<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>uim.model.ink API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>uim.model.ink</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
# Copyright Â© 2021 Wacom Authors. All Rights Reserved.
#
#  Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
import logging
import sys
import uuid
from abc import ABC
from typing import List, Any, Dict, Tuple, Optional

import numpy

from uim.codec.context.version import Version
from uim.codec.parser.base import FormatException
from uim.model.base import InkModelException, UUIDIdentifier, node_registration_debug
from uim.model.helpers.policy import HandleMissingDataPolicy
from uim.model.inkdata.brush import Brushes, BlendMode
from uim.model.inkdata.strokes import Stroke
from uim.model.inkinput.inputdata import SensorChannel, \
    InkSensorType, InkSensorMetricType, SensorChannelsContext, SensorContext, InputContext, InputContextRepository
from uim.model.inkinput.sensordata import SensorData
from uim.model.semantics import schema
from uim.model.semantics.node import InkNode, BoundingBox, StrokeNode, StrokeGroupNode, StrokeFragment
from uim.model.semantics.schema import CommonViews, SemanticTriple
from uim.model.helpers.treeiterator import PreOrderEnumerator

# Create the Logger
logger: Optional[logging.Logger] = None

if logger is None:
    logger: logging.Logger = logging.getLogger(__name__)
    logger.setLevel(logging.DEBUG)

    ch = logging.StreamHandler()
    ch.setLevel(logging.DEBUG)
    # create formatter and add it to the handlers
    formatter = logging.Formatter(&#39;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#39;)
    ch.setFormatter(formatter)
    # add the handlers to the logger
    logger.addHandler(ch)
    logger.info(&#39;Completed configuring logger()!&#39;)


class SensorDataRepository(ABC):
    &#34;&#34;&#34;
    SensorDataRepository
    ====================
    A collection of data repositories, holding raw sensor input, input device/provider configurations, sensor channel
    configurations, etc. Each data repository keeps certain data-sets isolated and is responsible for
    specific type(s) of data.

    Parameters
    ----------
    sensor_data: List[SensorData]
            List of sensor data items. [optional]
    &#34;&#34;&#34;

    def __init__(self, sensor_data: List[SensorData] = None):
        self.__sensor_data: List[SensorData] = sensor_data or []
        self.__map_id: Dict[uuid.UUID, int] = {}

    @property
    def sensor_data(self) -&gt; List[SensorData]:
        &#34;&#34;&#34;List of SensorData objects. (`List[SensorData]`)&#34;&#34;&#34;
        return self.__sensor_data

    @sensor_data.setter
    def sensor_data(self, sensor_data: list):
        self.__sensor_data = sensor_data
        self.__build_idx_map()

    def add(self, sensor_data: SensorData):
        &#34;&#34;&#34;
        Adding a sensor sample.

        Parameters
        ----------
        sensor_data: `SensorData`
            Adding a sensor data sample
        &#34;&#34;&#34;
        self.__sensor_data.append(sensor_data)
        self.__map_id[sensor_data.id] = len(self.__sensor_data) - 1

    def sensor_data_by_id(self, uimid: uuid.UUID) -&gt; SensorData:
        &#34;&#34;&#34;
        Returns the sensor data samples for a specific id.

        Parameters
        ----------
        uimid: `UUID`
            Id of the sensor data

        Returns
        -------
        instance: `SensorData`
            instance of the sensor data sample

        Raises
        ------
        InkModelException
            If `SensorData` for the id is not available.
        &#34;&#34;&#34;
        if uimid not in self.__map_id:
            raise InkModelException(&#39;No sensor data with id:={}&#39;.format(uimid))
        return self.__sensor_data[self.__map_id[uimid]]

    def __build_idx_map(self):
        &#34;&#34;&#34;Building an index to map the UUID to index in a list.&#34;&#34;&#34;
        self.__map_id = {}
        for idx, el in enumerate(self.sensor_data):
            self.__map_id[el.id] = idx

    def __eq__(self, other):
        if not isinstance(other, SensorDataRepository):
            return False
        map_sensor_data: dict = dict([(s.id, s) for s in other.sensor_data])
        for s in self.sensor_data:
            if s.id not in map_sensor_data:
                return False
            if s == map_sensor_data[s.id]:
                del map_sensor_data[s.id]
            else:
                return False
        return True

    def __repr__(self):
        return &#39;&lt;InputData : [sensor:={}]&gt;&#39;.format(self.__sensor_data)


class InkTree(ABC):
    &#34;&#34;&#34;
    InkTree
    =======
    The digital ink content, contained within a universal ink model, is organized in logical trees of ink nodes -
    they represent hierarchically organized ink-centric structures, and are also referred to as ink trees.

    Parameters
    ----------
    name: str -
        Name of the view
    &#34;&#34;&#34;

    def __init__(self, name: str = CommonViews.MAIN_INK_TREE.value):
        self.__name: str = name
        self.__model: Optional[InkModel] = None
        self.__root: Optional[StrokeGroupNode] = None

    @property
    def model(self) -&gt; &#39;InkModel&#39;:
        &#34;&#34;&#34;Reference to the model. (`InkModel`)&#34;&#34;&#34;
        return self.__model

    @model.setter
    def model(self, value: &#39;InkModel&#39;):
        self.__model = value

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;The primary name associated with this ink tree. (`str`)&#34;&#34;&#34;
        return self.__name

    @name.setter
    def name(self, value: str):
        self.__name = value

    @property
    def root(self) -&gt; StrokeGroupNode:
        &#34;&#34;&#34;Root node of the tree. (`StrokeGroupNode`)&#34;&#34;&#34;
        return self.__root

    @root.setter
    def root(self, root: StrokeGroupNode):
        root.__assert_not_owned__()
        if self.__root is not None:
            self.unregister_sub_tree(self.__root)
            self.__root = None
        self.register_sub_tree(root)
        self.__root = root

    def __iter__(self):
        return PreOrderEnumerator(self.__root)

    def __repr__(self):
        if self.__root:
            return f&#39;&lt;Ink Tree: [name:={self.name},  root id:={self.root}]&gt;&#39;
        return f&#39;&lt;Ink Tree: [name:={self.name}] - Empty tree&#39;

    def register_node(self, node: InkNode):
        &#34;&#34;&#34;
        Register node.

        Parameters
        ----------
        node: `InkNode`
            Node that needs to be registered
        &#34;&#34;&#34;
        if self.model is None:
            logger.warning(f&#34;InkTree with name {self.name} not yet attached to a model.&#34;)

        node.tree = self

        if self.model is not None:
            self.__model.register_node(node)

    def unregister_node(self, node: InkNode):
        &#34;&#34;&#34;
        Unregister node.

        Parameters
        ----------
        node: `InkNode`
            Node that needs to be unregistered
        &#34;&#34;&#34;
        if self.__model is not None:
            self.__model.unregister_node(node)

    def register_sub_tree(self, node: InkNode):
        &#34;&#34;&#34;
        Register sub tree.

        Parameters
        ----------
        node: `InkNode`
            Sub tree that needs to be registered
        &#34;&#34;&#34;
        if node.child_nodes_count() == 0:
            self.register_node(node)
        else:
            for n in PreOrderEnumerator(node):
                self.register_node(n)

    def unregister_sub_tree(self, node: InkNode):
        &#34;&#34;&#34;
        Unregister sub tree.

        Parameters
        ----------
        node: `InkNode`
            Sub tree that needs to be unregistered
        &#34;&#34;&#34;
        if node.child_nodes_count() == 0:
            self.unregister_node(node)
        else:
            for n in PreOrderEnumerator(node):
                self.unregister_node(n)


class InkModel(ABC):
    &#34;&#34;&#34;
    InkModel
    ========
    The Ink Model has the following logical sections:

    - **Data repositories** - a collection of data repositories, holding raw sensor input,
                              input device/provider configurations, splines, sensor channel configurations,
                              rendering configurations, etc. Each data repository keeps certain data-set isolated
                              and is responsible for specific type(s) of data.
    - **Logical data trees** - a collection of logical trees, representing structures of hierarchically
                               organized strokes.
    - **Semantic triple store** - an RDF/WODL compliant triple store, holding semantic information.

    Parameters
    ----------
    version: `Version`
            Version of the source (ink content file).

    Examples
    --------
    &gt;&gt;&gt; from uim.codec.writer.encoder.encoder_3_1_0 import UIMEncoder310
    &gt;&gt;&gt; from uim.model.base import UUIDIdentifier
    &gt;&gt;&gt; from uim.model.ink import InkModel, InkTree
    &gt;&gt;&gt; from uim.model.inkdata.brush import VectorBrush, BrushPolygon, BrushPolygonUri, RasterBrush, RotationMode,\
    &gt;&gt;&gt;  BlendMode
    &gt;&gt;&gt; from uim.model.inkdata.strokes import Spline, Style, Stroke, LayoutMask
    &gt;&gt;&gt; from uim.model.inkinput.inputdata import Environment, InkInputProvider, InkInputType, InputDevice,\
    &gt;&gt;&gt;    SensorChannel, InkSensorType, InkSensorMetricType, SensorChannelsContext, SensorContext, InputContext
    &gt;&gt;&gt; from uim.model.inkinput.sensordata import SensorData, InkState
    &gt;&gt;&gt; from uim.model.semantics import schema
    &gt;&gt;&gt; from uim.model.semantics.node import StrokeGroupNode, StrokeNode, StrokeFragment, URIBuilder
    &gt;&gt;&gt; from uim.model.semantics.schema import SemanticTriple, CommonViews
    &gt;&gt;&gt; from uim.utils.matrix import Matrix4x4
    &gt;&gt;&gt; # Creates an ink model from the scratch.
    &gt;&gt;&gt; ink_model: InkModel = InkModel()
    &gt;&gt;&gt; # Setting a unit scale factor
    &gt;&gt;&gt; ink_model.unit_scale_factor = 1.5
    &gt;&gt;&gt; # Using a 4x4 matrix for scaling
    &gt;&gt;&gt; ink_model.transform = Matrix4x4.create_scale(1.5)
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Properties are added as key-value pairs
    &gt;&gt;&gt; ink_model.properties.append((&#34;Author&#34;, &#34;John&#34;))
    &gt;&gt;&gt; ink_model.properties.append((&#34;PrimaryLanguage&#34;, &#34;en_US&#34;))
    &gt;&gt;&gt; ink_model.properties.append((&#34;OtherStuff&#34;, &#34;Yes&#34;))
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Create an environment
    &gt;&gt;&gt; env: Environment = Environment()
    &gt;&gt;&gt; env.properties.append((&#34;env.name&#34;, &#34;My Environment&#34;))
    &gt;&gt;&gt; env.properties.append((&#34;os.id&#34;, &#34;98765&#34;))
    &gt;&gt;&gt; env.properties.append((&#34;os.name&#34;, &#34;Windows&#34;))
    &gt;&gt;&gt; env.properties.append((&#34;os.version&#34;, &#34;10.0.18362.239&#34;))
    &gt;&gt;&gt; env.properties.append((&#34;os.build&#34;, &#34;239&#34;))
    &gt;&gt;&gt; env.properties.append((&#34;os.platform&#34;, &#34;whatever&#34;))
    &gt;&gt;&gt; ink_model.input_configuration.environments.append(env)
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Ink input provider can be pen, mouse or touch.
    &gt;&gt;&gt; provider: InkInputProvider = InkInputProvider(input_type=InkInputType.MOUSE)
    &gt;&gt;&gt; provider.properties.append((&#34;pen.id&#34;, &#34;1234567&#34;))
    &gt;&gt;&gt; ink_model.input_configuration.ink_input_providers.append(provider)
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Input device is the sensor (pen tablet, screen, etc.)
    &gt;&gt;&gt; input_device: InputDevice = InputDevice()
    &gt;&gt;&gt; input_device.properties.append((&#34;dev.id&#34;, &#34;123454321&#34;))
    &gt;&gt;&gt; input_device.properties.append((&#34;dev.manufacturer&#34;, &#34;Wacom&#34;))
    &gt;&gt;&gt; input_device.properties.append((&#34;dev.model&#34;, &#34;Mobile Studio Pro&#34;))
    &gt;&gt;&gt; input_device.properties.append((&#34;dev.cpu&#34;, &#34;Intel&#34;))
    &gt;&gt;&gt; input_device.properties.append((&#34;dev.graphics.display&#34;, &#34;Dell 1920x1080 32bit&#34;))
    &gt;&gt;&gt; input_device.properties.append((&#34;dev.graphics.adapter&#34;, &#34;NVidia&#34;))
    &gt;&gt;&gt; ink_model.input_configuration.devices.append(input_device)
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Create a group of sensor channels
    &gt;&gt;&gt; sensor_channels_tablet: list = [
    &gt;&gt;&gt;     SensorChannel(channel_type=InkSensorType.TIMESTAMP, metric=InkSensorMetricType.TIME, resolution=1.0),
    &gt;&gt;&gt;     SensorChannel(channel_type=InkSensorType.X, metric=InkSensorMetricType.LENGTH, resolution=1.0),
    &gt;&gt;&gt;     SensorChannel(channel_type=InkSensorType.Y, metric=InkSensorMetricType.LENGTH, resolution=1.0)
    &gt;&gt;&gt; ]
    &gt;&gt;&gt;
    &gt;&gt;&gt; scc_tablet: SensorChannelsContext = SensorChannelsContext(channels=sensor_channels_tablet,
    &gt;&gt;&gt;                                                           ink_input_provider_id=provider.id,
    &gt;&gt;&gt;                                                           input_device_id=input_device.id)
    &gt;&gt;&gt;
    &gt;&gt;&gt; # We can create an additional input device, for example one providing pressure via Bluetooth
    &gt;&gt;&gt; input_device_bluetooth: InputDevice = InputDevice()
    &gt;&gt;&gt; input_device_bluetooth.properties.append((&#34;dev.id&#34;, &#34;345456567&#34;))
    &gt;&gt;&gt; input_device_bluetooth.properties.append((&#34;dev.manufacturer&#34;, &#34;Apple&#34;))
    &gt;&gt;&gt; ink_model.input_configuration.devices.append(input_device_bluetooth)
    &gt;&gt;&gt;
    &gt;&gt;&gt; sensor_channels_bluetooth: list = [
    &gt;&gt;&gt;     SensorChannel(channel_type=InkSensorType.TIMESTAMP, metric=InkSensorMetricType.TIME, resolution=1.0),
    &gt;&gt;&gt;     SensorChannel(channel_type=InkSensorType.PRESSURE, metric=InkSensorMetricType.FORCE, resolution=1.0),
    &gt;&gt;&gt; ]
    &gt;&gt;&gt;
    &gt;&gt;&gt; scc_bluetooth: SensorChannelsContext = SensorChannelsContext(input_device_id=input_device_bluetooth.id,
    &gt;&gt;&gt;                                                              channels=sensor_channels_bluetooth)
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Add all sensor channel contexts
    &gt;&gt;&gt; sensor_context: SensorContext = SensorContext()
    &gt;&gt;&gt; sensor_context.add_sensor_channels_context(scc_tablet)
    &gt;&gt;&gt; sensor_context.add_sensor_channels_context(scc_bluetooth)
    &gt;&gt;&gt; ink_model.input_configuration.sensor_contexts.append(sensor_context)
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Create the input context using the Environment and the Sensor Context
    &gt;&gt;&gt; input_context: InputContext = InputContext(environment_id=env.id, sensor_context_id=sensor_context.id)
    &gt;&gt;&gt; ink_model.input_configuration.input_contexts.append(input_context)
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Create sensor data
    &gt;&gt;&gt; sensor_data_0: SensorData = SensorData(UUIDIdentifier.id_generator(), input_context_id=input_context.id,
    &gt;&gt;&gt;                                        state=InkState.PLANE)
    &gt;&gt;&gt;
    &gt;&gt;&gt; sensor_data_0.add_timestamp_data(sensor_channels_tablet[0], [0, 1, 2, 4, 5])
    &gt;&gt;&gt; sensor_data_0.add_data(sensor_channels_tablet[1],  [100.4, 103.7, 110.1])
    &gt;&gt;&gt; sensor_data_0.add_data(sensor_channels_tablet[2],  [200.1, 202.0, 207.0])
    &gt;&gt;&gt;
    &gt;&gt;&gt; sensor_data_0.add_timestamp_data(sensor_channels_bluetooth[0], [0, 1, 2])
    &gt;&gt;&gt;
    &gt;&gt;&gt; sensor_data_0.add_data(sensor_channels_bluetooth[1], [100, 200])
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Add sensor data to the model
    &gt;&gt;&gt; ink_model.sensor_data.add(sensor_data_0)
    &gt;&gt;&gt;
    &gt;&gt;&gt; # We need to define a brush polygon
    &gt;&gt;&gt; points: list = [(10, 10), (0, 10), (0, 0)]
    &gt;&gt;&gt; brush_polygons: list = [BrushPolygon(min_scale=0., points=points)]
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Create the brush object using polygons
    &gt;&gt;&gt; vector_brush_0: VectorBrush = VectorBrush(
    &gt;&gt;&gt;     &#34;app://qa-test-app/vector-brush/MyTriangleBrush&#34;,
    &gt;&gt;&gt;     brush_polygons)
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Add it to the model
    &gt;&gt;&gt; ink_model.brushes.add_vector_brush(vector_brush_0)
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Add a brush specified with shape Uris
    &gt;&gt;&gt; poly_uris: list = [
    &gt;&gt;&gt;     BrushPolygonUri(&#34;will://brush/3.0/shape/Circle?precision=20&amp;radius=1&#34;, 0.),
    &gt;&gt;&gt;     BrushPolygonUri(&#34;will://brush/3.0/shape/Ellipse?precision=20&amp;radiusX=1&amp;radiusY=0.5&#34;, 4.0)
    &gt;&gt;&gt; ]
    &gt;&gt;&gt;
    &gt;&gt;&gt; vector_brush_1: VectorBrush = VectorBrush(
    &gt;&gt;&gt;     &#34;app://qa-test-app/vector-brush/MyEllipticBrush&#34;,
    &gt;&gt;&gt;     poly_uris)
    &gt;&gt;&gt;
    &gt;&gt;&gt; raster_brush_0: RasterBrush = RasterBrush(
    &gt;&gt;&gt;     name=&#34;app://qa-test-app/raster-brush/MyRasterBrush&#34;,
    &gt;&gt;&gt;     spacing=10., scattering=5., rotation=RotationMode.TRAJECTORY, shape_textures=[bytes([10, 20]),
    &gt;&gt;&gt;                                                                                   bytes([30, 20])],
    &gt;&gt;&gt;     fill_width=2.0, fill_height=0.3,
    &gt;&gt;&gt;     fill_texture=bytes([10, 10, 20, 15, 17, 20, 25, 16, 34, 255, 23, 0, 34, 255, 23, 255]),
    &gt;&gt;&gt;     randomize_fill=False, blend_mode=BlendMode.SOURCE_OVER)
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Add it to the model
    &gt;&gt;&gt; ink_model.brushes.add_raster_brush(raster_brush_0)
    &gt;&gt;&gt;
    &gt;&gt;&gt; raster_brush_1: RasterBrush = RasterBrush(
    &gt;&gt;&gt;     name=&#34;app://qa-test-app/raster-brush/MyRasterBrush1&#34;,
    &gt;&gt;&gt;     spacing=10.0, scattering=5.0, rotation=RotationMode.TRAJECTORY, fill_width=2., fill_height=0.3,
    &gt;&gt;&gt;     fill_texture_uri=&#34;app://qa-test-app/raster-brush-fill/mixedShapesGL&#34;,
    &gt;&gt;&gt;     shape_texture_uris=[
    &gt;&gt;&gt;         &#34;app://qa-test-app/raster-brush-shape/mixedShapesGL_128x128&#34;,
    &gt;&gt;&gt;         &#34;app://qa-test-app/raster-brush-shape/mixedShapesGL_64x64&#34;,
    &gt;&gt;&gt;         &#34;app://qa-test-app/raster-brush-shape/mixedShapesGL_32x32&#34;,
    &gt;&gt;&gt;         &#34;app://qa-test-app/raster-brush-shape/mixedShapesGL_16x16&#34;
    &gt;&gt;&gt;     ], randomize_fill=False, blend_mode=BlendMode.SOURCE_OVER)
    &gt;&gt;&gt;
    &gt;&gt;&gt; ink_model.brushes.add_raster_brush(raster_brush_1)
    &gt;&gt;&gt; ink_model.brushes.add_vector_brush(vector_brush_1)
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Specify the layout of the stroke data, in this case the stroke will have variable X, Y and Size properties.
    &gt;&gt;&gt; layout_mask: int = LayoutMask.X.value | LayoutMask.Y.value | LayoutMask.SIZE.value
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Provide the stroke data - in this case 4 data points, each consisting of X, Y, Size
    &gt;&gt;&gt; path: list = [
    &gt;&gt;&gt;     10., 10.7, 1.0,
    &gt;&gt;&gt;     21.0, 20.2, 2.0,
    &gt;&gt;&gt;     30.0, 12.4, 2.1,
    &gt;&gt;&gt;     40.0, 15.0, 1.5
    &gt;&gt;&gt; ]
    &gt;&gt;&gt; # Create a spline object from the path data
    &gt;&gt;&gt; spline: Spline = Spline(layout_mask, path)
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Create some style
    &gt;&gt;&gt; style: Style = Style(brush_uri=vector_brush_0.name)
    &gt;&gt;&gt; style.path_point_properties.red = 1.0
    &gt;&gt;&gt; style.path_point_properties.green = 0.0
    &gt;&gt;&gt; style.path_point_properties.blue = 0.4
    &gt;&gt;&gt; style.path_point_properties.alpha = 1.0
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Create a stroke object. Note that it just exists, but is not in the model yet.
    &gt;&gt;&gt; stroke_0: Stroke = Stroke(sid=UUIDIdentifier.id_generator(), spline=spline, style=style)
    &gt;&gt;&gt; # Create a spline object - 9 data points, each consisting of X, Y, Size, Red, Green, Blue, Alpha
    &gt;&gt;&gt; spline_1: Spline = Spline(
    &gt;&gt;&gt;     LayoutMask.X.value | LayoutMask.Y.value | LayoutMask.SIZE.value | LayoutMask.RED.value | \
    &gt;&gt;&gt;     LayoutMask.GREEN.value
    &gt;&gt;&gt;     | LayoutMask.BLUE.value | LayoutMask.ALPHA.value,
    &gt;&gt;&gt;     [10.0, 10.7, 1.0, 0.5, 0.0, 0.1, 1.0,
    &gt;&gt;&gt;      21.0, 20.2, 2.0, 0.9, 0.4, 0.2, 0.8,
    &gt;&gt;&gt;      30.0, 12.4, 2.1, 0.7, 0.1, 0.1, 0.7,
    &gt;&gt;&gt;      40.0, 15.0, 1.5, 0.3, 0.5, 0.4, 1.0,
    &gt;&gt;&gt;      50.0, 45.0, 1.0, 0.3, 0.5, 0.4, 1.0,
    &gt;&gt;&gt;      41.0, 53.0, 1.1, 0.2, 0.3, 0.5, 0.9,
    &gt;&gt;&gt;      33.0, 73.0, 1.2, 0.6, 0.7, 0.4, 0.8,
    &gt;&gt;&gt;      20.0, 84.0, 1.3, 0.7, 0.8, 0.3, 0.7,
    &gt;&gt;&gt;      10.0, 91.0, 1.1, 0.7, 0.9, 0.2, 0.6]
    &gt;&gt;&gt; )
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Create a style
    &gt;&gt;&gt; style_1: Style = Style(brush_uri=raster_brush_0.name)
    &gt;&gt;&gt; style_1.path_point_properties.rotation = 0.35
    &gt;&gt;&gt;
    &gt;&gt;&gt; # The render mode URI can also be app specific like app://blabla
    &gt;&gt;&gt; # The URI will://rasterization/3.0/blend-mode/SourceOver is assumed and must not be set.
    &gt;&gt;&gt; style_1.render_mode_uri = &#34;will://rasterization/3.0/blend-mode/DestinationOver&#34;
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Create a stroke object. Note that it just exists, but is not in the model yet.
    &gt;&gt;&gt; stroke_1: Stroke = Stroke(UUIDIdentifier.id_generator(), spline=spline_1, style=style_1)
    &gt;&gt;&gt;
    &gt;&gt;&gt; # First you need a root group to contain the strokes
    &gt;&gt;&gt; root: StrokeGroupNode = StrokeGroupNode(UUIDIdentifier.id_generator())
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Assign the group as the root of the main ink tree
    &gt;&gt;&gt; ink_model.ink_tree = InkTree()
    &gt;&gt;&gt; ink_model.ink_tree.root = root
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Add a node for stroke 0
    &gt;&gt;&gt; stroke_node_0: StrokeNode = StrokeNode(stroke_0, StrokeFragment(0, 1, 0.0, 1.0))
    &gt;&gt;&gt; root.add(stroke_node_0)
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Add a node for stroke 1
    &gt;&gt;&gt; root.add(StrokeNode(stroke_1, StrokeFragment(0, 1, 0.0, 1.0)))
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Adding view for handwriting recognition results
    &gt;&gt;&gt; hwr_tree: InkTree = InkTree(CommonViews.HWR_VIEW.value)
    &gt;&gt;&gt; # Add view right after creation, to avoid warnings that tree is not yet attached
    &gt;&gt;&gt; ink_model.add_view(hwr_tree)
    &gt;&gt;&gt;
    &gt;&gt;&gt; hwr_root: StrokeGroupNode = StrokeGroupNode(UUIDIdentifier.id_generator())
    &gt;&gt;&gt; hwr_tree.root = hwr_root
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Here you can add the same strokes as in the main tree, but you can organize them in a different way
    &gt;&gt;&gt; # (put them in different groups)
    &gt;&gt;&gt; # You are not supposed to add strokes that are not already in the main tree.
    &gt;&gt;&gt; hwr_root.add(StrokeNode(stroke_0, StrokeFragment(0, 1, 0.0, 1.0)))
    &gt;&gt;&gt;
    &gt;&gt;&gt; # A view node can refer to a fragment of a stroke.
    &gt;&gt;&gt; hwr_root.add(StrokeNode(stroke_1, StrokeFragment(0, 1, 0.0, 1.0)))
    &gt;&gt;&gt;
    &gt;&gt;&gt; # The hwr root denotes a word
    &gt;&gt;&gt; ink_model.knowledge_graph.append(SemanticTriple(hwr_root.uri, syntax.CommonRDF.PRED_RDF_HAS_TYPE, syntax.WORD))
    &gt;&gt;&gt; ink_model.knowledge_graph.append(SemanticTriple(hwr_root.uri, syntax.Semantics.PRED_IS, &#34;Wacom&#34;))
    &gt;&gt;&gt;
    &gt;&gt;&gt; # We need an URI builder
    &gt;&gt;&gt; uri_builder: URIBuilder = URIBuilder()
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Create a named entity
    &gt;&gt;&gt; named_entity_uri: str = uri_builder.build_named_entity_uri(UUIDIdentifier.id_generator())
    &gt;&gt;&gt; ink_model.knowledge_graph.append(SemanticTriple(hwr_root.uri, schema.HAS_NAMED_ENTITY,
    &gt;&gt;&gt;                                                 named_entity_uri))
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Add knowledge for the named entity
    &gt;&gt;&gt; ink_model.knowledge_graph.append(SemanticTriple(named_entity_uri, &#34;entityType&#34;, &#34;Organization&#34;))
    &gt;&gt;&gt; ink_model.knowledge_graph.append(SemanticTriple(named_entity_uri, &#34;basedIn&#34;, &#34;Japan&#34;))
    &gt;&gt;&gt; ink_model.knowledge_graph.append(SemanticTriple(named_entity_uri, &#34;hasConfidence&#34;, &#34;0.85&#34;))
    &#34;&#34;&#34;

    def __init__(self, version: Version = None):
        self.__input_data: SensorDataRepository = SensorDataRepository()
        self.__version: Version = version
        self.__brushes: Brushes = Brushes()
        self.__ink_tree: Optional[InkTree] = None
        self.__views: List[InkTree] = []
        self.__knowledge_graph: schema.TripleStore = schema.TripleStore()
        self.__transform: numpy.ndarray = numpy.identity(4, dtype=float)
        self.__default_transform: bool = True
        self.__properties: List[Tuple[str, str]] = []
        self.__unit_scale_factor: float = 1.
        self.__input_configuration: InputContextRepository = InputContextRepository()
        self.__map: Dict[str, InkNode] = {}

    @property
    def version(self) -&gt; Version:
        &#34;&#34;&#34;Version of ink content file used to create the model. (`Version`, read-only)&#34;&#34;&#34;
        return self.__version

    @property
    def input_configuration(self) -&gt; InputContextRepository:
        &#34;&#34;&#34;Input context data repository. (`InputContextRepository`)&#34;&#34;&#34;
        return self.__input_configuration

    @input_configuration.setter
    def input_configuration(self, value: InputContextRepository):
        self.__input_configuration = value

    @property
    def unit_scale_factor(self) -&gt; float:
        &#34;&#34;&#34; LocalUnit * UnitScaleFactor = DIP (DIP = 1/96 of a logical Inch). (&#39;float&#39;)&#34;&#34;&#34;
        return self.__unit_scale_factor

    @unit_scale_factor.setter
    def unit_scale_factor(self, value: float):
        self.__unit_scale_factor = value

    @property
    def sensor_data(self) -&gt; SensorDataRepository:
        &#34;&#34;&#34;Input data repository; sensor data. (`SensorDataRepository`)&#34;&#34;&#34;
        return self.__input_data

    @property
    def brushes(self) -&gt; Brushes():
        &#34;&#34;&#34;All brushes (vector and raster brushes). (`Brushes`)&#34;&#34;&#34;
        return self.__brushes

    @property
    def ink_tree(self) -&gt; InkTree:
        &#34;&#34;&#34;Main ink tree. (``InkTree)&#34;&#34;&#34;
        return self.__ink_tree

    @ink_tree.setter
    def ink_tree(self, ink_tree: InkTree):
        self.add_tree(ink_tree)

    @property
    def strokes(self) -&gt; List[Stroke]:
        &#34;&#34;&#34;List of all strokes. (`List[Stroke]`, read-only)&#34;&#34;&#34;
        strokes: List[Stroke] = []
        for node in PreOrderEnumerator(self.ink_tree.root):
            if isinstance(node, StrokeNode):
                strokes.append(node.stroke)
        return strokes

    def stroke_by_id(self, stroke_uuid: uuid.UUID) -&gt; Stroke:
        &#34;&#34;&#34;
        Returns the stroke for a specific UUID.

        Parameters
        ----------
        stroke_uuid: `UUID`
            ID of the stroke

        Returns
        -------
        stroke: `Stroke`
            Instance of the  stroke
        &#34;&#34;&#34;
        for node in PreOrderEnumerator(self.ink_tree.root):
            if isinstance(node, StrokeNode):
                if node.stroke.id == stroke_uuid:
                    return node.stroke
        raise InkModelException(f&#34;Stroke with id {stroke_uuid} does not exist in main tree.&#34;)

    @staticmethod
    def collect_strokes(tree: InkTree) -&gt; List[Stroke]:
        strokes: List[Stroke] = []
        for node in PreOrderEnumerator(tree.root):
            if isinstance(node, StrokeNode):
                strokes.append(node.stroke)
        return strokes

    @property
    def views(self) -&gt; Tuple[InkTree]:
        &#34;&#34;&#34;List of views.&#34;&#34;&#34;
        return tuple(self.__views)

    def add_tree(self, tree: InkTree):
        &#34;&#34;&#34;Adding an ink tree to the model.
        :param tree: InkTree -
            Instance of the ink tree
        :raises:
            InkModelException - If name is already assigned to an ink model or
        &#34;&#34;&#34;
        if tree.model is not None:
            raise InkModelException(f&#34;InkTree with name {tree.name} is already assigned to an ink model.&#34;)

        if self.has_tree(tree.name):
            raise InkModelException(f&#34;InkTree with name {tree.name} is already assigned to the current ink model.&#34;)

        tree.model = self
        if tree.name == &#39;&#39; or tree.name == CommonViews.MAIN_INK_TREE.value:
            self.__ink_tree = tree
        else:
            self.__views.append(tree)

        if tree.root is not None:
            tree.register_sub_tree(tree.root)

    def remove_tree(self, name: str):
        &#34;&#34;&#34;Removing view tree from model.
        :param name: str -
            Name of the tree that should be removed

        &#34;&#34;&#34;
        tree: InkTree = self.tree(name)
        tree.unregister_sub_tree(tree.root)
        if tree.name == &#39;&#39; or tree.name == CommonViews.MAIN_INK_TREE.value:
            self.__ink_tree = None
        else:
            self.__views.remove(tree)

    def tree(self, name: str) -&gt; InkTree:
        &#34;&#34;&#34;Return named tree.
        :returns: tree for defined name
        &#34;&#34;&#34;
        if name == CommonViews.MAIN_INK_TREE.value:
            return self.ink_tree
        else:
            for v in self.views:
                if v.name == name:
                    return v
        raise InkModelException(f&#34;InkTree with name {name} is not found.&#34;)

    def has_tree(self, name: str) -&gt; bool:
        &#34;&#34;&#34;Check if the named tree exists.
        :param name: str -
            Name of the tree
        :returns: flag if the tree exists
        &#34;&#34;&#34;
        if name == CommonViews.MAIN_INK_TREE.value:
            return self.ink_tree is not None
        else:
            for v in self.views:
                if v.name == name:
                    return True
        return False

    def clear_views(self):
        &#34;&#34;&#34;Clears the views.&#34;&#34;&#34;
        self.__views = []

    @property
    def knowledge_graph(self) -&gt; schema.TripleStore:
        &#34;&#34;&#34;Knowledge graph encoding all knowledge about the ink strokes.&#34;&#34;&#34;
        return self.__knowledge_graph

    @property
    def transform(self) -&gt; numpy.array:
        &#34;&#34;&#34;Transformation matrix.&#34;&#34;&#34;
        return self.__transform

    @transform.setter
    def transform(self, transform: list):
        self.__transform = numpy.array(transform)
        self.__default_transform = False

    @property
    def default_transform(self) -&gt; bool:
        &#34;&#34;&#34;Flag if the transform has been updated.&#34;&#34;&#34;
        return self.__default_transform

    @property
    def properties(self) -&gt; list:
        &#34;&#34;&#34;Returns the properties for ink object.&#34;&#34;&#34;
        return self.__properties

    @properties.setter
    def properties(self, properties: list):
        self.__properties = properties

    def add_property(self, name: str, value: str):
        &#34;&#34;&#34;Adds a property.
        :param name: name of the property
        :param value: value of the property
        &#34;&#34;&#34;
        self.__properties.append((name, value))

    def view_root(self, name: str) -&gt; StrokeGroupNode:
        &#34;&#34;&#34;Returns the root for a view.
        :param name: CommonViews -
            Name of the view
        :return : root of named view
        :raises:
            KeyError: View with name does not exist
        &#34;&#34;&#34;
        return self.view(name).root

    def view(self, name: str) -&gt; InkTree:
        &#34;&#34;&#34;Returns the view.
        :param name: CommonViews -
            Name of the view
        :return : instance of the name
        :raises:
            KeyError: View with name does not exist
        &#34;&#34;&#34;
        for v in self.__views:
            if v.name == name:
                return v
        raise KeyError(&#39;No view with name:={}&#39;.format(name))

    def add_view(self, view: InkTree):
        &#34;&#34;&#34;Adding a view to the InkObject.
        :param view: View object
        &#34;&#34;&#34;
        self.add_tree(view)

    def add_semantic_triple(self, subject: str, predicate: str, obj: str):
        &#34;&#34;&#34;Adding a semantic triple to the object.

        :param subject: subject of the statement
        :param predicate: predicate of the statement
        :param obj: object of the statement
        &#34;&#34;&#34;
        self.__knowledge_graph.add_semantic_triple(subject, predicate, obj)

    def remove_semantic_triple(self, subject: str, predicate: str, obj: str):
        &#34;&#34;&#34;Remove a semantic triple from the object.

        :param subject:
        :param predicate:
        :param obj:
        &#34;&#34;&#34;
        self.__knowledge_graph.remove_semantic_triple(schema.SemanticTriple(subject, predicate, obj))

    def get_semantic_statement(self, subject: str) -&gt; schema.SemanticTriple:
        &#34;&#34;&#34;Returns the document property (or the optional default value).

        :param subject: str -
            key for property
        :return: value or None
        :raises:
            InkModelException: Raised if no semantic triple is existing for subject.
        &#34;&#34;&#34;
        for sem in self.knowledge_graph.statements:
            if sem.subject == subject:
                return sem
        raise InkModelException(&#39;No semantic triple for subject:= {}.&#39;.format(subject))

    def clear_knowledge_graph(self):
        &#34;&#34;&#34;Clears the knowledge graph.&#34;&#34;&#34;
        self.__knowledge_graph.clear_statements()

    def build_stroke_cache(self, stroke: Stroke):
        &#34;&#34;&#34;
        Build stroke cache.

        Parameters
        ----------
        stroke: Stroke
            Stroke for cache

        &#34;&#34;&#34;
        (ts, p) = self.get_stroke_timestamp_and_pressure_values(stroke)
        stroke.set_timestamp_values(ts)
        stroke.set_pressure_values(p)

    @staticmethod
    def clear_stroke_cache(stroke: Stroke):
        &#34;&#34;&#34;
        Clear stroke cache.

        Parameters
        ----------
        stroke: `Stroke`
            Stroke to clear.
        &#34;&#34;&#34;
        stroke.set_timestamp_values(None)
        stroke.set_pressure_values(None)

    def get_stroke_timestamp_and_pressure_values(self, stroke: Stroke, duplicate_first_and_last: bool = True) \
            -&gt; Tuple[List[float], List[float]]:
        &#34;&#34;&#34;
        Gets the timestamp and pressure values.

        Parameters
        ----------
        stroke: `Stroke`
            Stroke
        duplicate_first_and_last: `bool`
            Duplicate first and last

        Returns
        -------
        timestamps:  List[float]
            List of timestamp values
        pressure_values:  List[float]
            List of pressure values
        &#34;&#34;&#34;
        sd: SensorData = self.sensor_data.sensor_data_by_id(stroke.sensor_data_id)
        sensor_channels: list = self.input_configuration.sensor_contexts[0].sensor_channels_contexts[0] \
            .channels

        t_channel_id = [c.id for c in sensor_channels if c.type == InkSensorType.TIMESTAMP][0]
        p_channel_id = [c.id for c in sensor_channels if c.type == InkSensorType.PRESSURE][0]

        ts: list = []
        ps: list = []

        for cd in sd.data_channels:
            if cd.id == t_channel_id:
                ts = cd.values.copy()
            elif cd.id == p_channel_id:
                ps = cd.values.copy()

        if duplicate_first_and_last:
            ts.insert(0, ts[0])
            ts.append(ts[-1])

            ps.insert(0, ps[0])
            ps.append(ps[-1])

        return ts, ps

    def get_strokes_as_strided_array(self, layout: str = &#34;xytp&#34;,
                                     policy: HandleMissingDataPolicy = HandleMissingDataPolicy.FILL_WITH_ZEROS) \
            -&gt; Tuple[List, str]:
        &#34;&#34;&#34;
        Returns all the strokes in the document, where each stroke is an array with stride 4.

        Parameters
        ----------
        layout: str -
            Layout string - &#39;xytp&#39; (x, y, timestamp, pressure).
        policy: HandleMissingDataPolicy -
            Policy to handle missing data.

        Returns
        -------
        array: `List`
            Strided array
        layout: `str`
            Layout string
        &#34;&#34;&#34;

        if layout != &#34;xytp&#34;:
            raise ValueError(&#34;Unsupported layout: %s&#34; % layout)

        strokes: List[Stroke] = self.strokes
        result: List = []
        for stroke in strokes:
            # Remove the first and last element, which are added by the spline producer
            xs = stroke.splines_x[1:-1]
            ys = stroke.splines_y[1:-1]

            sd: SensorData = self.sensor_data.sensor_data_by_id(stroke.sensor_data_id)

            sc_ts: Optional[SensorChannel] = None
            sc_pressure: Optional[SensorChannel] = None

            input_context: InputContext = self.input_configuration.get_input_context(sd.input_context_id)
            if input_context is not None:
                sensor_context = self.input_configuration.get_sensor_context(input_context.sensor_context_id)
                if sensor_context is not None:
                    sc_ts = None
                    sc_pressure = None

                    if sensor_context.has_channel_type(InkSensorType.TIMESTAMP):
                        sc_ts = sensor_context.get_channel_by_type(InkSensorType.TIMESTAMP)

                    if sensor_context.has_channel_type(InkSensorType.PRESSURE):
                        sc_pressure = sensor_context.get_channel_by_type(InkSensorType.PRESSURE)
            if sd is None or sc_ts is None or sd.get_data_by_id(sc_ts.id) is None:
                ts = []
            else:
                ts = sd.get_data_by_id(sc_ts.id).values.copy()

            if sd is None or sc_pressure is None or sd.get_data_by_id(sc_pressure.id) is None:
                ps = []
            else:
                ps = sd.get_data_by_id(sc_pressure.id).values.copy()

            xs = xs[0:len(ts)]
            ys = ys[0:len(ts)]

            # Handle missing timestamp according to policy
            if len(ts) == 0:
                if policy == HandleMissingDataPolicy.SKIP_STROKE:
                    continue
                elif policy == HandleMissingDataPolicy.THROW_EXCEPTION:
                    raise ValueError(&#34;There is no timestamp data for this stroke.&#34;)

            # Handle missing pressure according to policy
            if len(ps) == 0:
                if policy == HandleMissingDataPolicy.SKIP_STROKE:
                    continue
                elif policy == HandleMissingDataPolicy.THROW_EXCEPTION:
                    raise ValueError(&#34;There is no pressure data for this stroke.&#34;)

            points = []

            sensor_data_mapping = stroke.sensor_data_mapping

            if len(sensor_data_mapping) == 0:  # Mapping is 1:1
                limit = min(stroke.sensor_data_offset + len(xs), len(ts))
                sensor_data_mapping = range(stroke.sensor_data_offset, limit)

            i = 0

            for map_i in sensor_data_mapping:
                points.append(xs[i])
                points.append(ys[i])

                if len(ts) == 0:
                    points.append(0)
                else:
                    points.append(ts[map_i])

                if len(ps) == 0:
                    points.append(0)
                else:
                    points.append(ps[map_i])

                i += 1

            result.append(points)

        return result, layout

    def sensor_data_lookup(self, stroke: Stroke, ink_sensor_type: InkSensorType,
                           return_channel_data_instance: bool = False):
        sd: SensorData = self.sensor_data.sensor_data_by_id(stroke.sensor_data_id)

        sc = None

        input_context = self.input_configuration.get_input_context(sd.input_context_id)
        if input_context is not None:
            sensor_context = self.input_configuration.get_sensor_context(input_context.sensor_context_id)
            if sensor_context is not None:

                if sensor_context.has_channel_type(ink_sensor_type):
                    sc = sensor_context.get_channel_by_type(ink_sensor_type)

        if sd is None or sc is None or sd.get_data_by_id(sc.id) is None:
            return None if return_channel_data_instance else []
        else:
            return sd.get_data_by_id(sc.id) if return_channel_data_instance else sd.get_data_by_id(sc.id).values.copy()

    def calculate_bounds_recursively(self, node: InkNode):
        &#34;&#34;&#34;
        Calculates the bounds recursively.

        Parameters
        ----------
        node: Node
            Node of the tree
        &#34;&#34;&#34;
        x_min: float = sys.float_info.max
        x_max: float = 0.
        y_min: float = sys.float_info.max
        y_max: float = 0.
        if isinstance(node, StrokeNode):
            stroke_node: StrokeNode = node
            x_min: float = min(stroke_node.stroke.spline_min_x, x_min)
            x_max: float = max(stroke_node.stroke.spline_max_x, x_max)
            y_min: float = min(stroke_node.stroke.spline_min_y, y_min)
            y_max: float = max(stroke_node.stroke.spline_max_y, y_max)
            node.group_bounding_box = BoundingBox(x_min, y_min, x_max - x_min, y_max - y_min)
        elif isinstance(node, StrokeGroupNode):
            for child_node in node.children:
                self.calculate_bounds_recursively(child_node)
                child_bbox: BoundingBox = child_node.group_bounding_box
                x_min: float = min(child_bbox.x, x_min)
                x_max: float = max(child_bbox.x + child_bbox.width, x_max)
                y_min: float = min(child_bbox.y, y_min)
                y_max: float = max(child_bbox.y + child_bbox.height, y_max)
            bbox: BoundingBox = BoundingBox(x_min, y_min, x_max - x_min, y_max - y_min)
            node.group_bounding_box = bbox

    def has_properties(self) -&gt; bool:
        &#34;&#34;&#34;
        Checks if the Ink Model has properties configured.

        Returns
        --------
        flag: `bool`
            Flag if properties have been configured for InkModel
        &#34;&#34;&#34;
        return len(self.properties) &gt; 0

    def has_input_data(self) -&gt; bool:
        &#34;&#34;&#34;
        Checks if the Ink Model has input data configured.

        Returns
        -------
        flag: `bool`
            Flag if input data have been configured for InkModel
        &#34;&#34;&#34;
        return len(self.sensor_data.sensor_data) &gt; 0 or self.input_configuration.has_configuration()

    def has_brushes(self) -&gt; bool:
        &#34;&#34;&#34;
        Checks if the Ink Model has brushes configured.

        Returns
        -------
        flag: `bool`
            Flag if brushes have been configured for InkModel
        &#34;&#34;&#34;
        return len(self.brushes.vector_brushes) &gt; 0 or len(self.brushes.raster_brushes) &gt; 0

    def has_ink_data(self) -&gt; bool:
        &#34;&#34;&#34;
        Checks if the Ink Model has ink data configured.

        Returns
        -------
        flag: `bool`
            Flag if ink data have been configured for InkModel
        &#34;&#34;&#34;
        try:
            return self.ink_tree is not None
        except FormatException:
            return False

    def has_knowledge_graph(self) -&gt; bool:
        &#34;&#34;&#34;
        Checks if the Ink Model has knowledge graph configured.

        Returns
        -------
        flag: `bool`
            Flag if knowledge graph have been configured for InkModel
        &#34;&#34;&#34;
        return len(self.knowledge_graph.statements) &gt; 0

    def has_ink_structure(self) -&gt; bool:
        &#34;&#34;&#34;
        Checks if the Ink Model has ink structure configured.

        Returns
        -------
        flag: `bool`
            Flag if input data have been configured for InkModel
        &#34;&#34;&#34;
        try:
            if self.ink_tree is None:
                return False
            return self.ink_tree.root is not None
        except FormatException:
            return False

    def clone_stroke_node(self, stroke_node: StrokeNode,  target_parent_node: StrokeGroupNode = None,
                          clone_semantics: bool = True) -&gt; StrokeNode:
        &#34;&#34;&#34;
        Cloning a stroke node.

        Parameters
        ----------
        stroke_node: `StrokeNode`
            Stroke node which shall be cloned

        target_parent_node: `StrokeGroupNode`
            Target node

        clone_semantics: `bool`
            Cloning semantics

        Returns
        -------
            stroke: `StrokeNode`
                Cloned stroke
        &#34;&#34;&#34;
        if stroke_node.fragment is not None:
            f = stroke_node.fragment
            fragment = StrokeFragment(f.from_point_index, f.to_point_index, f.from_t_value, f.to_t_value)
        else:
            fragment = None

        new_node: StrokeNode = StrokeNode(stroke=stroke_node.stroke, fragment=fragment)

        if clone_semantics:
            triples = self.knowledge_graph.filter(stroke_node.uri)
            t: SemanticTriple
            for t in triples:
                self.knowledge_graph.add_semantic_triple(new_node.uri, t.predicate, t.object)

        if target_parent_node is not None:
            target_parent_node.add(new_node)

        return new_node

    def clone_stroke_group_node(self, stroke_group_node: StrokeGroupNode,
                                target_parent_node: StrokeGroupNode = None,
                                clone_semantics: bool = True,
                                clone_child_stroke_nodes: bool = True,
                                clone_child_group_nodes: bool = False,
                                raise_exception: bool = False,
                                store_source_node_reference_transient_key: str = None) -&gt; StrokeGroupNode:
        &#34;&#34;&#34;
        Clone stroke group node.

        Parameters
        ----------
        stroke_group_node: `StrokeGroupNode`
            StrokeGroupNode to be cloned.
        target_parent_node: `StrokeGroupNode`
            Target node
        clone_semantics: `bool`
            Clone semantics [default:=True]
        clone_child_stroke_nodes: `bool`
            Clone child stroke nodes [default:=True]
        clone_child_group_nodes: bool
            Clone child group nodes [default:=False]
        raise_exception: bool
            Raise exceptions [default:=False]
        store_source_node_reference_transient_key: str
            Store source node reference.

        Returns
        -------
        new_stroke_group_node: `StrokeGroupNode`
            Cloned `StrokeGroupNode`

        Raises
        ------
        InkModelException
            If cloning needs to be aborted.
        &#34;&#34;&#34;
        new_node: StrokeGroupNode = StrokeGroupNode(UUIDIdentifier.id_generator())

        if target_parent_node is not None:
            target_parent_node.add(new_node)

        if clone_semantics:
            triples = self.knowledge_graph.filter(stroke_group_node.uri)
            t: SemanticTriple
            for t in triples:
                self.knowledge_graph.add_semantic_triple(new_node.uri, t.predicate, t.object)

        if clone_child_stroke_nodes or clone_child_group_nodes:
            for n in stroke_group_node.children:
                child_clone: Optional[InkNode] = None

                if isinstance(n, StrokeNode):
                    if clone_child_stroke_nodes:
                        child_clone = self.clone_stroke_node(n, target_parent_node=new_node,
                                                             clone_semantics=clone_semantics)
                    elif raise_exception:
                        raise InkModelException(&#34;Cloning aborted: Stroke node would be left behind if we continue.&#34;)

                elif isinstance(n, StrokeGroupNode):
                    if clone_child_group_nodes:
                        child_clone = self.clone_stroke_group_node(n, target_parent_node=new_node,
                                                                   clone_semantics=clone_semantics,
                                                                   clone_child_stroke_nodes=clone_child_stroke_nodes,
                                                                   clone_child_group_nodes=clone_child_group_nodes,
                                                                   raise_exception=raise_exception)
                    elif raise_exception:
                        raise InkModelException(&#34;Cloning aborted: Group node would be left behind if we continue.&#34;)

                if store_source_node_reference_transient_key is not None:
                    child_clone.transient_tag = {store_source_node_reference_transient_key: n}
        return new_node

    def register_node(self, node: InkNode):
        &#34;&#34;&#34;
        Register ink node.

        Parameters
        ----------
        node: `InkNode`
            Reference to node.

        Raises
        ------
        InkModelException
            If Node with URI already exist in the tree
        &#34;&#34;&#34;
        if self.__map.get(node.uri) is not None:
            raise InkModelException(f&#39;An ink node with uri {node.uri} already exists in the model.&#39;)
        else:
            if node_registration_debug:
                logger.debug(f&#34;Registering node {node.uri}&#34;)

        self.__map[node.uri] = node

    def is_node_registered(self, node: InkNode):
        &#34;&#34;&#34;
        Check if node is registered.

        Parameters
        ----------
        node: `InkNode`
            Node to check

        Returns
        -------
        flag: `bool`
            Flag if node is already registered in tree.
        &#34;&#34;&#34;
        return self.__map.get(node.uri) is not None

    def unregister_node(self, node: InkNode):
        &#34;&#34;&#34;
        Unregister a node.

        Parameters
        ----------
        node: `InkNode`
            Node to unregister

        Notes
        -----
        This function removes the triples for the node as well.

        &#34;&#34;&#34;
        if node_registration_debug:
            logger.debug(f&#34;Unregistering node {node.uri}&#34;)
            
        if node.tree is not None:
            triples = self.knowledge_graph.filter(node.uri)
            if node_registration_debug:
                logger.debug(f&#34;Found {len(triples)} triples for {node.uri}&#34;)
            for t in triples:
                if node_registration_debug:
                    logger.debug(f&#34;Removing semantic triple: {str(t)}&#34;)
                self.knowledge_graph.remove_semantic_triple(t)

            if node_registration_debug:
                triples = self.knowledge_graph.filter(node.uri)
                logger.debug(f&#34;Sanity check =&gt; Found {len(triples)} triples for {node.uri}&#34;)

        del self.__map[node.uri]

    def remove_node(self, node: InkNode):
        &#34;&#34;&#34;
        Remove a node.

        Parameters
        ----------
        node: `InkNode`
           Node to be remove

        Notes
        -----
        This function removes the triples and the node as well.

       &#34;&#34;&#34;
        # First remove the triples
        self.unregister_node(node)
        if node.parent is not None:
            node.parent.remove(node)

    def __eq__(self, other: Any):
        if not isinstance(other, InkModel):
            return False
        other_model: InkModel = other
        if self.has_properties() == other_model.has_properties():
            map_prop: dict = dict(other_model.properties)
            for key, value in self.properties:
                if key in map_prop:
                    if value != map_prop[key]:
                        return False
                    else:
                        del map_prop[key]
                else:
                    return False
            if len(map_prop) &gt; 0:
                return False
        else:
            return False
        if self.has_input_data() == other_model.has_input_data():
            if self.has_input_data():
                if self.sensor_data != other_model.sensor_data:
                    return False
        else:
            return False
        if self.has_brushes() == other_model.has_input_data():
            pass
        else:
            return False
        if self.has_ink_data() == other_model.has_ink_data():
            pass
        else:
            return False
        if self.has_knowledge_graph() == other_model.has_knowledge_graph():
            pass
        else:
            return False
        if self.has_ink_structure() == other_model.has_ink_structure():
            pass
        else:
            return False
        return True

    def __repr__(self):
        parts: str = &#39;&#39;
        prefix: str = &#39;&#39;
        if self.has_properties():
            parts += f&#39;Properties (properties:={len(self.properties)})&#39;
            prefix = &#39;, &#39;
        if self.has_input_data():
            parts += prefix + f&#39;Input Data (sensor data:={len(self.sensor_data.sensor_data)})&#39;
            prefix = &#39;, &#39;
        if self.has_brushes():
            parts += prefix + f&#39;Brushes (vector:={len(self.brushes.vector_brushes)}, &#39;
            parts += f&#39;raster:={len(self.brushes.raster_brushes)})&#39;
            prefix = &#39;, &#39;
        if self.has_ink_data():
            parts += prefix + f&#39;Ink Data (ink data:={len(self.strokes)})&#39;
            prefix = &#39;, &#39;
        if self.has_knowledge_graph():
            parts += prefix + f&#39;Knowledge graph (statements:={len(self.knowledge_graph.statements)})&#39;
            prefix = &#39;, &#39;
        if self.has_ink_structure():
            parts += prefix + f&#39;Ink Structure (main:={1 if self.ink_tree is not None else 0},views:={len(self.views)})&#39;
        return &#39;&lt;InkModel - [{}]&gt;&#39;.format(parts)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="uim.model.ink.InkModel"><code class="flex name class">
<span>class <span class="ident">InkModel</span></span>
<span>(</span><span>version:Â <a title="uim.codec.context.version.Version" href="../codec/context/version.html#uim.codec.context.version.Version">Version</a>Â =Â None)</span>
</code></dt>
<dd>
<div class="desc"><h1 id="inkmodel">InkModel</h1>
<p>The Ink Model has the following logical sections:</p>
<ul>
<li><strong>Data repositories</strong> - a collection of data repositories, holding raw sensor input,
input device/provider configurations, splines, sensor channel configurations,
rendering configurations, etc. Each data repository keeps certain data-set isolated
and is responsible for specific type(s) of data.</li>
<li><strong>Logical data trees</strong> - a collection of logical trees, representing structures of hierarchically
organized strokes.</li>
<li><strong>Semantic triple store</strong> - an RDF/WODL compliant triple store, holding semantic information.</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>version</code></strong> :&ensp;<code>Version</code></dt>
<dd>Version of the source (ink content file).</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from uim.codec.writer.encoder.encoder_3_1_0 import UIMEncoder310
&gt;&gt;&gt; from uim.model.base import UUIDIdentifier
&gt;&gt;&gt; from uim.model.ink import InkModel, InkTree
&gt;&gt;&gt; from uim.model.inkdata.brush import VectorBrush, BrushPolygon, BrushPolygonUri, RasterBrush, RotationMode,    &gt;&gt;&gt;  BlendMode
&gt;&gt;&gt; from uim.model.inkdata.strokes import Spline, Style, Stroke, LayoutMask
&gt;&gt;&gt; from uim.model.inkinput.inputdata import Environment, InkInputProvider, InkInputType, InputDevice,    &gt;&gt;&gt;    SensorChannel, InkSensorType, InkSensorMetricType, SensorChannelsContext, SensorContext, InputContext
&gt;&gt;&gt; from uim.model.inkinput.sensordata import SensorData, InkState
&gt;&gt;&gt; from uim.model.semantics import schema
&gt;&gt;&gt; from uim.model.semantics.node import StrokeGroupNode, StrokeNode, StrokeFragment, URIBuilder
&gt;&gt;&gt; from uim.model.semantics.schema import SemanticTriple, CommonViews
&gt;&gt;&gt; from uim.utils.matrix import Matrix4x4
&gt;&gt;&gt; # Creates an ink model from the scratch.
&gt;&gt;&gt; ink_model: InkModel = InkModel()
&gt;&gt;&gt; # Setting a unit scale factor
&gt;&gt;&gt; ink_model.unit_scale_factor = 1.5
&gt;&gt;&gt; # Using a 4x4 matrix for scaling
&gt;&gt;&gt; ink_model.transform = Matrix4x4.create_scale(1.5)
&gt;&gt;&gt;
&gt;&gt;&gt; # Properties are added as key-value pairs
&gt;&gt;&gt; ink_model.properties.append((&quot;Author&quot;, &quot;John&quot;))
&gt;&gt;&gt; ink_model.properties.append((&quot;PrimaryLanguage&quot;, &quot;en_US&quot;))
&gt;&gt;&gt; ink_model.properties.append((&quot;OtherStuff&quot;, &quot;Yes&quot;))
&gt;&gt;&gt;
&gt;&gt;&gt; # Create an environment
&gt;&gt;&gt; env: Environment = Environment()
&gt;&gt;&gt; env.properties.append((&quot;env.name&quot;, &quot;My Environment&quot;))
&gt;&gt;&gt; env.properties.append((&quot;os.id&quot;, &quot;98765&quot;))
&gt;&gt;&gt; env.properties.append((&quot;os.name&quot;, &quot;Windows&quot;))
&gt;&gt;&gt; env.properties.append((&quot;os.version&quot;, &quot;10.0.18362.239&quot;))
&gt;&gt;&gt; env.properties.append((&quot;os.build&quot;, &quot;239&quot;))
&gt;&gt;&gt; env.properties.append((&quot;os.platform&quot;, &quot;whatever&quot;))
&gt;&gt;&gt; ink_model.input_configuration.environments.append(env)
&gt;&gt;&gt;
&gt;&gt;&gt; # Ink input provider can be pen, mouse or touch.
&gt;&gt;&gt; provider: InkInputProvider = InkInputProvider(input_type=InkInputType.MOUSE)
&gt;&gt;&gt; provider.properties.append((&quot;pen.id&quot;, &quot;1234567&quot;))
&gt;&gt;&gt; ink_model.input_configuration.ink_input_providers.append(provider)
&gt;&gt;&gt;
&gt;&gt;&gt; # Input device is the sensor (pen tablet, screen, etc.)
&gt;&gt;&gt; input_device: InputDevice = InputDevice()
&gt;&gt;&gt; input_device.properties.append((&quot;dev.id&quot;, &quot;123454321&quot;))
&gt;&gt;&gt; input_device.properties.append((&quot;dev.manufacturer&quot;, &quot;Wacom&quot;))
&gt;&gt;&gt; input_device.properties.append((&quot;dev.model&quot;, &quot;Mobile Studio Pro&quot;))
&gt;&gt;&gt; input_device.properties.append((&quot;dev.cpu&quot;, &quot;Intel&quot;))
&gt;&gt;&gt; input_device.properties.append((&quot;dev.graphics.display&quot;, &quot;Dell 1920x1080 32bit&quot;))
&gt;&gt;&gt; input_device.properties.append((&quot;dev.graphics.adapter&quot;, &quot;NVidia&quot;))
&gt;&gt;&gt; ink_model.input_configuration.devices.append(input_device)
&gt;&gt;&gt;
&gt;&gt;&gt; # Create a group of sensor channels
&gt;&gt;&gt; sensor_channels_tablet: list = [
&gt;&gt;&gt;     SensorChannel(channel_type=InkSensorType.TIMESTAMP, metric=InkSensorMetricType.TIME, resolution=1.0),
&gt;&gt;&gt;     SensorChannel(channel_type=InkSensorType.X, metric=InkSensorMetricType.LENGTH, resolution=1.0),
&gt;&gt;&gt;     SensorChannel(channel_type=InkSensorType.Y, metric=InkSensorMetricType.LENGTH, resolution=1.0)
&gt;&gt;&gt; ]
&gt;&gt;&gt;
&gt;&gt;&gt; scc_tablet: SensorChannelsContext = SensorChannelsContext(channels=sensor_channels_tablet,
&gt;&gt;&gt;                                                           ink_input_provider_id=provider.id,
&gt;&gt;&gt;                                                           input_device_id=input_device.id)
&gt;&gt;&gt;
&gt;&gt;&gt; # We can create an additional input device, for example one providing pressure via Bluetooth
&gt;&gt;&gt; input_device_bluetooth: InputDevice = InputDevice()
&gt;&gt;&gt; input_device_bluetooth.properties.append((&quot;dev.id&quot;, &quot;345456567&quot;))
&gt;&gt;&gt; input_device_bluetooth.properties.append((&quot;dev.manufacturer&quot;, &quot;Apple&quot;))
&gt;&gt;&gt; ink_model.input_configuration.devices.append(input_device_bluetooth)
&gt;&gt;&gt;
&gt;&gt;&gt; sensor_channels_bluetooth: list = [
&gt;&gt;&gt;     SensorChannel(channel_type=InkSensorType.TIMESTAMP, metric=InkSensorMetricType.TIME, resolution=1.0),
&gt;&gt;&gt;     SensorChannel(channel_type=InkSensorType.PRESSURE, metric=InkSensorMetricType.FORCE, resolution=1.0),
&gt;&gt;&gt; ]
&gt;&gt;&gt;
&gt;&gt;&gt; scc_bluetooth: SensorChannelsContext = SensorChannelsContext(input_device_id=input_device_bluetooth.id,
&gt;&gt;&gt;                                                              channels=sensor_channels_bluetooth)
&gt;&gt;&gt;
&gt;&gt;&gt; # Add all sensor channel contexts
&gt;&gt;&gt; sensor_context: SensorContext = SensorContext()
&gt;&gt;&gt; sensor_context.add_sensor_channels_context(scc_tablet)
&gt;&gt;&gt; sensor_context.add_sensor_channels_context(scc_bluetooth)
&gt;&gt;&gt; ink_model.input_configuration.sensor_contexts.append(sensor_context)
&gt;&gt;&gt;
&gt;&gt;&gt; # Create the input context using the Environment and the Sensor Context
&gt;&gt;&gt; input_context: InputContext = InputContext(environment_id=env.id, sensor_context_id=sensor_context.id)
&gt;&gt;&gt; ink_model.input_configuration.input_contexts.append(input_context)
&gt;&gt;&gt;
&gt;&gt;&gt; # Create sensor data
&gt;&gt;&gt; sensor_data_0: SensorData = SensorData(UUIDIdentifier.id_generator(), input_context_id=input_context.id,
&gt;&gt;&gt;                                        state=InkState.PLANE)
&gt;&gt;&gt;
&gt;&gt;&gt; sensor_data_0.add_timestamp_data(sensor_channels_tablet[0], [0, 1, 2, 4, 5])
&gt;&gt;&gt; sensor_data_0.add_data(sensor_channels_tablet[1],  [100.4, 103.7, 110.1])
&gt;&gt;&gt; sensor_data_0.add_data(sensor_channels_tablet[2],  [200.1, 202.0, 207.0])
&gt;&gt;&gt;
&gt;&gt;&gt; sensor_data_0.add_timestamp_data(sensor_channels_bluetooth[0], [0, 1, 2])
&gt;&gt;&gt;
&gt;&gt;&gt; sensor_data_0.add_data(sensor_channels_bluetooth[1], [100, 200])
&gt;&gt;&gt;
&gt;&gt;&gt; # Add sensor data to the model
&gt;&gt;&gt; ink_model.sensor_data.add(sensor_data_0)
&gt;&gt;&gt;
&gt;&gt;&gt; # We need to define a brush polygon
&gt;&gt;&gt; points: list = [(10, 10), (0, 10), (0, 0)]
&gt;&gt;&gt; brush_polygons: list = [BrushPolygon(min_scale=0., points=points)]
&gt;&gt;&gt;
&gt;&gt;&gt; # Create the brush object using polygons
&gt;&gt;&gt; vector_brush_0: VectorBrush = VectorBrush(
&gt;&gt;&gt;     &quot;app://qa-test-app/vector-brush/MyTriangleBrush&quot;,
&gt;&gt;&gt;     brush_polygons)
&gt;&gt;&gt;
&gt;&gt;&gt; # Add it to the model
&gt;&gt;&gt; ink_model.brushes.add_vector_brush(vector_brush_0)
&gt;&gt;&gt;
&gt;&gt;&gt; # Add a brush specified with shape Uris
&gt;&gt;&gt; poly_uris: list = [
&gt;&gt;&gt;     BrushPolygonUri(&quot;will://brush/3.0/shape/Circle?precision=20&amp;radius=1&quot;, 0.),
&gt;&gt;&gt;     BrushPolygonUri(&quot;will://brush/3.0/shape/Ellipse?precision=20&amp;radiusX=1&amp;radiusY=0.5&quot;, 4.0)
&gt;&gt;&gt; ]
&gt;&gt;&gt;
&gt;&gt;&gt; vector_brush_1: VectorBrush = VectorBrush(
&gt;&gt;&gt;     &quot;app://qa-test-app/vector-brush/MyEllipticBrush&quot;,
&gt;&gt;&gt;     poly_uris)
&gt;&gt;&gt;
&gt;&gt;&gt; raster_brush_0: RasterBrush = RasterBrush(
&gt;&gt;&gt;     name=&quot;app://qa-test-app/raster-brush/MyRasterBrush&quot;,
&gt;&gt;&gt;     spacing=10., scattering=5., rotation=RotationMode.TRAJECTORY, shape_textures=[bytes([10, 20]),
&gt;&gt;&gt;                                                                                   bytes([30, 20])],
&gt;&gt;&gt;     fill_width=2.0, fill_height=0.3,
&gt;&gt;&gt;     fill_texture=bytes([10, 10, 20, 15, 17, 20, 25, 16, 34, 255, 23, 0, 34, 255, 23, 255]),
&gt;&gt;&gt;     randomize_fill=False, blend_mode=BlendMode.SOURCE_OVER)
&gt;&gt;&gt;
&gt;&gt;&gt; # Add it to the model
&gt;&gt;&gt; ink_model.brushes.add_raster_brush(raster_brush_0)
&gt;&gt;&gt;
&gt;&gt;&gt; raster_brush_1: RasterBrush = RasterBrush(
&gt;&gt;&gt;     name=&quot;app://qa-test-app/raster-brush/MyRasterBrush1&quot;,
&gt;&gt;&gt;     spacing=10.0, scattering=5.0, rotation=RotationMode.TRAJECTORY, fill_width=2., fill_height=0.3,
&gt;&gt;&gt;     fill_texture_uri=&quot;app://qa-test-app/raster-brush-fill/mixedShapesGL&quot;,
&gt;&gt;&gt;     shape_texture_uris=[
&gt;&gt;&gt;         &quot;app://qa-test-app/raster-brush-shape/mixedShapesGL_128x128&quot;,
&gt;&gt;&gt;         &quot;app://qa-test-app/raster-brush-shape/mixedShapesGL_64x64&quot;,
&gt;&gt;&gt;         &quot;app://qa-test-app/raster-brush-shape/mixedShapesGL_32x32&quot;,
&gt;&gt;&gt;         &quot;app://qa-test-app/raster-brush-shape/mixedShapesGL_16x16&quot;
&gt;&gt;&gt;     ], randomize_fill=False, blend_mode=BlendMode.SOURCE_OVER)
&gt;&gt;&gt;
&gt;&gt;&gt; ink_model.brushes.add_raster_brush(raster_brush_1)
&gt;&gt;&gt; ink_model.brushes.add_vector_brush(vector_brush_1)
&gt;&gt;&gt;
&gt;&gt;&gt; # Specify the layout of the stroke data, in this case the stroke will have variable X, Y and Size properties.
&gt;&gt;&gt; layout_mask: int = LayoutMask.X.value | LayoutMask.Y.value | LayoutMask.SIZE.value
&gt;&gt;&gt;
&gt;&gt;&gt; # Provide the stroke data - in this case 4 data points, each consisting of X, Y, Size
&gt;&gt;&gt; path: list = [
&gt;&gt;&gt;     10., 10.7, 1.0,
&gt;&gt;&gt;     21.0, 20.2, 2.0,
&gt;&gt;&gt;     30.0, 12.4, 2.1,
&gt;&gt;&gt;     40.0, 15.0, 1.5
&gt;&gt;&gt; ]
&gt;&gt;&gt; # Create a spline object from the path data
&gt;&gt;&gt; spline: Spline = Spline(layout_mask, path)
&gt;&gt;&gt;
&gt;&gt;&gt; # Create some style
&gt;&gt;&gt; style: Style = Style(brush_uri=vector_brush_0.name)
&gt;&gt;&gt; style.path_point_properties.red = 1.0
&gt;&gt;&gt; style.path_point_properties.green = 0.0
&gt;&gt;&gt; style.path_point_properties.blue = 0.4
&gt;&gt;&gt; style.path_point_properties.alpha = 1.0
&gt;&gt;&gt;
&gt;&gt;&gt; # Create a stroke object. Note that it just exists, but is not in the model yet.
&gt;&gt;&gt; stroke_0: Stroke = Stroke(sid=UUIDIdentifier.id_generator(), spline=spline, style=style)
&gt;&gt;&gt; # Create a spline object - 9 data points, each consisting of X, Y, Size, Red, Green, Blue, Alpha
&gt;&gt;&gt; spline_1: Spline = Spline(
&gt;&gt;&gt;     LayoutMask.X.value | LayoutMask.Y.value | LayoutMask.SIZE.value | LayoutMask.RED.value |     &gt;&gt;&gt;     LayoutMask.GREEN.value
&gt;&gt;&gt;     | LayoutMask.BLUE.value | LayoutMask.ALPHA.value,
&gt;&gt;&gt;     [10.0, 10.7, 1.0, 0.5, 0.0, 0.1, 1.0,
&gt;&gt;&gt;      21.0, 20.2, 2.0, 0.9, 0.4, 0.2, 0.8,
&gt;&gt;&gt;      30.0, 12.4, 2.1, 0.7, 0.1, 0.1, 0.7,
&gt;&gt;&gt;      40.0, 15.0, 1.5, 0.3, 0.5, 0.4, 1.0,
&gt;&gt;&gt;      50.0, 45.0, 1.0, 0.3, 0.5, 0.4, 1.0,
&gt;&gt;&gt;      41.0, 53.0, 1.1, 0.2, 0.3, 0.5, 0.9,
&gt;&gt;&gt;      33.0, 73.0, 1.2, 0.6, 0.7, 0.4, 0.8,
&gt;&gt;&gt;      20.0, 84.0, 1.3, 0.7, 0.8, 0.3, 0.7,
&gt;&gt;&gt;      10.0, 91.0, 1.1, 0.7, 0.9, 0.2, 0.6]
&gt;&gt;&gt; )
&gt;&gt;&gt;
&gt;&gt;&gt; # Create a style
&gt;&gt;&gt; style_1: Style = Style(brush_uri=raster_brush_0.name)
&gt;&gt;&gt; style_1.path_point_properties.rotation = 0.35
&gt;&gt;&gt;
&gt;&gt;&gt; # The render mode URI can also be app specific like app://blabla
&gt;&gt;&gt; # The URI will://rasterization/3.0/blend-mode/SourceOver is assumed and must not be set.
&gt;&gt;&gt; style_1.render_mode_uri = &quot;will://rasterization/3.0/blend-mode/DestinationOver&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; # Create a stroke object. Note that it just exists, but is not in the model yet.
&gt;&gt;&gt; stroke_1: Stroke = Stroke(UUIDIdentifier.id_generator(), spline=spline_1, style=style_1)
&gt;&gt;&gt;
&gt;&gt;&gt; # First you need a root group to contain the strokes
&gt;&gt;&gt; root: StrokeGroupNode = StrokeGroupNode(UUIDIdentifier.id_generator())
&gt;&gt;&gt;
&gt;&gt;&gt; # Assign the group as the root of the main ink tree
&gt;&gt;&gt; ink_model.ink_tree = InkTree()
&gt;&gt;&gt; ink_model.ink_tree.root = root
&gt;&gt;&gt;
&gt;&gt;&gt; # Add a node for stroke 0
&gt;&gt;&gt; stroke_node_0: StrokeNode = StrokeNode(stroke_0, StrokeFragment(0, 1, 0.0, 1.0))
&gt;&gt;&gt; root.add(stroke_node_0)
&gt;&gt;&gt;
&gt;&gt;&gt; # Add a node for stroke 1
&gt;&gt;&gt; root.add(StrokeNode(stroke_1, StrokeFragment(0, 1, 0.0, 1.0)))
&gt;&gt;&gt;
&gt;&gt;&gt; # Adding view for handwriting recognition results
&gt;&gt;&gt; hwr_tree: InkTree = InkTree(CommonViews.HWR_VIEW.value)
&gt;&gt;&gt; # Add view right after creation, to avoid warnings that tree is not yet attached
&gt;&gt;&gt; ink_model.add_view(hwr_tree)
&gt;&gt;&gt;
&gt;&gt;&gt; hwr_root: StrokeGroupNode = StrokeGroupNode(UUIDIdentifier.id_generator())
&gt;&gt;&gt; hwr_tree.root = hwr_root
&gt;&gt;&gt;
&gt;&gt;&gt; # Here you can add the same strokes as in the main tree, but you can organize them in a different way
&gt;&gt;&gt; # (put them in different groups)
&gt;&gt;&gt; # You are not supposed to add strokes that are not already in the main tree.
&gt;&gt;&gt; hwr_root.add(StrokeNode(stroke_0, StrokeFragment(0, 1, 0.0, 1.0)))
&gt;&gt;&gt;
&gt;&gt;&gt; # A view node can refer to a fragment of a stroke.
&gt;&gt;&gt; hwr_root.add(StrokeNode(stroke_1, StrokeFragment(0, 1, 0.0, 1.0)))
&gt;&gt;&gt;
&gt;&gt;&gt; # The hwr root denotes a word
&gt;&gt;&gt; ink_model.knowledge_graph.append(SemanticTriple(hwr_root.uri, syntax.CommonRDF.PRED_RDF_HAS_TYPE, syntax.WORD))
&gt;&gt;&gt; ink_model.knowledge_graph.append(SemanticTriple(hwr_root.uri, syntax.Semantics.PRED_IS, &quot;Wacom&quot;))
&gt;&gt;&gt;
&gt;&gt;&gt; # We need an URI builder
&gt;&gt;&gt; uri_builder: URIBuilder = URIBuilder()
&gt;&gt;&gt;
&gt;&gt;&gt; # Create a named entity
&gt;&gt;&gt; named_entity_uri: str = uri_builder.build_named_entity_uri(UUIDIdentifier.id_generator())
&gt;&gt;&gt; ink_model.knowledge_graph.append(SemanticTriple(hwr_root.uri, schema.HAS_NAMED_ENTITY,
&gt;&gt;&gt;                                                 named_entity_uri))
&gt;&gt;&gt;
&gt;&gt;&gt; # Add knowledge for the named entity
&gt;&gt;&gt; ink_model.knowledge_graph.append(SemanticTriple(named_entity_uri, &quot;entityType&quot;, &quot;Organization&quot;))
&gt;&gt;&gt; ink_model.knowledge_graph.append(SemanticTriple(named_entity_uri, &quot;basedIn&quot;, &quot;Japan&quot;))
&gt;&gt;&gt; ink_model.knowledge_graph.append(SemanticTriple(named_entity_uri, &quot;hasConfidence&quot;, &quot;0.85&quot;))
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InkModel(ABC):
    &#34;&#34;&#34;
    InkModel
    ========
    The Ink Model has the following logical sections:

    - **Data repositories** - a collection of data repositories, holding raw sensor input,
                              input device/provider configurations, splines, sensor channel configurations,
                              rendering configurations, etc. Each data repository keeps certain data-set isolated
                              and is responsible for specific type(s) of data.
    - **Logical data trees** - a collection of logical trees, representing structures of hierarchically
                               organized strokes.
    - **Semantic triple store** - an RDF/WODL compliant triple store, holding semantic information.

    Parameters
    ----------
    version: `Version`
            Version of the source (ink content file).

    Examples
    --------
    &gt;&gt;&gt; from uim.codec.writer.encoder.encoder_3_1_0 import UIMEncoder310
    &gt;&gt;&gt; from uim.model.base import UUIDIdentifier
    &gt;&gt;&gt; from uim.model.ink import InkModel, InkTree
    &gt;&gt;&gt; from uim.model.inkdata.brush import VectorBrush, BrushPolygon, BrushPolygonUri, RasterBrush, RotationMode,\
    &gt;&gt;&gt;  BlendMode
    &gt;&gt;&gt; from uim.model.inkdata.strokes import Spline, Style, Stroke, LayoutMask
    &gt;&gt;&gt; from uim.model.inkinput.inputdata import Environment, InkInputProvider, InkInputType, InputDevice,\
    &gt;&gt;&gt;    SensorChannel, InkSensorType, InkSensorMetricType, SensorChannelsContext, SensorContext, InputContext
    &gt;&gt;&gt; from uim.model.inkinput.sensordata import SensorData, InkState
    &gt;&gt;&gt; from uim.model.semantics import schema
    &gt;&gt;&gt; from uim.model.semantics.node import StrokeGroupNode, StrokeNode, StrokeFragment, URIBuilder
    &gt;&gt;&gt; from uim.model.semantics.schema import SemanticTriple, CommonViews
    &gt;&gt;&gt; from uim.utils.matrix import Matrix4x4
    &gt;&gt;&gt; # Creates an ink model from the scratch.
    &gt;&gt;&gt; ink_model: InkModel = InkModel()
    &gt;&gt;&gt; # Setting a unit scale factor
    &gt;&gt;&gt; ink_model.unit_scale_factor = 1.5
    &gt;&gt;&gt; # Using a 4x4 matrix for scaling
    &gt;&gt;&gt; ink_model.transform = Matrix4x4.create_scale(1.5)
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Properties are added as key-value pairs
    &gt;&gt;&gt; ink_model.properties.append((&#34;Author&#34;, &#34;John&#34;))
    &gt;&gt;&gt; ink_model.properties.append((&#34;PrimaryLanguage&#34;, &#34;en_US&#34;))
    &gt;&gt;&gt; ink_model.properties.append((&#34;OtherStuff&#34;, &#34;Yes&#34;))
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Create an environment
    &gt;&gt;&gt; env: Environment = Environment()
    &gt;&gt;&gt; env.properties.append((&#34;env.name&#34;, &#34;My Environment&#34;))
    &gt;&gt;&gt; env.properties.append((&#34;os.id&#34;, &#34;98765&#34;))
    &gt;&gt;&gt; env.properties.append((&#34;os.name&#34;, &#34;Windows&#34;))
    &gt;&gt;&gt; env.properties.append((&#34;os.version&#34;, &#34;10.0.18362.239&#34;))
    &gt;&gt;&gt; env.properties.append((&#34;os.build&#34;, &#34;239&#34;))
    &gt;&gt;&gt; env.properties.append((&#34;os.platform&#34;, &#34;whatever&#34;))
    &gt;&gt;&gt; ink_model.input_configuration.environments.append(env)
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Ink input provider can be pen, mouse or touch.
    &gt;&gt;&gt; provider: InkInputProvider = InkInputProvider(input_type=InkInputType.MOUSE)
    &gt;&gt;&gt; provider.properties.append((&#34;pen.id&#34;, &#34;1234567&#34;))
    &gt;&gt;&gt; ink_model.input_configuration.ink_input_providers.append(provider)
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Input device is the sensor (pen tablet, screen, etc.)
    &gt;&gt;&gt; input_device: InputDevice = InputDevice()
    &gt;&gt;&gt; input_device.properties.append((&#34;dev.id&#34;, &#34;123454321&#34;))
    &gt;&gt;&gt; input_device.properties.append((&#34;dev.manufacturer&#34;, &#34;Wacom&#34;))
    &gt;&gt;&gt; input_device.properties.append((&#34;dev.model&#34;, &#34;Mobile Studio Pro&#34;))
    &gt;&gt;&gt; input_device.properties.append((&#34;dev.cpu&#34;, &#34;Intel&#34;))
    &gt;&gt;&gt; input_device.properties.append((&#34;dev.graphics.display&#34;, &#34;Dell 1920x1080 32bit&#34;))
    &gt;&gt;&gt; input_device.properties.append((&#34;dev.graphics.adapter&#34;, &#34;NVidia&#34;))
    &gt;&gt;&gt; ink_model.input_configuration.devices.append(input_device)
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Create a group of sensor channels
    &gt;&gt;&gt; sensor_channels_tablet: list = [
    &gt;&gt;&gt;     SensorChannel(channel_type=InkSensorType.TIMESTAMP, metric=InkSensorMetricType.TIME, resolution=1.0),
    &gt;&gt;&gt;     SensorChannel(channel_type=InkSensorType.X, metric=InkSensorMetricType.LENGTH, resolution=1.0),
    &gt;&gt;&gt;     SensorChannel(channel_type=InkSensorType.Y, metric=InkSensorMetricType.LENGTH, resolution=1.0)
    &gt;&gt;&gt; ]
    &gt;&gt;&gt;
    &gt;&gt;&gt; scc_tablet: SensorChannelsContext = SensorChannelsContext(channels=sensor_channels_tablet,
    &gt;&gt;&gt;                                                           ink_input_provider_id=provider.id,
    &gt;&gt;&gt;                                                           input_device_id=input_device.id)
    &gt;&gt;&gt;
    &gt;&gt;&gt; # We can create an additional input device, for example one providing pressure via Bluetooth
    &gt;&gt;&gt; input_device_bluetooth: InputDevice = InputDevice()
    &gt;&gt;&gt; input_device_bluetooth.properties.append((&#34;dev.id&#34;, &#34;345456567&#34;))
    &gt;&gt;&gt; input_device_bluetooth.properties.append((&#34;dev.manufacturer&#34;, &#34;Apple&#34;))
    &gt;&gt;&gt; ink_model.input_configuration.devices.append(input_device_bluetooth)
    &gt;&gt;&gt;
    &gt;&gt;&gt; sensor_channels_bluetooth: list = [
    &gt;&gt;&gt;     SensorChannel(channel_type=InkSensorType.TIMESTAMP, metric=InkSensorMetricType.TIME, resolution=1.0),
    &gt;&gt;&gt;     SensorChannel(channel_type=InkSensorType.PRESSURE, metric=InkSensorMetricType.FORCE, resolution=1.0),
    &gt;&gt;&gt; ]
    &gt;&gt;&gt;
    &gt;&gt;&gt; scc_bluetooth: SensorChannelsContext = SensorChannelsContext(input_device_id=input_device_bluetooth.id,
    &gt;&gt;&gt;                                                              channels=sensor_channels_bluetooth)
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Add all sensor channel contexts
    &gt;&gt;&gt; sensor_context: SensorContext = SensorContext()
    &gt;&gt;&gt; sensor_context.add_sensor_channels_context(scc_tablet)
    &gt;&gt;&gt; sensor_context.add_sensor_channels_context(scc_bluetooth)
    &gt;&gt;&gt; ink_model.input_configuration.sensor_contexts.append(sensor_context)
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Create the input context using the Environment and the Sensor Context
    &gt;&gt;&gt; input_context: InputContext = InputContext(environment_id=env.id, sensor_context_id=sensor_context.id)
    &gt;&gt;&gt; ink_model.input_configuration.input_contexts.append(input_context)
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Create sensor data
    &gt;&gt;&gt; sensor_data_0: SensorData = SensorData(UUIDIdentifier.id_generator(), input_context_id=input_context.id,
    &gt;&gt;&gt;                                        state=InkState.PLANE)
    &gt;&gt;&gt;
    &gt;&gt;&gt; sensor_data_0.add_timestamp_data(sensor_channels_tablet[0], [0, 1, 2, 4, 5])
    &gt;&gt;&gt; sensor_data_0.add_data(sensor_channels_tablet[1],  [100.4, 103.7, 110.1])
    &gt;&gt;&gt; sensor_data_0.add_data(sensor_channels_tablet[2],  [200.1, 202.0, 207.0])
    &gt;&gt;&gt;
    &gt;&gt;&gt; sensor_data_0.add_timestamp_data(sensor_channels_bluetooth[0], [0, 1, 2])
    &gt;&gt;&gt;
    &gt;&gt;&gt; sensor_data_0.add_data(sensor_channels_bluetooth[1], [100, 200])
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Add sensor data to the model
    &gt;&gt;&gt; ink_model.sensor_data.add(sensor_data_0)
    &gt;&gt;&gt;
    &gt;&gt;&gt; # We need to define a brush polygon
    &gt;&gt;&gt; points: list = [(10, 10), (0, 10), (0, 0)]
    &gt;&gt;&gt; brush_polygons: list = [BrushPolygon(min_scale=0., points=points)]
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Create the brush object using polygons
    &gt;&gt;&gt; vector_brush_0: VectorBrush = VectorBrush(
    &gt;&gt;&gt;     &#34;app://qa-test-app/vector-brush/MyTriangleBrush&#34;,
    &gt;&gt;&gt;     brush_polygons)
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Add it to the model
    &gt;&gt;&gt; ink_model.brushes.add_vector_brush(vector_brush_0)
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Add a brush specified with shape Uris
    &gt;&gt;&gt; poly_uris: list = [
    &gt;&gt;&gt;     BrushPolygonUri(&#34;will://brush/3.0/shape/Circle?precision=20&amp;radius=1&#34;, 0.),
    &gt;&gt;&gt;     BrushPolygonUri(&#34;will://brush/3.0/shape/Ellipse?precision=20&amp;radiusX=1&amp;radiusY=0.5&#34;, 4.0)
    &gt;&gt;&gt; ]
    &gt;&gt;&gt;
    &gt;&gt;&gt; vector_brush_1: VectorBrush = VectorBrush(
    &gt;&gt;&gt;     &#34;app://qa-test-app/vector-brush/MyEllipticBrush&#34;,
    &gt;&gt;&gt;     poly_uris)
    &gt;&gt;&gt;
    &gt;&gt;&gt; raster_brush_0: RasterBrush = RasterBrush(
    &gt;&gt;&gt;     name=&#34;app://qa-test-app/raster-brush/MyRasterBrush&#34;,
    &gt;&gt;&gt;     spacing=10., scattering=5., rotation=RotationMode.TRAJECTORY, shape_textures=[bytes([10, 20]),
    &gt;&gt;&gt;                                                                                   bytes([30, 20])],
    &gt;&gt;&gt;     fill_width=2.0, fill_height=0.3,
    &gt;&gt;&gt;     fill_texture=bytes([10, 10, 20, 15, 17, 20, 25, 16, 34, 255, 23, 0, 34, 255, 23, 255]),
    &gt;&gt;&gt;     randomize_fill=False, blend_mode=BlendMode.SOURCE_OVER)
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Add it to the model
    &gt;&gt;&gt; ink_model.brushes.add_raster_brush(raster_brush_0)
    &gt;&gt;&gt;
    &gt;&gt;&gt; raster_brush_1: RasterBrush = RasterBrush(
    &gt;&gt;&gt;     name=&#34;app://qa-test-app/raster-brush/MyRasterBrush1&#34;,
    &gt;&gt;&gt;     spacing=10.0, scattering=5.0, rotation=RotationMode.TRAJECTORY, fill_width=2., fill_height=0.3,
    &gt;&gt;&gt;     fill_texture_uri=&#34;app://qa-test-app/raster-brush-fill/mixedShapesGL&#34;,
    &gt;&gt;&gt;     shape_texture_uris=[
    &gt;&gt;&gt;         &#34;app://qa-test-app/raster-brush-shape/mixedShapesGL_128x128&#34;,
    &gt;&gt;&gt;         &#34;app://qa-test-app/raster-brush-shape/mixedShapesGL_64x64&#34;,
    &gt;&gt;&gt;         &#34;app://qa-test-app/raster-brush-shape/mixedShapesGL_32x32&#34;,
    &gt;&gt;&gt;         &#34;app://qa-test-app/raster-brush-shape/mixedShapesGL_16x16&#34;
    &gt;&gt;&gt;     ], randomize_fill=False, blend_mode=BlendMode.SOURCE_OVER)
    &gt;&gt;&gt;
    &gt;&gt;&gt; ink_model.brushes.add_raster_brush(raster_brush_1)
    &gt;&gt;&gt; ink_model.brushes.add_vector_brush(vector_brush_1)
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Specify the layout of the stroke data, in this case the stroke will have variable X, Y and Size properties.
    &gt;&gt;&gt; layout_mask: int = LayoutMask.X.value | LayoutMask.Y.value | LayoutMask.SIZE.value
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Provide the stroke data - in this case 4 data points, each consisting of X, Y, Size
    &gt;&gt;&gt; path: list = [
    &gt;&gt;&gt;     10., 10.7, 1.0,
    &gt;&gt;&gt;     21.0, 20.2, 2.0,
    &gt;&gt;&gt;     30.0, 12.4, 2.1,
    &gt;&gt;&gt;     40.0, 15.0, 1.5
    &gt;&gt;&gt; ]
    &gt;&gt;&gt; # Create a spline object from the path data
    &gt;&gt;&gt; spline: Spline = Spline(layout_mask, path)
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Create some style
    &gt;&gt;&gt; style: Style = Style(brush_uri=vector_brush_0.name)
    &gt;&gt;&gt; style.path_point_properties.red = 1.0
    &gt;&gt;&gt; style.path_point_properties.green = 0.0
    &gt;&gt;&gt; style.path_point_properties.blue = 0.4
    &gt;&gt;&gt; style.path_point_properties.alpha = 1.0
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Create a stroke object. Note that it just exists, but is not in the model yet.
    &gt;&gt;&gt; stroke_0: Stroke = Stroke(sid=UUIDIdentifier.id_generator(), spline=spline, style=style)
    &gt;&gt;&gt; # Create a spline object - 9 data points, each consisting of X, Y, Size, Red, Green, Blue, Alpha
    &gt;&gt;&gt; spline_1: Spline = Spline(
    &gt;&gt;&gt;     LayoutMask.X.value | LayoutMask.Y.value | LayoutMask.SIZE.value | LayoutMask.RED.value | \
    &gt;&gt;&gt;     LayoutMask.GREEN.value
    &gt;&gt;&gt;     | LayoutMask.BLUE.value | LayoutMask.ALPHA.value,
    &gt;&gt;&gt;     [10.0, 10.7, 1.0, 0.5, 0.0, 0.1, 1.0,
    &gt;&gt;&gt;      21.0, 20.2, 2.0, 0.9, 0.4, 0.2, 0.8,
    &gt;&gt;&gt;      30.0, 12.4, 2.1, 0.7, 0.1, 0.1, 0.7,
    &gt;&gt;&gt;      40.0, 15.0, 1.5, 0.3, 0.5, 0.4, 1.0,
    &gt;&gt;&gt;      50.0, 45.0, 1.0, 0.3, 0.5, 0.4, 1.0,
    &gt;&gt;&gt;      41.0, 53.0, 1.1, 0.2, 0.3, 0.5, 0.9,
    &gt;&gt;&gt;      33.0, 73.0, 1.2, 0.6, 0.7, 0.4, 0.8,
    &gt;&gt;&gt;      20.0, 84.0, 1.3, 0.7, 0.8, 0.3, 0.7,
    &gt;&gt;&gt;      10.0, 91.0, 1.1, 0.7, 0.9, 0.2, 0.6]
    &gt;&gt;&gt; )
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Create a style
    &gt;&gt;&gt; style_1: Style = Style(brush_uri=raster_brush_0.name)
    &gt;&gt;&gt; style_1.path_point_properties.rotation = 0.35
    &gt;&gt;&gt;
    &gt;&gt;&gt; # The render mode URI can also be app specific like app://blabla
    &gt;&gt;&gt; # The URI will://rasterization/3.0/blend-mode/SourceOver is assumed and must not be set.
    &gt;&gt;&gt; style_1.render_mode_uri = &#34;will://rasterization/3.0/blend-mode/DestinationOver&#34;
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Create a stroke object. Note that it just exists, but is not in the model yet.
    &gt;&gt;&gt; stroke_1: Stroke = Stroke(UUIDIdentifier.id_generator(), spline=spline_1, style=style_1)
    &gt;&gt;&gt;
    &gt;&gt;&gt; # First you need a root group to contain the strokes
    &gt;&gt;&gt; root: StrokeGroupNode = StrokeGroupNode(UUIDIdentifier.id_generator())
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Assign the group as the root of the main ink tree
    &gt;&gt;&gt; ink_model.ink_tree = InkTree()
    &gt;&gt;&gt; ink_model.ink_tree.root = root
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Add a node for stroke 0
    &gt;&gt;&gt; stroke_node_0: StrokeNode = StrokeNode(stroke_0, StrokeFragment(0, 1, 0.0, 1.0))
    &gt;&gt;&gt; root.add(stroke_node_0)
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Add a node for stroke 1
    &gt;&gt;&gt; root.add(StrokeNode(stroke_1, StrokeFragment(0, 1, 0.0, 1.0)))
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Adding view for handwriting recognition results
    &gt;&gt;&gt; hwr_tree: InkTree = InkTree(CommonViews.HWR_VIEW.value)
    &gt;&gt;&gt; # Add view right after creation, to avoid warnings that tree is not yet attached
    &gt;&gt;&gt; ink_model.add_view(hwr_tree)
    &gt;&gt;&gt;
    &gt;&gt;&gt; hwr_root: StrokeGroupNode = StrokeGroupNode(UUIDIdentifier.id_generator())
    &gt;&gt;&gt; hwr_tree.root = hwr_root
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Here you can add the same strokes as in the main tree, but you can organize them in a different way
    &gt;&gt;&gt; # (put them in different groups)
    &gt;&gt;&gt; # You are not supposed to add strokes that are not already in the main tree.
    &gt;&gt;&gt; hwr_root.add(StrokeNode(stroke_0, StrokeFragment(0, 1, 0.0, 1.0)))
    &gt;&gt;&gt;
    &gt;&gt;&gt; # A view node can refer to a fragment of a stroke.
    &gt;&gt;&gt; hwr_root.add(StrokeNode(stroke_1, StrokeFragment(0, 1, 0.0, 1.0)))
    &gt;&gt;&gt;
    &gt;&gt;&gt; # The hwr root denotes a word
    &gt;&gt;&gt; ink_model.knowledge_graph.append(SemanticTriple(hwr_root.uri, syntax.CommonRDF.PRED_RDF_HAS_TYPE, syntax.WORD))
    &gt;&gt;&gt; ink_model.knowledge_graph.append(SemanticTriple(hwr_root.uri, syntax.Semantics.PRED_IS, &#34;Wacom&#34;))
    &gt;&gt;&gt;
    &gt;&gt;&gt; # We need an URI builder
    &gt;&gt;&gt; uri_builder: URIBuilder = URIBuilder()
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Create a named entity
    &gt;&gt;&gt; named_entity_uri: str = uri_builder.build_named_entity_uri(UUIDIdentifier.id_generator())
    &gt;&gt;&gt; ink_model.knowledge_graph.append(SemanticTriple(hwr_root.uri, schema.HAS_NAMED_ENTITY,
    &gt;&gt;&gt;                                                 named_entity_uri))
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Add knowledge for the named entity
    &gt;&gt;&gt; ink_model.knowledge_graph.append(SemanticTriple(named_entity_uri, &#34;entityType&#34;, &#34;Organization&#34;))
    &gt;&gt;&gt; ink_model.knowledge_graph.append(SemanticTriple(named_entity_uri, &#34;basedIn&#34;, &#34;Japan&#34;))
    &gt;&gt;&gt; ink_model.knowledge_graph.append(SemanticTriple(named_entity_uri, &#34;hasConfidence&#34;, &#34;0.85&#34;))
    &#34;&#34;&#34;

    def __init__(self, version: Version = None):
        self.__input_data: SensorDataRepository = SensorDataRepository()
        self.__version: Version = version
        self.__brushes: Brushes = Brushes()
        self.__ink_tree: Optional[InkTree] = None
        self.__views: List[InkTree] = []
        self.__knowledge_graph: schema.TripleStore = schema.TripleStore()
        self.__transform: numpy.ndarray = numpy.identity(4, dtype=float)
        self.__default_transform: bool = True
        self.__properties: List[Tuple[str, str]] = []
        self.__unit_scale_factor: float = 1.
        self.__input_configuration: InputContextRepository = InputContextRepository()
        self.__map: Dict[str, InkNode] = {}

    @property
    def version(self) -&gt; Version:
        &#34;&#34;&#34;Version of ink content file used to create the model. (`Version`, read-only)&#34;&#34;&#34;
        return self.__version

    @property
    def input_configuration(self) -&gt; InputContextRepository:
        &#34;&#34;&#34;Input context data repository. (`InputContextRepository`)&#34;&#34;&#34;
        return self.__input_configuration

    @input_configuration.setter
    def input_configuration(self, value: InputContextRepository):
        self.__input_configuration = value

    @property
    def unit_scale_factor(self) -&gt; float:
        &#34;&#34;&#34; LocalUnit * UnitScaleFactor = DIP (DIP = 1/96 of a logical Inch). (&#39;float&#39;)&#34;&#34;&#34;
        return self.__unit_scale_factor

    @unit_scale_factor.setter
    def unit_scale_factor(self, value: float):
        self.__unit_scale_factor = value

    @property
    def sensor_data(self) -&gt; SensorDataRepository:
        &#34;&#34;&#34;Input data repository; sensor data. (`SensorDataRepository`)&#34;&#34;&#34;
        return self.__input_data

    @property
    def brushes(self) -&gt; Brushes():
        &#34;&#34;&#34;All brushes (vector and raster brushes). (`Brushes`)&#34;&#34;&#34;
        return self.__brushes

    @property
    def ink_tree(self) -&gt; InkTree:
        &#34;&#34;&#34;Main ink tree. (``InkTree)&#34;&#34;&#34;
        return self.__ink_tree

    @ink_tree.setter
    def ink_tree(self, ink_tree: InkTree):
        self.add_tree(ink_tree)

    @property
    def strokes(self) -&gt; List[Stroke]:
        &#34;&#34;&#34;List of all strokes. (`List[Stroke]`, read-only)&#34;&#34;&#34;
        strokes: List[Stroke] = []
        for node in PreOrderEnumerator(self.ink_tree.root):
            if isinstance(node, StrokeNode):
                strokes.append(node.stroke)
        return strokes

    def stroke_by_id(self, stroke_uuid: uuid.UUID) -&gt; Stroke:
        &#34;&#34;&#34;
        Returns the stroke for a specific UUID.

        Parameters
        ----------
        stroke_uuid: `UUID`
            ID of the stroke

        Returns
        -------
        stroke: `Stroke`
            Instance of the  stroke
        &#34;&#34;&#34;
        for node in PreOrderEnumerator(self.ink_tree.root):
            if isinstance(node, StrokeNode):
                if node.stroke.id == stroke_uuid:
                    return node.stroke
        raise InkModelException(f&#34;Stroke with id {stroke_uuid} does not exist in main tree.&#34;)

    @staticmethod
    def collect_strokes(tree: InkTree) -&gt; List[Stroke]:
        strokes: List[Stroke] = []
        for node in PreOrderEnumerator(tree.root):
            if isinstance(node, StrokeNode):
                strokes.append(node.stroke)
        return strokes

    @property
    def views(self) -&gt; Tuple[InkTree]:
        &#34;&#34;&#34;List of views.&#34;&#34;&#34;
        return tuple(self.__views)

    def add_tree(self, tree: InkTree):
        &#34;&#34;&#34;Adding an ink tree to the model.
        :param tree: InkTree -
            Instance of the ink tree
        :raises:
            InkModelException - If name is already assigned to an ink model or
        &#34;&#34;&#34;
        if tree.model is not None:
            raise InkModelException(f&#34;InkTree with name {tree.name} is already assigned to an ink model.&#34;)

        if self.has_tree(tree.name):
            raise InkModelException(f&#34;InkTree with name {tree.name} is already assigned to the current ink model.&#34;)

        tree.model = self
        if tree.name == &#39;&#39; or tree.name == CommonViews.MAIN_INK_TREE.value:
            self.__ink_tree = tree
        else:
            self.__views.append(tree)

        if tree.root is not None:
            tree.register_sub_tree(tree.root)

    def remove_tree(self, name: str):
        &#34;&#34;&#34;Removing view tree from model.
        :param name: str -
            Name of the tree that should be removed

        &#34;&#34;&#34;
        tree: InkTree = self.tree(name)
        tree.unregister_sub_tree(tree.root)
        if tree.name == &#39;&#39; or tree.name == CommonViews.MAIN_INK_TREE.value:
            self.__ink_tree = None
        else:
            self.__views.remove(tree)

    def tree(self, name: str) -&gt; InkTree:
        &#34;&#34;&#34;Return named tree.
        :returns: tree for defined name
        &#34;&#34;&#34;
        if name == CommonViews.MAIN_INK_TREE.value:
            return self.ink_tree
        else:
            for v in self.views:
                if v.name == name:
                    return v
        raise InkModelException(f&#34;InkTree with name {name} is not found.&#34;)

    def has_tree(self, name: str) -&gt; bool:
        &#34;&#34;&#34;Check if the named tree exists.
        :param name: str -
            Name of the tree
        :returns: flag if the tree exists
        &#34;&#34;&#34;
        if name == CommonViews.MAIN_INK_TREE.value:
            return self.ink_tree is not None
        else:
            for v in self.views:
                if v.name == name:
                    return True
        return False

    def clear_views(self):
        &#34;&#34;&#34;Clears the views.&#34;&#34;&#34;
        self.__views = []

    @property
    def knowledge_graph(self) -&gt; schema.TripleStore:
        &#34;&#34;&#34;Knowledge graph encoding all knowledge about the ink strokes.&#34;&#34;&#34;
        return self.__knowledge_graph

    @property
    def transform(self) -&gt; numpy.array:
        &#34;&#34;&#34;Transformation matrix.&#34;&#34;&#34;
        return self.__transform

    @transform.setter
    def transform(self, transform: list):
        self.__transform = numpy.array(transform)
        self.__default_transform = False

    @property
    def default_transform(self) -&gt; bool:
        &#34;&#34;&#34;Flag if the transform has been updated.&#34;&#34;&#34;
        return self.__default_transform

    @property
    def properties(self) -&gt; list:
        &#34;&#34;&#34;Returns the properties for ink object.&#34;&#34;&#34;
        return self.__properties

    @properties.setter
    def properties(self, properties: list):
        self.__properties = properties

    def add_property(self, name: str, value: str):
        &#34;&#34;&#34;Adds a property.
        :param name: name of the property
        :param value: value of the property
        &#34;&#34;&#34;
        self.__properties.append((name, value))

    def view_root(self, name: str) -&gt; StrokeGroupNode:
        &#34;&#34;&#34;Returns the root for a view.
        :param name: CommonViews -
            Name of the view
        :return : root of named view
        :raises:
            KeyError: View with name does not exist
        &#34;&#34;&#34;
        return self.view(name).root

    def view(self, name: str) -&gt; InkTree:
        &#34;&#34;&#34;Returns the view.
        :param name: CommonViews -
            Name of the view
        :return : instance of the name
        :raises:
            KeyError: View with name does not exist
        &#34;&#34;&#34;
        for v in self.__views:
            if v.name == name:
                return v
        raise KeyError(&#39;No view with name:={}&#39;.format(name))

    def add_view(self, view: InkTree):
        &#34;&#34;&#34;Adding a view to the InkObject.
        :param view: View object
        &#34;&#34;&#34;
        self.add_tree(view)

    def add_semantic_triple(self, subject: str, predicate: str, obj: str):
        &#34;&#34;&#34;Adding a semantic triple to the object.

        :param subject: subject of the statement
        :param predicate: predicate of the statement
        :param obj: object of the statement
        &#34;&#34;&#34;
        self.__knowledge_graph.add_semantic_triple(subject, predicate, obj)

    def remove_semantic_triple(self, subject: str, predicate: str, obj: str):
        &#34;&#34;&#34;Remove a semantic triple from the object.

        :param subject:
        :param predicate:
        :param obj:
        &#34;&#34;&#34;
        self.__knowledge_graph.remove_semantic_triple(schema.SemanticTriple(subject, predicate, obj))

    def get_semantic_statement(self, subject: str) -&gt; schema.SemanticTriple:
        &#34;&#34;&#34;Returns the document property (or the optional default value).

        :param subject: str -
            key for property
        :return: value or None
        :raises:
            InkModelException: Raised if no semantic triple is existing for subject.
        &#34;&#34;&#34;
        for sem in self.knowledge_graph.statements:
            if sem.subject == subject:
                return sem
        raise InkModelException(&#39;No semantic triple for subject:= {}.&#39;.format(subject))

    def clear_knowledge_graph(self):
        &#34;&#34;&#34;Clears the knowledge graph.&#34;&#34;&#34;
        self.__knowledge_graph.clear_statements()

    def build_stroke_cache(self, stroke: Stroke):
        &#34;&#34;&#34;
        Build stroke cache.

        Parameters
        ----------
        stroke: Stroke
            Stroke for cache

        &#34;&#34;&#34;
        (ts, p) = self.get_stroke_timestamp_and_pressure_values(stroke)
        stroke.set_timestamp_values(ts)
        stroke.set_pressure_values(p)

    @staticmethod
    def clear_stroke_cache(stroke: Stroke):
        &#34;&#34;&#34;
        Clear stroke cache.

        Parameters
        ----------
        stroke: `Stroke`
            Stroke to clear.
        &#34;&#34;&#34;
        stroke.set_timestamp_values(None)
        stroke.set_pressure_values(None)

    def get_stroke_timestamp_and_pressure_values(self, stroke: Stroke, duplicate_first_and_last: bool = True) \
            -&gt; Tuple[List[float], List[float]]:
        &#34;&#34;&#34;
        Gets the timestamp and pressure values.

        Parameters
        ----------
        stroke: `Stroke`
            Stroke
        duplicate_first_and_last: `bool`
            Duplicate first and last

        Returns
        -------
        timestamps:  List[float]
            List of timestamp values
        pressure_values:  List[float]
            List of pressure values
        &#34;&#34;&#34;
        sd: SensorData = self.sensor_data.sensor_data_by_id(stroke.sensor_data_id)
        sensor_channels: list = self.input_configuration.sensor_contexts[0].sensor_channels_contexts[0] \
            .channels

        t_channel_id = [c.id for c in sensor_channels if c.type == InkSensorType.TIMESTAMP][0]
        p_channel_id = [c.id for c in sensor_channels if c.type == InkSensorType.PRESSURE][0]

        ts: list = []
        ps: list = []

        for cd in sd.data_channels:
            if cd.id == t_channel_id:
                ts = cd.values.copy()
            elif cd.id == p_channel_id:
                ps = cd.values.copy()

        if duplicate_first_and_last:
            ts.insert(0, ts[0])
            ts.append(ts[-1])

            ps.insert(0, ps[0])
            ps.append(ps[-1])

        return ts, ps

    def get_strokes_as_strided_array(self, layout: str = &#34;xytp&#34;,
                                     policy: HandleMissingDataPolicy = HandleMissingDataPolicy.FILL_WITH_ZEROS) \
            -&gt; Tuple[List, str]:
        &#34;&#34;&#34;
        Returns all the strokes in the document, where each stroke is an array with stride 4.

        Parameters
        ----------
        layout: str -
            Layout string - &#39;xytp&#39; (x, y, timestamp, pressure).
        policy: HandleMissingDataPolicy -
            Policy to handle missing data.

        Returns
        -------
        array: `List`
            Strided array
        layout: `str`
            Layout string
        &#34;&#34;&#34;

        if layout != &#34;xytp&#34;:
            raise ValueError(&#34;Unsupported layout: %s&#34; % layout)

        strokes: List[Stroke] = self.strokes
        result: List = []
        for stroke in strokes:
            # Remove the first and last element, which are added by the spline producer
            xs = stroke.splines_x[1:-1]
            ys = stroke.splines_y[1:-1]

            sd: SensorData = self.sensor_data.sensor_data_by_id(stroke.sensor_data_id)

            sc_ts: Optional[SensorChannel] = None
            sc_pressure: Optional[SensorChannel] = None

            input_context: InputContext = self.input_configuration.get_input_context(sd.input_context_id)
            if input_context is not None:
                sensor_context = self.input_configuration.get_sensor_context(input_context.sensor_context_id)
                if sensor_context is not None:
                    sc_ts = None
                    sc_pressure = None

                    if sensor_context.has_channel_type(InkSensorType.TIMESTAMP):
                        sc_ts = sensor_context.get_channel_by_type(InkSensorType.TIMESTAMP)

                    if sensor_context.has_channel_type(InkSensorType.PRESSURE):
                        sc_pressure = sensor_context.get_channel_by_type(InkSensorType.PRESSURE)
            if sd is None or sc_ts is None or sd.get_data_by_id(sc_ts.id) is None:
                ts = []
            else:
                ts = sd.get_data_by_id(sc_ts.id).values.copy()

            if sd is None or sc_pressure is None or sd.get_data_by_id(sc_pressure.id) is None:
                ps = []
            else:
                ps = sd.get_data_by_id(sc_pressure.id).values.copy()

            xs = xs[0:len(ts)]
            ys = ys[0:len(ts)]

            # Handle missing timestamp according to policy
            if len(ts) == 0:
                if policy == HandleMissingDataPolicy.SKIP_STROKE:
                    continue
                elif policy == HandleMissingDataPolicy.THROW_EXCEPTION:
                    raise ValueError(&#34;There is no timestamp data for this stroke.&#34;)

            # Handle missing pressure according to policy
            if len(ps) == 0:
                if policy == HandleMissingDataPolicy.SKIP_STROKE:
                    continue
                elif policy == HandleMissingDataPolicy.THROW_EXCEPTION:
                    raise ValueError(&#34;There is no pressure data for this stroke.&#34;)

            points = []

            sensor_data_mapping = stroke.sensor_data_mapping

            if len(sensor_data_mapping) == 0:  # Mapping is 1:1
                limit = min(stroke.sensor_data_offset + len(xs), len(ts))
                sensor_data_mapping = range(stroke.sensor_data_offset, limit)

            i = 0

            for map_i in sensor_data_mapping:
                points.append(xs[i])
                points.append(ys[i])

                if len(ts) == 0:
                    points.append(0)
                else:
                    points.append(ts[map_i])

                if len(ps) == 0:
                    points.append(0)
                else:
                    points.append(ps[map_i])

                i += 1

            result.append(points)

        return result, layout

    def sensor_data_lookup(self, stroke: Stroke, ink_sensor_type: InkSensorType,
                           return_channel_data_instance: bool = False):
        sd: SensorData = self.sensor_data.sensor_data_by_id(stroke.sensor_data_id)

        sc = None

        input_context = self.input_configuration.get_input_context(sd.input_context_id)
        if input_context is not None:
            sensor_context = self.input_configuration.get_sensor_context(input_context.sensor_context_id)
            if sensor_context is not None:

                if sensor_context.has_channel_type(ink_sensor_type):
                    sc = sensor_context.get_channel_by_type(ink_sensor_type)

        if sd is None or sc is None or sd.get_data_by_id(sc.id) is None:
            return None if return_channel_data_instance else []
        else:
            return sd.get_data_by_id(sc.id) if return_channel_data_instance else sd.get_data_by_id(sc.id).values.copy()

    def calculate_bounds_recursively(self, node: InkNode):
        &#34;&#34;&#34;
        Calculates the bounds recursively.

        Parameters
        ----------
        node: Node
            Node of the tree
        &#34;&#34;&#34;
        x_min: float = sys.float_info.max
        x_max: float = 0.
        y_min: float = sys.float_info.max
        y_max: float = 0.
        if isinstance(node, StrokeNode):
            stroke_node: StrokeNode = node
            x_min: float = min(stroke_node.stroke.spline_min_x, x_min)
            x_max: float = max(stroke_node.stroke.spline_max_x, x_max)
            y_min: float = min(stroke_node.stroke.spline_min_y, y_min)
            y_max: float = max(stroke_node.stroke.spline_max_y, y_max)
            node.group_bounding_box = BoundingBox(x_min, y_min, x_max - x_min, y_max - y_min)
        elif isinstance(node, StrokeGroupNode):
            for child_node in node.children:
                self.calculate_bounds_recursively(child_node)
                child_bbox: BoundingBox = child_node.group_bounding_box
                x_min: float = min(child_bbox.x, x_min)
                x_max: float = max(child_bbox.x + child_bbox.width, x_max)
                y_min: float = min(child_bbox.y, y_min)
                y_max: float = max(child_bbox.y + child_bbox.height, y_max)
            bbox: BoundingBox = BoundingBox(x_min, y_min, x_max - x_min, y_max - y_min)
            node.group_bounding_box = bbox

    def has_properties(self) -&gt; bool:
        &#34;&#34;&#34;
        Checks if the Ink Model has properties configured.

        Returns
        --------
        flag: `bool`
            Flag if properties have been configured for InkModel
        &#34;&#34;&#34;
        return len(self.properties) &gt; 0

    def has_input_data(self) -&gt; bool:
        &#34;&#34;&#34;
        Checks if the Ink Model has input data configured.

        Returns
        -------
        flag: `bool`
            Flag if input data have been configured for InkModel
        &#34;&#34;&#34;
        return len(self.sensor_data.sensor_data) &gt; 0 or self.input_configuration.has_configuration()

    def has_brushes(self) -&gt; bool:
        &#34;&#34;&#34;
        Checks if the Ink Model has brushes configured.

        Returns
        -------
        flag: `bool`
            Flag if brushes have been configured for InkModel
        &#34;&#34;&#34;
        return len(self.brushes.vector_brushes) &gt; 0 or len(self.brushes.raster_brushes) &gt; 0

    def has_ink_data(self) -&gt; bool:
        &#34;&#34;&#34;
        Checks if the Ink Model has ink data configured.

        Returns
        -------
        flag: `bool`
            Flag if ink data have been configured for InkModel
        &#34;&#34;&#34;
        try:
            return self.ink_tree is not None
        except FormatException:
            return False

    def has_knowledge_graph(self) -&gt; bool:
        &#34;&#34;&#34;
        Checks if the Ink Model has knowledge graph configured.

        Returns
        -------
        flag: `bool`
            Flag if knowledge graph have been configured for InkModel
        &#34;&#34;&#34;
        return len(self.knowledge_graph.statements) &gt; 0

    def has_ink_structure(self) -&gt; bool:
        &#34;&#34;&#34;
        Checks if the Ink Model has ink structure configured.

        Returns
        -------
        flag: `bool`
            Flag if input data have been configured for InkModel
        &#34;&#34;&#34;
        try:
            if self.ink_tree is None:
                return False
            return self.ink_tree.root is not None
        except FormatException:
            return False

    def clone_stroke_node(self, stroke_node: StrokeNode,  target_parent_node: StrokeGroupNode = None,
                          clone_semantics: bool = True) -&gt; StrokeNode:
        &#34;&#34;&#34;
        Cloning a stroke node.

        Parameters
        ----------
        stroke_node: `StrokeNode`
            Stroke node which shall be cloned

        target_parent_node: `StrokeGroupNode`
            Target node

        clone_semantics: `bool`
            Cloning semantics

        Returns
        -------
            stroke: `StrokeNode`
                Cloned stroke
        &#34;&#34;&#34;
        if stroke_node.fragment is not None:
            f = stroke_node.fragment
            fragment = StrokeFragment(f.from_point_index, f.to_point_index, f.from_t_value, f.to_t_value)
        else:
            fragment = None

        new_node: StrokeNode = StrokeNode(stroke=stroke_node.stroke, fragment=fragment)

        if clone_semantics:
            triples = self.knowledge_graph.filter(stroke_node.uri)
            t: SemanticTriple
            for t in triples:
                self.knowledge_graph.add_semantic_triple(new_node.uri, t.predicate, t.object)

        if target_parent_node is not None:
            target_parent_node.add(new_node)

        return new_node

    def clone_stroke_group_node(self, stroke_group_node: StrokeGroupNode,
                                target_parent_node: StrokeGroupNode = None,
                                clone_semantics: bool = True,
                                clone_child_stroke_nodes: bool = True,
                                clone_child_group_nodes: bool = False,
                                raise_exception: bool = False,
                                store_source_node_reference_transient_key: str = None) -&gt; StrokeGroupNode:
        &#34;&#34;&#34;
        Clone stroke group node.

        Parameters
        ----------
        stroke_group_node: `StrokeGroupNode`
            StrokeGroupNode to be cloned.
        target_parent_node: `StrokeGroupNode`
            Target node
        clone_semantics: `bool`
            Clone semantics [default:=True]
        clone_child_stroke_nodes: `bool`
            Clone child stroke nodes [default:=True]
        clone_child_group_nodes: bool
            Clone child group nodes [default:=False]
        raise_exception: bool
            Raise exceptions [default:=False]
        store_source_node_reference_transient_key: str
            Store source node reference.

        Returns
        -------
        new_stroke_group_node: `StrokeGroupNode`
            Cloned `StrokeGroupNode`

        Raises
        ------
        InkModelException
            If cloning needs to be aborted.
        &#34;&#34;&#34;
        new_node: StrokeGroupNode = StrokeGroupNode(UUIDIdentifier.id_generator())

        if target_parent_node is not None:
            target_parent_node.add(new_node)

        if clone_semantics:
            triples = self.knowledge_graph.filter(stroke_group_node.uri)
            t: SemanticTriple
            for t in triples:
                self.knowledge_graph.add_semantic_triple(new_node.uri, t.predicate, t.object)

        if clone_child_stroke_nodes or clone_child_group_nodes:
            for n in stroke_group_node.children:
                child_clone: Optional[InkNode] = None

                if isinstance(n, StrokeNode):
                    if clone_child_stroke_nodes:
                        child_clone = self.clone_stroke_node(n, target_parent_node=new_node,
                                                             clone_semantics=clone_semantics)
                    elif raise_exception:
                        raise InkModelException(&#34;Cloning aborted: Stroke node would be left behind if we continue.&#34;)

                elif isinstance(n, StrokeGroupNode):
                    if clone_child_group_nodes:
                        child_clone = self.clone_stroke_group_node(n, target_parent_node=new_node,
                                                                   clone_semantics=clone_semantics,
                                                                   clone_child_stroke_nodes=clone_child_stroke_nodes,
                                                                   clone_child_group_nodes=clone_child_group_nodes,
                                                                   raise_exception=raise_exception)
                    elif raise_exception:
                        raise InkModelException(&#34;Cloning aborted: Group node would be left behind if we continue.&#34;)

                if store_source_node_reference_transient_key is not None:
                    child_clone.transient_tag = {store_source_node_reference_transient_key: n}
        return new_node

    def register_node(self, node: InkNode):
        &#34;&#34;&#34;
        Register ink node.

        Parameters
        ----------
        node: `InkNode`
            Reference to node.

        Raises
        ------
        InkModelException
            If Node with URI already exist in the tree
        &#34;&#34;&#34;
        if self.__map.get(node.uri) is not None:
            raise InkModelException(f&#39;An ink node with uri {node.uri} already exists in the model.&#39;)
        else:
            if node_registration_debug:
                logger.debug(f&#34;Registering node {node.uri}&#34;)

        self.__map[node.uri] = node

    def is_node_registered(self, node: InkNode):
        &#34;&#34;&#34;
        Check if node is registered.

        Parameters
        ----------
        node: `InkNode`
            Node to check

        Returns
        -------
        flag: `bool`
            Flag if node is already registered in tree.
        &#34;&#34;&#34;
        return self.__map.get(node.uri) is not None

    def unregister_node(self, node: InkNode):
        &#34;&#34;&#34;
        Unregister a node.

        Parameters
        ----------
        node: `InkNode`
            Node to unregister

        Notes
        -----
        This function removes the triples for the node as well.

        &#34;&#34;&#34;
        if node_registration_debug:
            logger.debug(f&#34;Unregistering node {node.uri}&#34;)
            
        if node.tree is not None:
            triples = self.knowledge_graph.filter(node.uri)
            if node_registration_debug:
                logger.debug(f&#34;Found {len(triples)} triples for {node.uri}&#34;)
            for t in triples:
                if node_registration_debug:
                    logger.debug(f&#34;Removing semantic triple: {str(t)}&#34;)
                self.knowledge_graph.remove_semantic_triple(t)

            if node_registration_debug:
                triples = self.knowledge_graph.filter(node.uri)
                logger.debug(f&#34;Sanity check =&gt; Found {len(triples)} triples for {node.uri}&#34;)

        del self.__map[node.uri]

    def remove_node(self, node: InkNode):
        &#34;&#34;&#34;
        Remove a node.

        Parameters
        ----------
        node: `InkNode`
           Node to be remove

        Notes
        -----
        This function removes the triples and the node as well.

       &#34;&#34;&#34;
        # First remove the triples
        self.unregister_node(node)
        if node.parent is not None:
            node.parent.remove(node)

    def __eq__(self, other: Any):
        if not isinstance(other, InkModel):
            return False
        other_model: InkModel = other
        if self.has_properties() == other_model.has_properties():
            map_prop: dict = dict(other_model.properties)
            for key, value in self.properties:
                if key in map_prop:
                    if value != map_prop[key]:
                        return False
                    else:
                        del map_prop[key]
                else:
                    return False
            if len(map_prop) &gt; 0:
                return False
        else:
            return False
        if self.has_input_data() == other_model.has_input_data():
            if self.has_input_data():
                if self.sensor_data != other_model.sensor_data:
                    return False
        else:
            return False
        if self.has_brushes() == other_model.has_input_data():
            pass
        else:
            return False
        if self.has_ink_data() == other_model.has_ink_data():
            pass
        else:
            return False
        if self.has_knowledge_graph() == other_model.has_knowledge_graph():
            pass
        else:
            return False
        if self.has_ink_structure() == other_model.has_ink_structure():
            pass
        else:
            return False
        return True

    def __repr__(self):
        parts: str = &#39;&#39;
        prefix: str = &#39;&#39;
        if self.has_properties():
            parts += f&#39;Properties (properties:={len(self.properties)})&#39;
            prefix = &#39;, &#39;
        if self.has_input_data():
            parts += prefix + f&#39;Input Data (sensor data:={len(self.sensor_data.sensor_data)})&#39;
            prefix = &#39;, &#39;
        if self.has_brushes():
            parts += prefix + f&#39;Brushes (vector:={len(self.brushes.vector_brushes)}, &#39;
            parts += f&#39;raster:={len(self.brushes.raster_brushes)})&#39;
            prefix = &#39;, &#39;
        if self.has_ink_data():
            parts += prefix + f&#39;Ink Data (ink data:={len(self.strokes)})&#39;
            prefix = &#39;, &#39;
        if self.has_knowledge_graph():
            parts += prefix + f&#39;Knowledge graph (statements:={len(self.knowledge_graph.statements)})&#39;
            prefix = &#39;, &#39;
        if self.has_ink_structure():
            parts += prefix + f&#39;Ink Structure (main:={1 if self.ink_tree is not None else 0},views:={len(self.views)})&#39;
        return &#39;&lt;InkModel - [{}]&gt;&#39;.format(parts)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="uim.model.ink.InkModel.clear_stroke_cache"><code class="name flex">
<span>def <span class="ident">clear_stroke_cache</span></span>(<span>stroke:Â <a title="uim.model.inkdata.strokes.Stroke" href="inkdata/strokes.html#uim.model.inkdata.strokes.Stroke">Stroke</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Clear stroke cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>stroke</code></strong> :&ensp;<code>Stroke</code></dt>
<dd>Stroke to clear.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def clear_stroke_cache(stroke: Stroke):
    &#34;&#34;&#34;
    Clear stroke cache.

    Parameters
    ----------
    stroke: `Stroke`
        Stroke to clear.
    &#34;&#34;&#34;
    stroke.set_timestamp_values(None)
    stroke.set_pressure_values(None)</code></pre>
</details>
</dd>
<dt id="uim.model.ink.InkModel.collect_strokes"><code class="name flex">
<span>def <span class="ident">collect_strokes</span></span>(<span>tree:Â <a title="uim.model.ink.InkTree" href="#uim.model.ink.InkTree">InkTree</a>) â>Â List[<a title="uim.model.inkdata.strokes.Stroke" href="inkdata/strokes.html#uim.model.inkdata.strokes.Stroke">Stroke</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def collect_strokes(tree: InkTree) -&gt; List[Stroke]:
    strokes: List[Stroke] = []
    for node in PreOrderEnumerator(tree.root):
        if isinstance(node, StrokeNode):
            strokes.append(node.stroke)
    return strokes</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="uim.model.ink.InkModel.brushes"><code class="name">var <span class="ident">brushes</span> :Â <BrushesÂ :Â [rasterÂ brush:=#0,Â vectorÂ brush:=#0]></code></dt>
<dd>
<div class="desc"><p>All brushes (vector and raster brushes). (<code>Brushes</code>)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def brushes(self) -&gt; Brushes():
    &#34;&#34;&#34;All brushes (vector and raster brushes). (`Brushes`)&#34;&#34;&#34;
    return self.__brushes</code></pre>
</details>
</dd>
<dt id="uim.model.ink.InkModel.default_transform"><code class="name">var <span class="ident">default_transform</span> :Â bool</code></dt>
<dd>
<div class="desc"><p>Flag if the transform has been updated.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def default_transform(self) -&gt; bool:
    &#34;&#34;&#34;Flag if the transform has been updated.&#34;&#34;&#34;
    return self.__default_transform</code></pre>
</details>
</dd>
<dt id="uim.model.ink.InkModel.ink_tree"><code class="name">var <span class="ident">ink_tree</span> :Â <a title="uim.model.ink.InkTree" href="#uim.model.ink.InkTree">InkTree</a></code></dt>
<dd>
<div class="desc"><p>Main ink tree. (``InkTree)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ink_tree(self) -&gt; InkTree:
    &#34;&#34;&#34;Main ink tree. (``InkTree)&#34;&#34;&#34;
    return self.__ink_tree</code></pre>
</details>
</dd>
<dt id="uim.model.ink.InkModel.input_configuration"><code class="name">var <span class="ident">input_configuration</span> :Â <a title="uim.model.inkinput.inputdata.InputContextRepository" href="inkinput/inputdata.html#uim.model.inkinput.inputdata.InputContextRepository">InputContextRepository</a></code></dt>
<dd>
<div class="desc"><p>Input context data repository. (<code>InputContextRepository</code>)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def input_configuration(self) -&gt; InputContextRepository:
    &#34;&#34;&#34;Input context data repository. (`InputContextRepository`)&#34;&#34;&#34;
    return self.__input_configuration</code></pre>
</details>
</dd>
<dt id="uim.model.ink.InkModel.knowledge_graph"><code class="name">var <span class="ident">knowledge_graph</span> :Â <a title="uim.model.semantics.schema.TripleStore" href="semantics/schema.html#uim.model.semantics.schema.TripleStore">TripleStore</a></code></dt>
<dd>
<div class="desc"><p>Knowledge graph encoding all knowledge about the ink strokes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def knowledge_graph(self) -&gt; schema.TripleStore:
    &#34;&#34;&#34;Knowledge graph encoding all knowledge about the ink strokes.&#34;&#34;&#34;
    return self.__knowledge_graph</code></pre>
</details>
</dd>
<dt id="uim.model.ink.InkModel.properties"><code class="name">var <span class="ident">properties</span> :Â list</code></dt>
<dd>
<div class="desc"><p>Returns the properties for ink object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def properties(self) -&gt; list:
    &#34;&#34;&#34;Returns the properties for ink object.&#34;&#34;&#34;
    return self.__properties</code></pre>
</details>
</dd>
<dt id="uim.model.ink.InkModel.sensor_data"><code class="name">var <span class="ident">sensor_data</span> :Â <a title="uim.model.ink.SensorDataRepository" href="#uim.model.ink.SensorDataRepository">SensorDataRepository</a></code></dt>
<dd>
<div class="desc"><p>Input data repository; sensor data. (<code><a title="uim.model.ink.SensorDataRepository" href="#uim.model.ink.SensorDataRepository">SensorDataRepository</a></code>)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sensor_data(self) -&gt; SensorDataRepository:
    &#34;&#34;&#34;Input data repository; sensor data. (`SensorDataRepository`)&#34;&#34;&#34;
    return self.__input_data</code></pre>
</details>
</dd>
<dt id="uim.model.ink.InkModel.strokes"><code class="name">var <span class="ident">strokes</span> :Â List[<a title="uim.model.inkdata.strokes.Stroke" href="inkdata/strokes.html#uim.model.inkdata.strokes.Stroke">Stroke</a>]</code></dt>
<dd>
<div class="desc"><p>List of all strokes. (<code>List[Stroke]</code>, read-only)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def strokes(self) -&gt; List[Stroke]:
    &#34;&#34;&#34;List of all strokes. (`List[Stroke]`, read-only)&#34;&#34;&#34;
    strokes: List[Stroke] = []
    for node in PreOrderEnumerator(self.ink_tree.root):
        if isinstance(node, StrokeNode):
            strokes.append(node.stroke)
    return strokes</code></pre>
</details>
</dd>
<dt id="uim.model.ink.InkModel.transform"><code class="name">var <span class="ident">transform</span> :Â <built-inÂ functionÂ array></code></dt>
<dd>
<div class="desc"><p>Transformation matrix.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def transform(self) -&gt; numpy.array:
    &#34;&#34;&#34;Transformation matrix.&#34;&#34;&#34;
    return self.__transform</code></pre>
</details>
</dd>
<dt id="uim.model.ink.InkModel.unit_scale_factor"><code class="name">var <span class="ident">unit_scale_factor</span> :Â float</code></dt>
<dd>
<div class="desc"><p>LocalUnit * UnitScaleFactor = DIP (DIP = 1/96 of a logical Inch). ('float')</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def unit_scale_factor(self) -&gt; float:
    &#34;&#34;&#34; LocalUnit * UnitScaleFactor = DIP (DIP = 1/96 of a logical Inch). (&#39;float&#39;)&#34;&#34;&#34;
    return self.__unit_scale_factor</code></pre>
</details>
</dd>
<dt id="uim.model.ink.InkModel.version"><code class="name">var <span class="ident">version</span> :Â <a title="uim.codec.context.version.Version" href="../codec/context/version.html#uim.codec.context.version.Version">Version</a></code></dt>
<dd>
<div class="desc"><p>Version of ink content file used to create the model. (<code>Version</code>, read-only)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def version(self) -&gt; Version:
    &#34;&#34;&#34;Version of ink content file used to create the model. (`Version`, read-only)&#34;&#34;&#34;
    return self.__version</code></pre>
</details>
</dd>
<dt id="uim.model.ink.InkModel.views"><code class="name">var <span class="ident">views</span> :Â Tuple[<a title="uim.model.ink.InkTree" href="#uim.model.ink.InkTree">InkTree</a>]</code></dt>
<dd>
<div class="desc"><p>List of views.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def views(self) -&gt; Tuple[InkTree]:
    &#34;&#34;&#34;List of views.&#34;&#34;&#34;
    return tuple(self.__views)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="uim.model.ink.InkModel.add_property"><code class="name flex">
<span>def <span class="ident">add_property</span></span>(<span>self, name:Â str, value:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a property.
:param name: name of the property
:param value: value of the property</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_property(self, name: str, value: str):
    &#34;&#34;&#34;Adds a property.
    :param name: name of the property
    :param value: value of the property
    &#34;&#34;&#34;
    self.__properties.append((name, value))</code></pre>
</details>
</dd>
<dt id="uim.model.ink.InkModel.add_semantic_triple"><code class="name flex">
<span>def <span class="ident">add_semantic_triple</span></span>(<span>self, subject:Â str, predicate:Â str, obj:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>Adding a semantic triple to the object.</p>
<p>:param subject: subject of the statement
:param predicate: predicate of the statement
:param obj: object of the statement</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_semantic_triple(self, subject: str, predicate: str, obj: str):
    &#34;&#34;&#34;Adding a semantic triple to the object.

    :param subject: subject of the statement
    :param predicate: predicate of the statement
    :param obj: object of the statement
    &#34;&#34;&#34;
    self.__knowledge_graph.add_semantic_triple(subject, predicate, obj)</code></pre>
</details>
</dd>
<dt id="uim.model.ink.InkModel.add_tree"><code class="name flex">
<span>def <span class="ident">add_tree</span></span>(<span>self, tree:Â <a title="uim.model.ink.InkTree" href="#uim.model.ink.InkTree">InkTree</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Adding an ink tree to the model.
:param tree: InkTree -
Instance of the ink tree
:raises:
InkModelException - If name is already assigned to an ink model or</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_tree(self, tree: InkTree):
    &#34;&#34;&#34;Adding an ink tree to the model.
    :param tree: InkTree -
        Instance of the ink tree
    :raises:
        InkModelException - If name is already assigned to an ink model or
    &#34;&#34;&#34;
    if tree.model is not None:
        raise InkModelException(f&#34;InkTree with name {tree.name} is already assigned to an ink model.&#34;)

    if self.has_tree(tree.name):
        raise InkModelException(f&#34;InkTree with name {tree.name} is already assigned to the current ink model.&#34;)

    tree.model = self
    if tree.name == &#39;&#39; or tree.name == CommonViews.MAIN_INK_TREE.value:
        self.__ink_tree = tree
    else:
        self.__views.append(tree)

    if tree.root is not None:
        tree.register_sub_tree(tree.root)</code></pre>
</details>
</dd>
<dt id="uim.model.ink.InkModel.add_view"><code class="name flex">
<span>def <span class="ident">add_view</span></span>(<span>self, view:Â <a title="uim.model.ink.InkTree" href="#uim.model.ink.InkTree">InkTree</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Adding a view to the InkObject.
:param view: View object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_view(self, view: InkTree):
    &#34;&#34;&#34;Adding a view to the InkObject.
    :param view: View object
    &#34;&#34;&#34;
    self.add_tree(view)</code></pre>
</details>
</dd>
<dt id="uim.model.ink.InkModel.build_stroke_cache"><code class="name flex">
<span>def <span class="ident">build_stroke_cache</span></span>(<span>self, stroke:Â <a title="uim.model.inkdata.strokes.Stroke" href="inkdata/strokes.html#uim.model.inkdata.strokes.Stroke">Stroke</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Build stroke cache.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>stroke</code></strong> :&ensp;<code>Stroke</code></dt>
<dd>Stroke for cache</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_stroke_cache(self, stroke: Stroke):
    &#34;&#34;&#34;
    Build stroke cache.

    Parameters
    ----------
    stroke: Stroke
        Stroke for cache

    &#34;&#34;&#34;
    (ts, p) = self.get_stroke_timestamp_and_pressure_values(stroke)
    stroke.set_timestamp_values(ts)
    stroke.set_pressure_values(p)</code></pre>
</details>
</dd>
<dt id="uim.model.ink.InkModel.calculate_bounds_recursively"><code class="name flex">
<span>def <span class="ident">calculate_bounds_recursively</span></span>(<span>self, node:Â <a title="uim.model.semantics.node.InkNode" href="semantics/node.html#uim.model.semantics.node.InkNode">InkNode</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the bounds recursively.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>Node</code></dt>
<dd>Node of the tree</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_bounds_recursively(self, node: InkNode):
    &#34;&#34;&#34;
    Calculates the bounds recursively.

    Parameters
    ----------
    node: Node
        Node of the tree
    &#34;&#34;&#34;
    x_min: float = sys.float_info.max
    x_max: float = 0.
    y_min: float = sys.float_info.max
    y_max: float = 0.
    if isinstance(node, StrokeNode):
        stroke_node: StrokeNode = node
        x_min: float = min(stroke_node.stroke.spline_min_x, x_min)
        x_max: float = max(stroke_node.stroke.spline_max_x, x_max)
        y_min: float = min(stroke_node.stroke.spline_min_y, y_min)
        y_max: float = max(stroke_node.stroke.spline_max_y, y_max)
        node.group_bounding_box = BoundingBox(x_min, y_min, x_max - x_min, y_max - y_min)
    elif isinstance(node, StrokeGroupNode):
        for child_node in node.children:
            self.calculate_bounds_recursively(child_node)
            child_bbox: BoundingBox = child_node.group_bounding_box
            x_min: float = min(child_bbox.x, x_min)
            x_max: float = max(child_bbox.x + child_bbox.width, x_max)
            y_min: float = min(child_bbox.y, y_min)
            y_max: float = max(child_bbox.y + child_bbox.height, y_max)
        bbox: BoundingBox = BoundingBox(x_min, y_min, x_max - x_min, y_max - y_min)
        node.group_bounding_box = bbox</code></pre>
</details>
</dd>
<dt id="uim.model.ink.InkModel.clear_knowledge_graph"><code class="name flex">
<span>def <span class="ident">clear_knowledge_graph</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clears the knowledge graph.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_knowledge_graph(self):
    &#34;&#34;&#34;Clears the knowledge graph.&#34;&#34;&#34;
    self.__knowledge_graph.clear_statements()</code></pre>
</details>
</dd>
<dt id="uim.model.ink.InkModel.clear_views"><code class="name flex">
<span>def <span class="ident">clear_views</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clears the views.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_views(self):
    &#34;&#34;&#34;Clears the views.&#34;&#34;&#34;
    self.__views = []</code></pre>
</details>
</dd>
<dt id="uim.model.ink.InkModel.clone_stroke_group_node"><code class="name flex">
<span>def <span class="ident">clone_stroke_group_node</span></span>(<span>self, stroke_group_node:Â <a title="uim.model.semantics.node.StrokeGroupNode" href="semantics/node.html#uim.model.semantics.node.StrokeGroupNode">StrokeGroupNode</a>, target_parent_node:Â <a title="uim.model.semantics.node.StrokeGroupNode" href="semantics/node.html#uim.model.semantics.node.StrokeGroupNode">StrokeGroupNode</a>Â =Â None, clone_semantics:Â boolÂ =Â True, clone_child_stroke_nodes:Â boolÂ =Â True, clone_child_group_nodes:Â boolÂ =Â False, raise_exception:Â boolÂ =Â False, store_source_node_reference_transient_key:Â strÂ =Â None) â>Â <a title="uim.model.semantics.node.StrokeGroupNode" href="semantics/node.html#uim.model.semantics.node.StrokeGroupNode">StrokeGroupNode</a></span>
</code></dt>
<dd>
<div class="desc"><p>Clone stroke group node.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>stroke_group_node</code></strong> :&ensp;<code>StrokeGroupNode</code></dt>
<dd>StrokeGroupNode to be cloned.</dd>
<dt><strong><code>target_parent_node</code></strong> :&ensp;<code>StrokeGroupNode</code></dt>
<dd>Target node</dd>
<dt><strong><code>clone_semantics</code></strong> :&ensp;<code>bool</code></dt>
<dd>Clone semantics [default:=True]</dd>
<dt><strong><code>clone_child_stroke_nodes</code></strong> :&ensp;<code>bool</code></dt>
<dd>Clone child stroke nodes [default:=True]</dd>
<dt><strong><code>clone_child_group_nodes</code></strong> :&ensp;<code>bool</code></dt>
<dd>Clone child group nodes [default:=False]</dd>
<dt><strong><code>raise_exception</code></strong> :&ensp;<code>bool</code></dt>
<dd>Raise exceptions [default:=False]</dd>
<dt><strong><code>store_source_node_reference_transient_key</code></strong> :&ensp;<code>str</code></dt>
<dd>Store source node reference.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>new_stroke_group_node</code></strong> :&ensp;<code>StrokeGroupNode</code></dt>
<dd>Cloned <code>StrokeGroupNode</code></dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>InkModelException</code></dt>
<dd>If cloning needs to be aborted.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clone_stroke_group_node(self, stroke_group_node: StrokeGroupNode,
                            target_parent_node: StrokeGroupNode = None,
                            clone_semantics: bool = True,
                            clone_child_stroke_nodes: bool = True,
                            clone_child_group_nodes: bool = False,
                            raise_exception: bool = False,
                            store_source_node_reference_transient_key: str = None) -&gt; StrokeGroupNode:
    &#34;&#34;&#34;
    Clone stroke group node.

    Parameters
    ----------
    stroke_group_node: `StrokeGroupNode`
        StrokeGroupNode to be cloned.
    target_parent_node: `StrokeGroupNode`
        Target node
    clone_semantics: `bool`
        Clone semantics [default:=True]
    clone_child_stroke_nodes: `bool`
        Clone child stroke nodes [default:=True]
    clone_child_group_nodes: bool
        Clone child group nodes [default:=False]
    raise_exception: bool
        Raise exceptions [default:=False]
    store_source_node_reference_transient_key: str
        Store source node reference.

    Returns
    -------
    new_stroke_group_node: `StrokeGroupNode`
        Cloned `StrokeGroupNode`

    Raises
    ------
    InkModelException
        If cloning needs to be aborted.
    &#34;&#34;&#34;
    new_node: StrokeGroupNode = StrokeGroupNode(UUIDIdentifier.id_generator())

    if target_parent_node is not None:
        target_parent_node.add(new_node)

    if clone_semantics:
        triples = self.knowledge_graph.filter(stroke_group_node.uri)
        t: SemanticTriple
        for t in triples:
            self.knowledge_graph.add_semantic_triple(new_node.uri, t.predicate, t.object)

    if clone_child_stroke_nodes or clone_child_group_nodes:
        for n in stroke_group_node.children:
            child_clone: Optional[InkNode] = None

            if isinstance(n, StrokeNode):
                if clone_child_stroke_nodes:
                    child_clone = self.clone_stroke_node(n, target_parent_node=new_node,
                                                         clone_semantics=clone_semantics)
                elif raise_exception:
                    raise InkModelException(&#34;Cloning aborted: Stroke node would be left behind if we continue.&#34;)

            elif isinstance(n, StrokeGroupNode):
                if clone_child_group_nodes:
                    child_clone = self.clone_stroke_group_node(n, target_parent_node=new_node,
                                                               clone_semantics=clone_semantics,
                                                               clone_child_stroke_nodes=clone_child_stroke_nodes,
                                                               clone_child_group_nodes=clone_child_group_nodes,
                                                               raise_exception=raise_exception)
                elif raise_exception:
                    raise InkModelException(&#34;Cloning aborted: Group node would be left behind if we continue.&#34;)

            if store_source_node_reference_transient_key is not None:
                child_clone.transient_tag = {store_source_node_reference_transient_key: n}
    return new_node</code></pre>
</details>
</dd>
<dt id="uim.model.ink.InkModel.clone_stroke_node"><code class="name flex">
<span>def <span class="ident">clone_stroke_node</span></span>(<span>self, stroke_node:Â <a title="uim.model.semantics.node.StrokeNode" href="semantics/node.html#uim.model.semantics.node.StrokeNode">StrokeNode</a>, target_parent_node:Â <a title="uim.model.semantics.node.StrokeGroupNode" href="semantics/node.html#uim.model.semantics.node.StrokeGroupNode">StrokeGroupNode</a>Â =Â None, clone_semantics:Â boolÂ =Â True) â>Â <a title="uim.model.semantics.node.StrokeNode" href="semantics/node.html#uim.model.semantics.node.StrokeNode">StrokeNode</a></span>
</code></dt>
<dd>
<div class="desc"><p>Cloning a stroke node.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>stroke_node</code></strong> :&ensp;<code>StrokeNode</code></dt>
<dd>Stroke node which shall be cloned</dd>
<dt><strong><code>target_parent_node</code></strong> :&ensp;<code>StrokeGroupNode</code></dt>
<dd>Target node</dd>
<dt><strong><code>clone_semantics</code></strong> :&ensp;<code>bool</code></dt>
<dd>Cloning semantics</dd>
</dl>
<h2 id="returns">Returns</h2>
<pre><code>stroke: &lt;code&gt;StrokeNode&lt;/code&gt;
    Cloned stroke
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clone_stroke_node(self, stroke_node: StrokeNode,  target_parent_node: StrokeGroupNode = None,
                      clone_semantics: bool = True) -&gt; StrokeNode:
    &#34;&#34;&#34;
    Cloning a stroke node.

    Parameters
    ----------
    stroke_node: `StrokeNode`
        Stroke node which shall be cloned

    target_parent_node: `StrokeGroupNode`
        Target node

    clone_semantics: `bool`
        Cloning semantics

    Returns
    -------
        stroke: `StrokeNode`
            Cloned stroke
    &#34;&#34;&#34;
    if stroke_node.fragment is not None:
        f = stroke_node.fragment
        fragment = StrokeFragment(f.from_point_index, f.to_point_index, f.from_t_value, f.to_t_value)
    else:
        fragment = None

    new_node: StrokeNode = StrokeNode(stroke=stroke_node.stroke, fragment=fragment)

    if clone_semantics:
        triples = self.knowledge_graph.filter(stroke_node.uri)
        t: SemanticTriple
        for t in triples:
            self.knowledge_graph.add_semantic_triple(new_node.uri, t.predicate, t.object)

    if target_parent_node is not None:
        target_parent_node.add(new_node)

    return new_node</code></pre>
</details>
</dd>
<dt id="uim.model.ink.InkModel.get_semantic_statement"><code class="name flex">
<span>def <span class="ident">get_semantic_statement</span></span>(<span>self, subject:Â str) â>Â <a title="uim.model.semantics.schema.SemanticTriple" href="semantics/schema.html#uim.model.semantics.schema.SemanticTriple">SemanticTriple</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns the document property (or the optional default value).</p>
<p>:param subject: str -
key for property
:return: value or None
:raises:
InkModelException: Raised if no semantic triple is existing for subject.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_semantic_statement(self, subject: str) -&gt; schema.SemanticTriple:
    &#34;&#34;&#34;Returns the document property (or the optional default value).

    :param subject: str -
        key for property
    :return: value or None
    :raises:
        InkModelException: Raised if no semantic triple is existing for subject.
    &#34;&#34;&#34;
    for sem in self.knowledge_graph.statements:
        if sem.subject == subject:
            return sem
    raise InkModelException(&#39;No semantic triple for subject:= {}.&#39;.format(subject))</code></pre>
</details>
</dd>
<dt id="uim.model.ink.InkModel.get_stroke_timestamp_and_pressure_values"><code class="name flex">
<span>def <span class="ident">get_stroke_timestamp_and_pressure_values</span></span>(<span>self, stroke:Â <a title="uim.model.inkdata.strokes.Stroke" href="inkdata/strokes.html#uim.model.inkdata.strokes.Stroke">Stroke</a>, duplicate_first_and_last:Â boolÂ =Â True) â>Â Tuple[List[float],Â List[float]]</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the timestamp and pressure values.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>stroke</code></strong> :&ensp;<code>Stroke</code></dt>
<dd>Stroke</dd>
<dt><strong><code>duplicate_first_and_last</code></strong> :&ensp;<code>bool</code></dt>
<dd>Duplicate first and last</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>timestamps</code></strong> :&ensp;<code> List[float]</code></dt>
<dd>List of timestamp values</dd>
<dt><strong><code>pressure_values</code></strong> :&ensp;<code> List[float]</code></dt>
<dd>List of pressure values</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_stroke_timestamp_and_pressure_values(self, stroke: Stroke, duplicate_first_and_last: bool = True) \
        -&gt; Tuple[List[float], List[float]]:
    &#34;&#34;&#34;
    Gets the timestamp and pressure values.

    Parameters
    ----------
    stroke: `Stroke`
        Stroke
    duplicate_first_and_last: `bool`
        Duplicate first and last

    Returns
    -------
    timestamps:  List[float]
        List of timestamp values
    pressure_values:  List[float]
        List of pressure values
    &#34;&#34;&#34;
    sd: SensorData = self.sensor_data.sensor_data_by_id(stroke.sensor_data_id)
    sensor_channels: list = self.input_configuration.sensor_contexts[0].sensor_channels_contexts[0] \
        .channels

    t_channel_id = [c.id for c in sensor_channels if c.type == InkSensorType.TIMESTAMP][0]
    p_channel_id = [c.id for c in sensor_channels if c.type == InkSensorType.PRESSURE][0]

    ts: list = []
    ps: list = []

    for cd in sd.data_channels:
        if cd.id == t_channel_id:
            ts = cd.values.copy()
        elif cd.id == p_channel_id:
            ps = cd.values.copy()

    if duplicate_first_and_last:
        ts.insert(0, ts[0])
        ts.append(ts[-1])

        ps.insert(0, ps[0])
        ps.append(ps[-1])

    return ts, ps</code></pre>
</details>
</dd>
<dt id="uim.model.ink.InkModel.get_strokes_as_strided_array"><code class="name flex">
<span>def <span class="ident">get_strokes_as_strided_array</span></span>(<span>self, layout:Â strÂ =Â 'xytp', policy:Â <a title="uim.model.helpers.policy.HandleMissingDataPolicy" href="helpers/policy.html#uim.model.helpers.policy.HandleMissingDataPolicy">HandleMissingDataPolicy</a>Â =Â HandleMissingDataPolicy.FILL_WITH_ZEROS) â>Â Tuple[List,Â str]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns all the strokes in the document, where each stroke is an array with stride 4.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>layout</code></strong> :&ensp;<code>str -</code></dt>
<dd>Layout string - 'xytp' (x, y, timestamp, pressure).</dd>
<dt><strong><code>policy</code></strong> :&ensp;<code>HandleMissingDataPolicy -</code></dt>
<dd>Policy to handle missing data.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong> :&ensp;<code>List</code></dt>
<dd>Strided array</dd>
<dt><strong><code>layout</code></strong> :&ensp;<code>str</code></dt>
<dd>Layout string</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_strokes_as_strided_array(self, layout: str = &#34;xytp&#34;,
                                 policy: HandleMissingDataPolicy = HandleMissingDataPolicy.FILL_WITH_ZEROS) \
        -&gt; Tuple[List, str]:
    &#34;&#34;&#34;
    Returns all the strokes in the document, where each stroke is an array with stride 4.

    Parameters
    ----------
    layout: str -
        Layout string - &#39;xytp&#39; (x, y, timestamp, pressure).
    policy: HandleMissingDataPolicy -
        Policy to handle missing data.

    Returns
    -------
    array: `List`
        Strided array
    layout: `str`
        Layout string
    &#34;&#34;&#34;

    if layout != &#34;xytp&#34;:
        raise ValueError(&#34;Unsupported layout: %s&#34; % layout)

    strokes: List[Stroke] = self.strokes
    result: List = []
    for stroke in strokes:
        # Remove the first and last element, which are added by the spline producer
        xs = stroke.splines_x[1:-1]
        ys = stroke.splines_y[1:-1]

        sd: SensorData = self.sensor_data.sensor_data_by_id(stroke.sensor_data_id)

        sc_ts: Optional[SensorChannel] = None
        sc_pressure: Optional[SensorChannel] = None

        input_context: InputContext = self.input_configuration.get_input_context(sd.input_context_id)
        if input_context is not None:
            sensor_context = self.input_configuration.get_sensor_context(input_context.sensor_context_id)
            if sensor_context is not None:
                sc_ts = None
                sc_pressure = None

                if sensor_context.has_channel_type(InkSensorType.TIMESTAMP):
                    sc_ts = sensor_context.get_channel_by_type(InkSensorType.TIMESTAMP)

                if sensor_context.has_channel_type(InkSensorType.PRESSURE):
                    sc_pressure = sensor_context.get_channel_by_type(InkSensorType.PRESSURE)
        if sd is None or sc_ts is None or sd.get_data_by_id(sc_ts.id) is None:
            ts = []
        else:
            ts = sd.get_data_by_id(sc_ts.id).values.copy()

        if sd is None or sc_pressure is None or sd.get_data_by_id(sc_pressure.id) is None:
            ps = []
        else:
            ps = sd.get_data_by_id(sc_pressure.id).values.copy()

        xs = xs[0:len(ts)]
        ys = ys[0:len(ts)]

        # Handle missing timestamp according to policy
        if len(ts) == 0:
            if policy == HandleMissingDataPolicy.SKIP_STROKE:
                continue
            elif policy == HandleMissingDataPolicy.THROW_EXCEPTION:
                raise ValueError(&#34;There is no timestamp data for this stroke.&#34;)

        # Handle missing pressure according to policy
        if len(ps) == 0:
            if policy == HandleMissingDataPolicy.SKIP_STROKE:
                continue
            elif policy == HandleMissingDataPolicy.THROW_EXCEPTION:
                raise ValueError(&#34;There is no pressure data for this stroke.&#34;)

        points = []

        sensor_data_mapping = stroke.sensor_data_mapping

        if len(sensor_data_mapping) == 0:  # Mapping is 1:1
            limit = min(stroke.sensor_data_offset + len(xs), len(ts))
            sensor_data_mapping = range(stroke.sensor_data_offset, limit)

        i = 0

        for map_i in sensor_data_mapping:
            points.append(xs[i])
            points.append(ys[i])

            if len(ts) == 0:
                points.append(0)
            else:
                points.append(ts[map_i])

            if len(ps) == 0:
                points.append(0)
            else:
                points.append(ps[map_i])

            i += 1

        result.append(points)

    return result, layout</code></pre>
</details>
</dd>
<dt id="uim.model.ink.InkModel.has_brushes"><code class="name flex">
<span>def <span class="ident">has_brushes</span></span>(<span>self) â>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if the Ink Model has brushes configured.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>flag</code></strong> :&ensp;<code>bool</code></dt>
<dd>Flag if brushes have been configured for InkModel</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_brushes(self) -&gt; bool:
    &#34;&#34;&#34;
    Checks if the Ink Model has brushes configured.

    Returns
    -------
    flag: `bool`
        Flag if brushes have been configured for InkModel
    &#34;&#34;&#34;
    return len(self.brushes.vector_brushes) &gt; 0 or len(self.brushes.raster_brushes) &gt; 0</code></pre>
</details>
</dd>
<dt id="uim.model.ink.InkModel.has_ink_data"><code class="name flex">
<span>def <span class="ident">has_ink_data</span></span>(<span>self) â>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if the Ink Model has ink data configured.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>flag</code></strong> :&ensp;<code>bool</code></dt>
<dd>Flag if ink data have been configured for InkModel</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_ink_data(self) -&gt; bool:
    &#34;&#34;&#34;
    Checks if the Ink Model has ink data configured.

    Returns
    -------
    flag: `bool`
        Flag if ink data have been configured for InkModel
    &#34;&#34;&#34;
    try:
        return self.ink_tree is not None
    except FormatException:
        return False</code></pre>
</details>
</dd>
<dt id="uim.model.ink.InkModel.has_ink_structure"><code class="name flex">
<span>def <span class="ident">has_ink_structure</span></span>(<span>self) â>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if the Ink Model has ink structure configured.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>flag</code></strong> :&ensp;<code>bool</code></dt>
<dd>Flag if input data have been configured for InkModel</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_ink_structure(self) -&gt; bool:
    &#34;&#34;&#34;
    Checks if the Ink Model has ink structure configured.

    Returns
    -------
    flag: `bool`
        Flag if input data have been configured for InkModel
    &#34;&#34;&#34;
    try:
        if self.ink_tree is None:
            return False
        return self.ink_tree.root is not None
    except FormatException:
        return False</code></pre>
</details>
</dd>
<dt id="uim.model.ink.InkModel.has_input_data"><code class="name flex">
<span>def <span class="ident">has_input_data</span></span>(<span>self) â>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if the Ink Model has input data configured.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>flag</code></strong> :&ensp;<code>bool</code></dt>
<dd>Flag if input data have been configured for InkModel</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_input_data(self) -&gt; bool:
    &#34;&#34;&#34;
    Checks if the Ink Model has input data configured.

    Returns
    -------
    flag: `bool`
        Flag if input data have been configured for InkModel
    &#34;&#34;&#34;
    return len(self.sensor_data.sensor_data) &gt; 0 or self.input_configuration.has_configuration()</code></pre>
</details>
</dd>
<dt id="uim.model.ink.InkModel.has_knowledge_graph"><code class="name flex">
<span>def <span class="ident">has_knowledge_graph</span></span>(<span>self) â>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if the Ink Model has knowledge graph configured.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>flag</code></strong> :&ensp;<code>bool</code></dt>
<dd>Flag if knowledge graph have been configured for InkModel</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_knowledge_graph(self) -&gt; bool:
    &#34;&#34;&#34;
    Checks if the Ink Model has knowledge graph configured.

    Returns
    -------
    flag: `bool`
        Flag if knowledge graph have been configured for InkModel
    &#34;&#34;&#34;
    return len(self.knowledge_graph.statements) &gt; 0</code></pre>
</details>
</dd>
<dt id="uim.model.ink.InkModel.has_properties"><code class="name flex">
<span>def <span class="ident">has_properties</span></span>(<span>self) â>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if the Ink Model has properties configured.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>flag</code></strong> :&ensp;<code>bool</code></dt>
<dd>Flag if properties have been configured for InkModel</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_properties(self) -&gt; bool:
    &#34;&#34;&#34;
    Checks if the Ink Model has properties configured.

    Returns
    --------
    flag: `bool`
        Flag if properties have been configured for InkModel
    &#34;&#34;&#34;
    return len(self.properties) &gt; 0</code></pre>
</details>
</dd>
<dt id="uim.model.ink.InkModel.has_tree"><code class="name flex">
<span>def <span class="ident">has_tree</span></span>(<span>self, name:Â str) â>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if the named tree exists.
:param name: str -
Name of the tree
:returns: flag if the tree exists</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_tree(self, name: str) -&gt; bool:
    &#34;&#34;&#34;Check if the named tree exists.
    :param name: str -
        Name of the tree
    :returns: flag if the tree exists
    &#34;&#34;&#34;
    if name == CommonViews.MAIN_INK_TREE.value:
        return self.ink_tree is not None
    else:
        for v in self.views:
            if v.name == name:
                return True
    return False</code></pre>
</details>
</dd>
<dt id="uim.model.ink.InkModel.is_node_registered"><code class="name flex">
<span>def <span class="ident">is_node_registered</span></span>(<span>self, node:Â <a title="uim.model.semantics.node.InkNode" href="semantics/node.html#uim.model.semantics.node.InkNode">InkNode</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if node is registered.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>InkNode</code></dt>
<dd>Node to check</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>flag</code></strong> :&ensp;<code>bool</code></dt>
<dd>Flag if node is already registered in tree.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_node_registered(self, node: InkNode):
    &#34;&#34;&#34;
    Check if node is registered.

    Parameters
    ----------
    node: `InkNode`
        Node to check

    Returns
    -------
    flag: `bool`
        Flag if node is already registered in tree.
    &#34;&#34;&#34;
    return self.__map.get(node.uri) is not None</code></pre>
</details>
</dd>
<dt id="uim.model.ink.InkModel.register_node"><code class="name flex">
<span>def <span class="ident">register_node</span></span>(<span>self, node:Â <a title="uim.model.semantics.node.InkNode" href="semantics/node.html#uim.model.semantics.node.InkNode">InkNode</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Register ink node.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>InkNode</code></dt>
<dd>Reference to node.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>InkModelException</code></dt>
<dd>If Node with URI already exist in the tree</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register_node(self, node: InkNode):
    &#34;&#34;&#34;
    Register ink node.

    Parameters
    ----------
    node: `InkNode`
        Reference to node.

    Raises
    ------
    InkModelException
        If Node with URI already exist in the tree
    &#34;&#34;&#34;
    if self.__map.get(node.uri) is not None:
        raise InkModelException(f&#39;An ink node with uri {node.uri} already exists in the model.&#39;)
    else:
        if node_registration_debug:
            logger.debug(f&#34;Registering node {node.uri}&#34;)

    self.__map[node.uri] = node</code></pre>
</details>
</dd>
<dt id="uim.model.ink.InkModel.remove_node"><code class="name flex">
<span>def <span class="ident">remove_node</span></span>(<span>self, node:Â <a title="uim.model.semantics.node.InkNode" href="semantics/node.html#uim.model.semantics.node.InkNode">InkNode</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove a node.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>InkNode</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>Node to be remove</p>
<h2 id="notes">Notes</h2>
<p>This function removes the triples and the node as well.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_node(self, node: InkNode):
    &#34;&#34;&#34;
    Remove a node.

    Parameters
    ----------
    node: `InkNode`
       Node to be remove

    Notes
    -----
    This function removes the triples and the node as well.

   &#34;&#34;&#34;
    # First remove the triples
    self.unregister_node(node)
    if node.parent is not None:
        node.parent.remove(node)</code></pre>
</details>
</dd>
<dt id="uim.model.ink.InkModel.remove_semantic_triple"><code class="name flex">
<span>def <span class="ident">remove_semantic_triple</span></span>(<span>self, subject:Â str, predicate:Â str, obj:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove a semantic triple from the object.</p>
<p>:param subject:
:param predicate:
:param obj:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_semantic_triple(self, subject: str, predicate: str, obj: str):
    &#34;&#34;&#34;Remove a semantic triple from the object.

    :param subject:
    :param predicate:
    :param obj:
    &#34;&#34;&#34;
    self.__knowledge_graph.remove_semantic_triple(schema.SemanticTriple(subject, predicate, obj))</code></pre>
</details>
</dd>
<dt id="uim.model.ink.InkModel.remove_tree"><code class="name flex">
<span>def <span class="ident">remove_tree</span></span>(<span>self, name:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>Removing view tree from model.
:param name: str -
Name of the tree that should be removed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_tree(self, name: str):
    &#34;&#34;&#34;Removing view tree from model.
    :param name: str -
        Name of the tree that should be removed

    &#34;&#34;&#34;
    tree: InkTree = self.tree(name)
    tree.unregister_sub_tree(tree.root)
    if tree.name == &#39;&#39; or tree.name == CommonViews.MAIN_INK_TREE.value:
        self.__ink_tree = None
    else:
        self.__views.remove(tree)</code></pre>
</details>
</dd>
<dt id="uim.model.ink.InkModel.sensor_data_lookup"><code class="name flex">
<span>def <span class="ident">sensor_data_lookup</span></span>(<span>self, stroke:Â <a title="uim.model.inkdata.strokes.Stroke" href="inkdata/strokes.html#uim.model.inkdata.strokes.Stroke">Stroke</a>, ink_sensor_type:Â <a title="uim.model.inkinput.inputdata.InkSensorType" href="inkinput/inputdata.html#uim.model.inkinput.inputdata.InkSensorType">InkSensorType</a>, return_channel_data_instance:Â boolÂ =Â False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sensor_data_lookup(self, stroke: Stroke, ink_sensor_type: InkSensorType,
                       return_channel_data_instance: bool = False):
    sd: SensorData = self.sensor_data.sensor_data_by_id(stroke.sensor_data_id)

    sc = None

    input_context = self.input_configuration.get_input_context(sd.input_context_id)
    if input_context is not None:
        sensor_context = self.input_configuration.get_sensor_context(input_context.sensor_context_id)
        if sensor_context is not None:

            if sensor_context.has_channel_type(ink_sensor_type):
                sc = sensor_context.get_channel_by_type(ink_sensor_type)

    if sd is None or sc is None or sd.get_data_by_id(sc.id) is None:
        return None if return_channel_data_instance else []
    else:
        return sd.get_data_by_id(sc.id) if return_channel_data_instance else sd.get_data_by_id(sc.id).values.copy()</code></pre>
</details>
</dd>
<dt id="uim.model.ink.InkModel.stroke_by_id"><code class="name flex">
<span>def <span class="ident">stroke_by_id</span></span>(<span>self, stroke_uuid:Â uuid.UUID) â>Â <a title="uim.model.inkdata.strokes.Stroke" href="inkdata/strokes.html#uim.model.inkdata.strokes.Stroke">Stroke</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns the stroke for a specific UUID.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>stroke_uuid</code></strong> :&ensp;<code>UUID</code></dt>
<dd>ID of the stroke</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>stroke</code></strong> :&ensp;<code>Stroke</code></dt>
<dd>Instance of the
stroke</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stroke_by_id(self, stroke_uuid: uuid.UUID) -&gt; Stroke:
    &#34;&#34;&#34;
    Returns the stroke for a specific UUID.

    Parameters
    ----------
    stroke_uuid: `UUID`
        ID of the stroke

    Returns
    -------
    stroke: `Stroke`
        Instance of the  stroke
    &#34;&#34;&#34;
    for node in PreOrderEnumerator(self.ink_tree.root):
        if isinstance(node, StrokeNode):
            if node.stroke.id == stroke_uuid:
                return node.stroke
    raise InkModelException(f&#34;Stroke with id {stroke_uuid} does not exist in main tree.&#34;)</code></pre>
</details>
</dd>
<dt id="uim.model.ink.InkModel.tree"><code class="name flex">
<span>def <span class="ident">tree</span></span>(<span>self, name:Â str) â>Â <a title="uim.model.ink.InkTree" href="#uim.model.ink.InkTree">InkTree</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return named tree.
:returns: tree for defined name</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tree(self, name: str) -&gt; InkTree:
    &#34;&#34;&#34;Return named tree.
    :returns: tree for defined name
    &#34;&#34;&#34;
    if name == CommonViews.MAIN_INK_TREE.value:
        return self.ink_tree
    else:
        for v in self.views:
            if v.name == name:
                return v
    raise InkModelException(f&#34;InkTree with name {name} is not found.&#34;)</code></pre>
</details>
</dd>
<dt id="uim.model.ink.InkModel.unregister_node"><code class="name flex">
<span>def <span class="ident">unregister_node</span></span>(<span>self, node:Â <a title="uim.model.semantics.node.InkNode" href="semantics/node.html#uim.model.semantics.node.InkNode">InkNode</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Unregister a node.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>InkNode</code></dt>
<dd>Node to unregister</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>This function removes the triples for the node as well.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unregister_node(self, node: InkNode):
    &#34;&#34;&#34;
    Unregister a node.

    Parameters
    ----------
    node: `InkNode`
        Node to unregister

    Notes
    -----
    This function removes the triples for the node as well.

    &#34;&#34;&#34;
    if node_registration_debug:
        logger.debug(f&#34;Unregistering node {node.uri}&#34;)
        
    if node.tree is not None:
        triples = self.knowledge_graph.filter(node.uri)
        if node_registration_debug:
            logger.debug(f&#34;Found {len(triples)} triples for {node.uri}&#34;)
        for t in triples:
            if node_registration_debug:
                logger.debug(f&#34;Removing semantic triple: {str(t)}&#34;)
            self.knowledge_graph.remove_semantic_triple(t)

        if node_registration_debug:
            triples = self.knowledge_graph.filter(node.uri)
            logger.debug(f&#34;Sanity check =&gt; Found {len(triples)} triples for {node.uri}&#34;)

    del self.__map[node.uri]</code></pre>
</details>
</dd>
<dt id="uim.model.ink.InkModel.view"><code class="name flex">
<span>def <span class="ident">view</span></span>(<span>self, name:Â str) â>Â <a title="uim.model.ink.InkTree" href="#uim.model.ink.InkTree">InkTree</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns the view.
:param name: CommonViews -
Name of the view
:return : instance of the name
:raises:
KeyError: View with name does not exist</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def view(self, name: str) -&gt; InkTree:
    &#34;&#34;&#34;Returns the view.
    :param name: CommonViews -
        Name of the view
    :return : instance of the name
    :raises:
        KeyError: View with name does not exist
    &#34;&#34;&#34;
    for v in self.__views:
        if v.name == name:
            return v
    raise KeyError(&#39;No view with name:={}&#39;.format(name))</code></pre>
</details>
</dd>
<dt id="uim.model.ink.InkModel.view_root"><code class="name flex">
<span>def <span class="ident">view_root</span></span>(<span>self, name:Â str) â>Â <a title="uim.model.semantics.node.StrokeGroupNode" href="semantics/node.html#uim.model.semantics.node.StrokeGroupNode">StrokeGroupNode</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns the root for a view.
:param name: CommonViews -
Name of the view
:return : root of named view
:raises:
KeyError: View with name does not exist</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def view_root(self, name: str) -&gt; StrokeGroupNode:
    &#34;&#34;&#34;Returns the root for a view.
    :param name: CommonViews -
        Name of the view
    :return : root of named view
    :raises:
        KeyError: View with name does not exist
    &#34;&#34;&#34;
    return self.view(name).root</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="uim.model.ink.InkTree"><code class="flex name class">
<span>class <span class="ident">InkTree</span></span>
<span>(</span><span>name:Â strÂ =Â 'main')</span>
</code></dt>
<dd>
<div class="desc"><h1 id="inktree">InkTree</h1>
<p>The digital ink content, contained within a universal ink model, is organized in logical trees of ink nodes -
they represent hierarchically organized ink-centric structures, and are also referred to as ink trees.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str -</code></dt>
<dd>Name of the view</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InkTree(ABC):
    &#34;&#34;&#34;
    InkTree
    =======
    The digital ink content, contained within a universal ink model, is organized in logical trees of ink nodes -
    they represent hierarchically organized ink-centric structures, and are also referred to as ink trees.

    Parameters
    ----------
    name: str -
        Name of the view
    &#34;&#34;&#34;

    def __init__(self, name: str = CommonViews.MAIN_INK_TREE.value):
        self.__name: str = name
        self.__model: Optional[InkModel] = None
        self.__root: Optional[StrokeGroupNode] = None

    @property
    def model(self) -&gt; &#39;InkModel&#39;:
        &#34;&#34;&#34;Reference to the model. (`InkModel`)&#34;&#34;&#34;
        return self.__model

    @model.setter
    def model(self, value: &#39;InkModel&#39;):
        self.__model = value

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;The primary name associated with this ink tree. (`str`)&#34;&#34;&#34;
        return self.__name

    @name.setter
    def name(self, value: str):
        self.__name = value

    @property
    def root(self) -&gt; StrokeGroupNode:
        &#34;&#34;&#34;Root node of the tree. (`StrokeGroupNode`)&#34;&#34;&#34;
        return self.__root

    @root.setter
    def root(self, root: StrokeGroupNode):
        root.__assert_not_owned__()
        if self.__root is not None:
            self.unregister_sub_tree(self.__root)
            self.__root = None
        self.register_sub_tree(root)
        self.__root = root

    def __iter__(self):
        return PreOrderEnumerator(self.__root)

    def __repr__(self):
        if self.__root:
            return f&#39;&lt;Ink Tree: [name:={self.name},  root id:={self.root}]&gt;&#39;
        return f&#39;&lt;Ink Tree: [name:={self.name}] - Empty tree&#39;

    def register_node(self, node: InkNode):
        &#34;&#34;&#34;
        Register node.

        Parameters
        ----------
        node: `InkNode`
            Node that needs to be registered
        &#34;&#34;&#34;
        if self.model is None:
            logger.warning(f&#34;InkTree with name {self.name} not yet attached to a model.&#34;)

        node.tree = self

        if self.model is not None:
            self.__model.register_node(node)

    def unregister_node(self, node: InkNode):
        &#34;&#34;&#34;
        Unregister node.

        Parameters
        ----------
        node: `InkNode`
            Node that needs to be unregistered
        &#34;&#34;&#34;
        if self.__model is not None:
            self.__model.unregister_node(node)

    def register_sub_tree(self, node: InkNode):
        &#34;&#34;&#34;
        Register sub tree.

        Parameters
        ----------
        node: `InkNode`
            Sub tree that needs to be registered
        &#34;&#34;&#34;
        if node.child_nodes_count() == 0:
            self.register_node(node)
        else:
            for n in PreOrderEnumerator(node):
                self.register_node(n)

    def unregister_sub_tree(self, node: InkNode):
        &#34;&#34;&#34;
        Unregister sub tree.

        Parameters
        ----------
        node: `InkNode`
            Sub tree that needs to be unregistered
        &#34;&#34;&#34;
        if node.child_nodes_count() == 0:
            self.unregister_node(node)
        else:
            for n in PreOrderEnumerator(node):
                self.unregister_node(n)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="uim.model.ink.InkTree.model"><code class="name">var <span class="ident">model</span> :Â <a title="uim.model.ink.InkModel" href="#uim.model.ink.InkModel">InkModel</a></code></dt>
<dd>
<div class="desc"><p>Reference to the model. (<code><a title="uim.model.ink.InkModel" href="#uim.model.ink.InkModel">InkModel</a></code>)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def model(self) -&gt; &#39;InkModel&#39;:
    &#34;&#34;&#34;Reference to the model. (`InkModel`)&#34;&#34;&#34;
    return self.__model</code></pre>
</details>
</dd>
<dt id="uim.model.ink.InkTree.name"><code class="name">var <span class="ident">name</span> :Â str</code></dt>
<dd>
<div class="desc"><p>The primary name associated with this ink tree. (<code>str</code>)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; str:
    &#34;&#34;&#34;The primary name associated with this ink tree. (`str`)&#34;&#34;&#34;
    return self.__name</code></pre>
</details>
</dd>
<dt id="uim.model.ink.InkTree.root"><code class="name">var <span class="ident">root</span> :Â <a title="uim.model.semantics.node.StrokeGroupNode" href="semantics/node.html#uim.model.semantics.node.StrokeGroupNode">StrokeGroupNode</a></code></dt>
<dd>
<div class="desc"><p>Root node of the tree. (<code>StrokeGroupNode</code>)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def root(self) -&gt; StrokeGroupNode:
    &#34;&#34;&#34;Root node of the tree. (`StrokeGroupNode`)&#34;&#34;&#34;
    return self.__root</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="uim.model.ink.InkTree.register_node"><code class="name flex">
<span>def <span class="ident">register_node</span></span>(<span>self, node:Â <a title="uim.model.semantics.node.InkNode" href="semantics/node.html#uim.model.semantics.node.InkNode">InkNode</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Register node.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>InkNode</code></dt>
<dd>Node that needs to be registered</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register_node(self, node: InkNode):
    &#34;&#34;&#34;
    Register node.

    Parameters
    ----------
    node: `InkNode`
        Node that needs to be registered
    &#34;&#34;&#34;
    if self.model is None:
        logger.warning(f&#34;InkTree with name {self.name} not yet attached to a model.&#34;)

    node.tree = self

    if self.model is not None:
        self.__model.register_node(node)</code></pre>
</details>
</dd>
<dt id="uim.model.ink.InkTree.register_sub_tree"><code class="name flex">
<span>def <span class="ident">register_sub_tree</span></span>(<span>self, node:Â <a title="uim.model.semantics.node.InkNode" href="semantics/node.html#uim.model.semantics.node.InkNode">InkNode</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Register sub tree.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>InkNode</code></dt>
<dd>Sub tree that needs to be registered</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register_sub_tree(self, node: InkNode):
    &#34;&#34;&#34;
    Register sub tree.

    Parameters
    ----------
    node: `InkNode`
        Sub tree that needs to be registered
    &#34;&#34;&#34;
    if node.child_nodes_count() == 0:
        self.register_node(node)
    else:
        for n in PreOrderEnumerator(node):
            self.register_node(n)</code></pre>
</details>
</dd>
<dt id="uim.model.ink.InkTree.unregister_node"><code class="name flex">
<span>def <span class="ident">unregister_node</span></span>(<span>self, node:Â <a title="uim.model.semantics.node.InkNode" href="semantics/node.html#uim.model.semantics.node.InkNode">InkNode</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Unregister node.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>InkNode</code></dt>
<dd>Node that needs to be unregistered</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unregister_node(self, node: InkNode):
    &#34;&#34;&#34;
    Unregister node.

    Parameters
    ----------
    node: `InkNode`
        Node that needs to be unregistered
    &#34;&#34;&#34;
    if self.__model is not None:
        self.__model.unregister_node(node)</code></pre>
</details>
</dd>
<dt id="uim.model.ink.InkTree.unregister_sub_tree"><code class="name flex">
<span>def <span class="ident">unregister_sub_tree</span></span>(<span>self, node:Â <a title="uim.model.semantics.node.InkNode" href="semantics/node.html#uim.model.semantics.node.InkNode">InkNode</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Unregister sub tree.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>InkNode</code></dt>
<dd>Sub tree that needs to be unregistered</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unregister_sub_tree(self, node: InkNode):
    &#34;&#34;&#34;
    Unregister sub tree.

    Parameters
    ----------
    node: `InkNode`
        Sub tree that needs to be unregistered
    &#34;&#34;&#34;
    if node.child_nodes_count() == 0:
        self.unregister_node(node)
    else:
        for n in PreOrderEnumerator(node):
            self.unregister_node(n)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="uim.model.ink.SensorDataRepository"><code class="flex name class">
<span>class <span class="ident">SensorDataRepository</span></span>
<span>(</span><span>sensor_data:Â List[<a title="uim.model.inkinput.sensordata.SensorData" href="inkinput/sensordata.html#uim.model.inkinput.sensordata.SensorData">SensorData</a>]Â =Â None)</span>
</code></dt>
<dd>
<div class="desc"><h1 id="sensordatarepository">SensorDataRepository</h1>
<p>A collection of data repositories, holding raw sensor input, input device/provider configurations, sensor channel
configurations, etc. Each data repository keeps certain data-sets isolated and is responsible for
specific type(s) of data.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>sensor_data</code></strong> :&ensp;<code>List[SensorData]</code></dt>
<dd>List of sensor data items. [optional]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SensorDataRepository(ABC):
    &#34;&#34;&#34;
    SensorDataRepository
    ====================
    A collection of data repositories, holding raw sensor input, input device/provider configurations, sensor channel
    configurations, etc. Each data repository keeps certain data-sets isolated and is responsible for
    specific type(s) of data.

    Parameters
    ----------
    sensor_data: List[SensorData]
            List of sensor data items. [optional]
    &#34;&#34;&#34;

    def __init__(self, sensor_data: List[SensorData] = None):
        self.__sensor_data: List[SensorData] = sensor_data or []
        self.__map_id: Dict[uuid.UUID, int] = {}

    @property
    def sensor_data(self) -&gt; List[SensorData]:
        &#34;&#34;&#34;List of SensorData objects. (`List[SensorData]`)&#34;&#34;&#34;
        return self.__sensor_data

    @sensor_data.setter
    def sensor_data(self, sensor_data: list):
        self.__sensor_data = sensor_data
        self.__build_idx_map()

    def add(self, sensor_data: SensorData):
        &#34;&#34;&#34;
        Adding a sensor sample.

        Parameters
        ----------
        sensor_data: `SensorData`
            Adding a sensor data sample
        &#34;&#34;&#34;
        self.__sensor_data.append(sensor_data)
        self.__map_id[sensor_data.id] = len(self.__sensor_data) - 1

    def sensor_data_by_id(self, uimid: uuid.UUID) -&gt; SensorData:
        &#34;&#34;&#34;
        Returns the sensor data samples for a specific id.

        Parameters
        ----------
        uimid: `UUID`
            Id of the sensor data

        Returns
        -------
        instance: `SensorData`
            instance of the sensor data sample

        Raises
        ------
        InkModelException
            If `SensorData` for the id is not available.
        &#34;&#34;&#34;
        if uimid not in self.__map_id:
            raise InkModelException(&#39;No sensor data with id:={}&#39;.format(uimid))
        return self.__sensor_data[self.__map_id[uimid]]

    def __build_idx_map(self):
        &#34;&#34;&#34;Building an index to map the UUID to index in a list.&#34;&#34;&#34;
        self.__map_id = {}
        for idx, el in enumerate(self.sensor_data):
            self.__map_id[el.id] = idx

    def __eq__(self, other):
        if not isinstance(other, SensorDataRepository):
            return False
        map_sensor_data: dict = dict([(s.id, s) for s in other.sensor_data])
        for s in self.sensor_data:
            if s.id not in map_sensor_data:
                return False
            if s == map_sensor_data[s.id]:
                del map_sensor_data[s.id]
            else:
                return False
        return True

    def __repr__(self):
        return &#39;&lt;InputData : [sensor:={}]&gt;&#39;.format(self.__sensor_data)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="uim.model.ink.SensorDataRepository.sensor_data"><code class="name">var <span class="ident">sensor_data</span> :Â List[<a title="uim.model.inkinput.sensordata.SensorData" href="inkinput/sensordata.html#uim.model.inkinput.sensordata.SensorData">SensorData</a>]</code></dt>
<dd>
<div class="desc"><p>List of SensorData objects. (<code>List[SensorData]</code>)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sensor_data(self) -&gt; List[SensorData]:
    &#34;&#34;&#34;List of SensorData objects. (`List[SensorData]`)&#34;&#34;&#34;
    return self.__sensor_data</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="uim.model.ink.SensorDataRepository.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, sensor_data:Â <a title="uim.model.inkinput.sensordata.SensorData" href="inkinput/sensordata.html#uim.model.inkinput.sensordata.SensorData">SensorData</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Adding a sensor sample.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>sensor_data</code></strong> :&ensp;<code>SensorData</code></dt>
<dd>Adding a sensor data sample</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, sensor_data: SensorData):
    &#34;&#34;&#34;
    Adding a sensor sample.

    Parameters
    ----------
    sensor_data: `SensorData`
        Adding a sensor data sample
    &#34;&#34;&#34;
    self.__sensor_data.append(sensor_data)
    self.__map_id[sensor_data.id] = len(self.__sensor_data) - 1</code></pre>
</details>
</dd>
<dt id="uim.model.ink.SensorDataRepository.sensor_data_by_id"><code class="name flex">
<span>def <span class="ident">sensor_data_by_id</span></span>(<span>self, uimid:Â uuid.UUID) â>Â <a title="uim.model.inkinput.sensordata.SensorData" href="inkinput/sensordata.html#uim.model.inkinput.sensordata.SensorData">SensorData</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns the sensor data samples for a specific id.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>uimid</code></strong> :&ensp;<code>UUID</code></dt>
<dd>Id of the sensor data</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>instance</code></strong> :&ensp;<code>SensorData</code></dt>
<dd>instance of the sensor data sample</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>InkModelException</code></dt>
<dd>If <code>SensorData</code> for the id is not available.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sensor_data_by_id(self, uimid: uuid.UUID) -&gt; SensorData:
    &#34;&#34;&#34;
    Returns the sensor data samples for a specific id.

    Parameters
    ----------
    uimid: `UUID`
        Id of the sensor data

    Returns
    -------
    instance: `SensorData`
        instance of the sensor data sample

    Raises
    ------
    InkModelException
        If `SensorData` for the id is not available.
    &#34;&#34;&#34;
    if uimid not in self.__map_id:
        raise InkModelException(&#39;No sensor data with id:={}&#39;.format(uimid))
    return self.__sensor_data[self.__map_id[uimid]]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="uim.model" href="index.html">uim.model</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="uim.model.ink.InkModel" href="#uim.model.ink.InkModel">InkModel</a></code></h4>
<ul class="">
<li><code><a title="uim.model.ink.InkModel.add_property" href="#uim.model.ink.InkModel.add_property">add_property</a></code></li>
<li><code><a title="uim.model.ink.InkModel.add_semantic_triple" href="#uim.model.ink.InkModel.add_semantic_triple">add_semantic_triple</a></code></li>
<li><code><a title="uim.model.ink.InkModel.add_tree" href="#uim.model.ink.InkModel.add_tree">add_tree</a></code></li>
<li><code><a title="uim.model.ink.InkModel.add_view" href="#uim.model.ink.InkModel.add_view">add_view</a></code></li>
<li><code><a title="uim.model.ink.InkModel.brushes" href="#uim.model.ink.InkModel.brushes">brushes</a></code></li>
<li><code><a title="uim.model.ink.InkModel.build_stroke_cache" href="#uim.model.ink.InkModel.build_stroke_cache">build_stroke_cache</a></code></li>
<li><code><a title="uim.model.ink.InkModel.calculate_bounds_recursively" href="#uim.model.ink.InkModel.calculate_bounds_recursively">calculate_bounds_recursively</a></code></li>
<li><code><a title="uim.model.ink.InkModel.clear_knowledge_graph" href="#uim.model.ink.InkModel.clear_knowledge_graph">clear_knowledge_graph</a></code></li>
<li><code><a title="uim.model.ink.InkModel.clear_stroke_cache" href="#uim.model.ink.InkModel.clear_stroke_cache">clear_stroke_cache</a></code></li>
<li><code><a title="uim.model.ink.InkModel.clear_views" href="#uim.model.ink.InkModel.clear_views">clear_views</a></code></li>
<li><code><a title="uim.model.ink.InkModel.clone_stroke_group_node" href="#uim.model.ink.InkModel.clone_stroke_group_node">clone_stroke_group_node</a></code></li>
<li><code><a title="uim.model.ink.InkModel.clone_stroke_node" href="#uim.model.ink.InkModel.clone_stroke_node">clone_stroke_node</a></code></li>
<li><code><a title="uim.model.ink.InkModel.collect_strokes" href="#uim.model.ink.InkModel.collect_strokes">collect_strokes</a></code></li>
<li><code><a title="uim.model.ink.InkModel.default_transform" href="#uim.model.ink.InkModel.default_transform">default_transform</a></code></li>
<li><code><a title="uim.model.ink.InkModel.get_semantic_statement" href="#uim.model.ink.InkModel.get_semantic_statement">get_semantic_statement</a></code></li>
<li><code><a title="uim.model.ink.InkModel.get_stroke_timestamp_and_pressure_values" href="#uim.model.ink.InkModel.get_stroke_timestamp_and_pressure_values">get_stroke_timestamp_and_pressure_values</a></code></li>
<li><code><a title="uim.model.ink.InkModel.get_strokes_as_strided_array" href="#uim.model.ink.InkModel.get_strokes_as_strided_array">get_strokes_as_strided_array</a></code></li>
<li><code><a title="uim.model.ink.InkModel.has_brushes" href="#uim.model.ink.InkModel.has_brushes">has_brushes</a></code></li>
<li><code><a title="uim.model.ink.InkModel.has_ink_data" href="#uim.model.ink.InkModel.has_ink_data">has_ink_data</a></code></li>
<li><code><a title="uim.model.ink.InkModel.has_ink_structure" href="#uim.model.ink.InkModel.has_ink_structure">has_ink_structure</a></code></li>
<li><code><a title="uim.model.ink.InkModel.has_input_data" href="#uim.model.ink.InkModel.has_input_data">has_input_data</a></code></li>
<li><code><a title="uim.model.ink.InkModel.has_knowledge_graph" href="#uim.model.ink.InkModel.has_knowledge_graph">has_knowledge_graph</a></code></li>
<li><code><a title="uim.model.ink.InkModel.has_properties" href="#uim.model.ink.InkModel.has_properties">has_properties</a></code></li>
<li><code><a title="uim.model.ink.InkModel.has_tree" href="#uim.model.ink.InkModel.has_tree">has_tree</a></code></li>
<li><code><a title="uim.model.ink.InkModel.ink_tree" href="#uim.model.ink.InkModel.ink_tree">ink_tree</a></code></li>
<li><code><a title="uim.model.ink.InkModel.input_configuration" href="#uim.model.ink.InkModel.input_configuration">input_configuration</a></code></li>
<li><code><a title="uim.model.ink.InkModel.is_node_registered" href="#uim.model.ink.InkModel.is_node_registered">is_node_registered</a></code></li>
<li><code><a title="uim.model.ink.InkModel.knowledge_graph" href="#uim.model.ink.InkModel.knowledge_graph">knowledge_graph</a></code></li>
<li><code><a title="uim.model.ink.InkModel.properties" href="#uim.model.ink.InkModel.properties">properties</a></code></li>
<li><code><a title="uim.model.ink.InkModel.register_node" href="#uim.model.ink.InkModel.register_node">register_node</a></code></li>
<li><code><a title="uim.model.ink.InkModel.remove_node" href="#uim.model.ink.InkModel.remove_node">remove_node</a></code></li>
<li><code><a title="uim.model.ink.InkModel.remove_semantic_triple" href="#uim.model.ink.InkModel.remove_semantic_triple">remove_semantic_triple</a></code></li>
<li><code><a title="uim.model.ink.InkModel.remove_tree" href="#uim.model.ink.InkModel.remove_tree">remove_tree</a></code></li>
<li><code><a title="uim.model.ink.InkModel.sensor_data" href="#uim.model.ink.InkModel.sensor_data">sensor_data</a></code></li>
<li><code><a title="uim.model.ink.InkModel.sensor_data_lookup" href="#uim.model.ink.InkModel.sensor_data_lookup">sensor_data_lookup</a></code></li>
<li><code><a title="uim.model.ink.InkModel.stroke_by_id" href="#uim.model.ink.InkModel.stroke_by_id">stroke_by_id</a></code></li>
<li><code><a title="uim.model.ink.InkModel.strokes" href="#uim.model.ink.InkModel.strokes">strokes</a></code></li>
<li><code><a title="uim.model.ink.InkModel.transform" href="#uim.model.ink.InkModel.transform">transform</a></code></li>
<li><code><a title="uim.model.ink.InkModel.tree" href="#uim.model.ink.InkModel.tree">tree</a></code></li>
<li><code><a title="uim.model.ink.InkModel.unit_scale_factor" href="#uim.model.ink.InkModel.unit_scale_factor">unit_scale_factor</a></code></li>
<li><code><a title="uim.model.ink.InkModel.unregister_node" href="#uim.model.ink.InkModel.unregister_node">unregister_node</a></code></li>
<li><code><a title="uim.model.ink.InkModel.version" href="#uim.model.ink.InkModel.version">version</a></code></li>
<li><code><a title="uim.model.ink.InkModel.view" href="#uim.model.ink.InkModel.view">view</a></code></li>
<li><code><a title="uim.model.ink.InkModel.view_root" href="#uim.model.ink.InkModel.view_root">view_root</a></code></li>
<li><code><a title="uim.model.ink.InkModel.views" href="#uim.model.ink.InkModel.views">views</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="uim.model.ink.InkTree" href="#uim.model.ink.InkTree">InkTree</a></code></h4>
<ul class="two-column">
<li><code><a title="uim.model.ink.InkTree.model" href="#uim.model.ink.InkTree.model">model</a></code></li>
<li><code><a title="uim.model.ink.InkTree.name" href="#uim.model.ink.InkTree.name">name</a></code></li>
<li><code><a title="uim.model.ink.InkTree.register_node" href="#uim.model.ink.InkTree.register_node">register_node</a></code></li>
<li><code><a title="uim.model.ink.InkTree.register_sub_tree" href="#uim.model.ink.InkTree.register_sub_tree">register_sub_tree</a></code></li>
<li><code><a title="uim.model.ink.InkTree.root" href="#uim.model.ink.InkTree.root">root</a></code></li>
<li><code><a title="uim.model.ink.InkTree.unregister_node" href="#uim.model.ink.InkTree.unregister_node">unregister_node</a></code></li>
<li><code><a title="uim.model.ink.InkTree.unregister_sub_tree" href="#uim.model.ink.InkTree.unregister_sub_tree">unregister_sub_tree</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="uim.model.ink.SensorDataRepository" href="#uim.model.ink.SensorDataRepository">SensorDataRepository</a></code></h4>
<ul class="">
<li><code><a title="uim.model.ink.SensorDataRepository.add" href="#uim.model.ink.SensorDataRepository.add">add</a></code></li>
<li><code><a title="uim.model.ink.SensorDataRepository.sensor_data" href="#uim.model.ink.SensorDataRepository.sensor_data">sensor_data</a></code></li>
<li><code><a title="uim.model.ink.SensorDataRepository.sensor_data_by_id" href="#uim.model.ink.SensorDataRepository.sensor_data_by_id">sensor_data_by_id</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>