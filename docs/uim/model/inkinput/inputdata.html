<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>uim.model.inkinput.inputdata API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>uim.model.inkinput.inputdata</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
# Copyright Â© 2021 Wacom Authors. All Rights Reserved.
#
#  Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
import uuid
from abc import ABC
from enum import Enum
from typing import List, Tuple, Any

import numpy as np

import uim.codec.format.UIM_3_0_0_pb2 as uim
from uim.model.base import HashIdentifier, Identifier, UUIDIdentifier, InkModelException


class DataType(Enum):
    &#34;&#34;&#34;Data types for channels.&#34;&#34;&#34;
    BOOLEAN = 0
    FLOAT32 = 1
    FLOAT64 = 2
    INT32 = 3
    INT64 = 4
    UINT32 = 5
    UINT64 = 6


class InkInputType(Enum):
    &#34;&#34;&#34;
    Defining the different types of input data.
    &#34;&#34;&#34;
    PEN = uim.PEN
    &#34;&#34;&#34;Stylus, smart pens, pen displays, signature capturing input data, ...&#34;&#34;&#34;
    TOUCH = uim.TOUCH
    &#34;&#34;&#34;Touch controller input data: Finger or passive stylus.&#34;&#34;&#34;
    MOUSE = uim.MOUSE
    &#34;&#34;&#34;Mouse input data.&#34;&#34;&#34;
    CONTROLLER = uim.CONTROLLER
    &#34;&#34;&#34;3-DOF or 6-DOF input data devices.&#34;&#34;&#34;


class InkSensorMetricType(Enum):
    &#34;&#34;&#34;Metric for the channel.&#34;&#34;&#34;
    LENGTH = uim.LENGTH
    &#34;&#34;&#34;Length; underling si unit is meter&#34;&#34;&#34;
    TIME = uim.TIME
    &#34;&#34;&#34;Time; underling  si unit is second&#34;&#34;&#34;
    FORCE = uim.FORCE
    &#34;&#34;&#34;Force; underling si unit is newton&#34;&#34;&#34;
    ANGLE = uim.ANGLE
    &#34;&#34;&#34;Angle; underling si unit is radian&#34;&#34;&#34;
    NORMALIZED = uim.NORMALIZED
    &#34;&#34;&#34;Normalized; percentage, expressed as a fraction(1.0 = 100 %) relative to max - min&#34;&#34;&#34;


class Unit(Enum):
    # Lengths units
    UNDEFINED = 0
    &#34;&#34;&#34;Undefined unit&#34;&#34;&#34;
    M = 10
    &#34;&#34;&#34;meters&#34;&#34;&#34;
    CM = 11
    &#34;&#34;&#34;centimeters&#34;&#34;&#34;
    MM = 12
    &#34;&#34;&#34;millimeters&#34;&#34;&#34;
    IN = 13
    &#34;&#34;&#34;inches&#34;&#34;&#34;
    PT = 14
    &#34;&#34;&#34;points (1pt = 1/72 in)&#34;&#34;&#34;
    PC = 15
    &#34;&#34;&#34;picas (1pc = 1/22 pt)&#34;&#34;&#34;
    DIP = 16
    &#34;&#34;&#34;device independent pixel (1DIP = 1/96 in)&#34;&#34;&#34;
    # Time units
    S = 20
    &#34;&#34;&#34;seconds&#34;&#34;&#34;
    MS = 21
    &#34;&#34;&#34;milliseconds&#34;&#34;&#34;
    NS = 22
    &#34;&#34;&#34;nanoseconds&#34;&#34;&#34;
    # Force units
    N = 30
    &#34;&#34;&#34;Newtons&#34;&#34;&#34;
    # Angle
    RAD = 42
    &#34;&#34;&#34;radians&#34;&#34;&#34;
    DEG = 41
    &#34;&#34;&#34;degrees&#34;&#34;&#34;
    # General
    PERCENTAGE = 50
    &#34;&#34;&#34;percentage, expressed as a fraction (1.0 = 100%) relative to max-min&#34;&#34;&#34;
    LOGICAL_VALUE = 60
    &#34;&#34;&#34;logical value&#34;&#34;&#34;


# --------------------------------- Conversion values ------------------------------------------------------------------

CONVERSION_SCALAR = {
    # Length units
    Unit.M: {
        Unit.M: 1.,
        Unit.CM: 100,
        Unit.MM: 1000,
        Unit.IN: 39.3701,
        Unit.PT: 2834.65,
        Unit.PC: 236.222,
        Unit.DIP: (39.3701 * 96.)
    },
    Unit.CM: {
        Unit.M: 0.01,
        Unit.CM: 1.,
        Unit.MM: 10.,
        Unit.IN: 0.393701,
        Unit.PT: 28.3465,
        Unit.PC: 2.36222,
        Unit.DIP: (0.393701 * 96.)
    },
    Unit.MM: {
        Unit.M: 0.001,
        Unit.CM: 0.1,
        Unit.MM: 1.,
        Unit.IN: 0.0393701,
        Unit.PT: 2.83465,
        Unit.PC: 0.236222,
        Unit.DIP: (0.0393701 * 96.)
    },
    Unit.IN: {
        Unit.M: 0.0254,
        Unit.CM: 2.54,
        Unit.MM: 25.4,
        Unit.IN: 1.,
        Unit.PT: 72,
        Unit.PC: 6.,
        Unit.DIP: (1. * 96.)
    },
    Unit.PT: {
        Unit.M: 0.000352778,
        Unit.CM: 0.0352778,
        Unit.MM: 0.352778,
        Unit.IN: 0.0138888889,
        Unit.PT: 1.,
        Unit.PC: 0.08333333,
        Unit.DIP: (0.0138888889 * 96.)
    },
    Unit.PC: {
        Unit.M: 0.0042333333,
        Unit.CM: 0.4233333333,
        Unit.MM: 4.2333333333,
        Unit.IN: 0.166665,
        Unit.PT: 12.,
        Unit.PC: 1.,
        Unit.DIP: (0.166665 * 96.)
    },
    Unit.DIP: {
        Unit.M: (0.0254 / 96.),
        Unit.CM: (2.54 / 96.),
        Unit.MM: (25.4 / 96.),
        Unit.IN: (1. / 96.),
        Unit.PT: (72 / 96.),
        Unit.PC: (6. / 96.),
        Unit.DIP: 1.
    },
    # Time unit
    Unit.S: {
        Unit.S: 1.,
        Unit.MS: 1000.,
        Unit.NS: 1000000000.
    },
    Unit.MS: {
        Unit.S: 0.001,
        Unit.MS: 1.,
        Unit.NS: 1000000.
    },
    Unit.NS: {
        Unit.S: 0.000000001,
        Unit.MS: 0.000001,
        Unit.NS: 1.
    }
}
&#34;&#34;&#34;Mapping containing the factors to convert from one unit: &lt;source-unit&gt; into the other: &lt;target-unit&gt;.&#34;&#34;&#34;


class InkSensorType(Enum):
    &#34;&#34;&#34;
        Pre-defined SensorData types.
    &#34;&#34;&#34;

    X = &#39;will://input/3.0/channel/X&#39;
    &#34;&#34;&#34;X coordinate. This is the horizontal pen position on the writing surface.&#34;&#34;&#34;
    Y = &#39;will://input/3.0/channel/Y&#39;
    &#34;&#34;&#34;Y coordinate. This is the vertical position on the writing surface. &#34;&#34;&#34;
    Z = &#39;will://input/3.0/channel/Z&#39;
    &#34;&#34;&#34;Z coordinate. This is the height of pen above the writing surface.&#34;&#34;&#34;
    TIMESTAMP = &#39;will://input/3.0/channel/Timestamp&#39;
    &#34;&#34;&#34;Time (of the sample point)&#34;&#34;&#34;
    PRESSURE = &#39;will://input/3.0/channel/Pressure&#39;
    &#34;&#34;&#34;Input pressure.&#34;&#34;&#34;
    RADIUS_X = &#39;will://input/3.0/channel/RadiusX&#39;
    &#34;&#34;&#34;Touch radius by X&#34;&#34;&#34;
    RADIUS_Y = &#39;will://input/3.0/channel/RadiusY&#39;
    &#34;&#34;&#34;Touch radius by Y&#34;&#34;&#34;
    AZIMUTH = &#39;will://input/3.0/channel/Azimuth&#39;
    &#34;&#34;&#34;Azimuth angle of the pen (yaw)&#34;&#34;&#34;
    ALTITUDE = &#39;will://input/3.0/channel/Altitude&#39;
    &#34;&#34;&#34;Elevation angle of the pen (pitch)&#34;&#34;&#34;
    ROTATION = &#39;will://input/3.0/channel/Rotation&#39;
    &#34;&#34;&#34;Rotation (counter-clockwise rotation about pen axis)&#34;&#34;&#34;


# --------------------------------- Token mapping ----------------------------------------------------------------------


TOKEN_MAP: dict = {
    InkInputType.PEN: InkInputType.PEN.name,
    InkInputType.MOUSE: InkInputType.MOUSE.name,
    InkInputType.TOUCH: InkInputType.TOUCH.name,
    InkInputType.CONTROLLER: InkInputType.CONTROLLER.name,
    InkSensorMetricType.TIME: InkSensorMetricType.TIME.name,
    InkSensorMetricType.LENGTH: InkSensorMetricType.LENGTH.name,
    InkSensorMetricType.FORCE: InkSensorMetricType.FORCE.name,
    InkSensorMetricType.ANGLE: InkSensorMetricType.ANGLE.name,
    InkSensorMetricType.NORMALIZED: InkSensorMetricType.NORMALIZED.name,
    InkSensorType.X: InkSensorType.X.value,
    InkSensorType.Y: InkSensorType.Y.value,
    InkSensorType.Z: InkSensorType.Z.value,
    InkSensorType.TIMESTAMP: InkSensorType.TIMESTAMP.value,
    InkSensorType.PRESSURE: InkSensorType.PRESSURE.value,
    InkSensorType.RADIUS_X: InkSensorType.RADIUS_X.value,
    InkSensorType.RADIUS_Y: InkSensorType.RADIUS_Y.value,
    InkSensorType.AZIMUTH: InkSensorType.AZIMUTH.value,
    InkSensorType.ALTITUDE: InkSensorType.ALTITUDE.value,
    InkSensorType.ROTATION: InkSensorType.ROTATION.value
}

# --------------------------------- Conversion functions ---------------------------------------------------------------


def virtual_resolution_for_si_unit(source_unit: Unit) -&gt; float:
    &#34;&#34;&#34;
    Calculate a virtual resolution for source unit.

    Parameters
    ----------
    source_unit: unit
        Source unit
    Returns
    -------
    resolution: `float`
        Virtual resolution
    &#34;&#34;&#34;
    si: Unit = si_unit(source_unit)
    if si == Unit.UNDEFINED:
        return 1.
    return 1. / CONVERSION_SCALAR[source_unit][si]


def si_unit(unit_type: Unit) -&gt; Unit:
    &#34;&#34;&#34;
    Return the SI unit for a specific unit type.

    Parameters
    ----------
    unit_type: `Unit`
        Unit

    Returns
    -------
    si_unit: Unit
        SI unit for a unit, e.g., for a lengths unit cm the SI unit is m.
    &#34;&#34;&#34;
    # SI unit for length is m
    if unit_type in [Unit.M, Unit.CM, Unit.MM, Unit.IN, Unit.PT, Unit.PC, Unit.DIP]:
        return Unit.M
    # SI unit for time is s
    if unit_type in [Unit.S, Unit.MS, Unit.NS]:
        return Unit.S
    return Unit.UNDEFINED


def unit2unit(source_unit: Unit, target_unit: Unit, value: float) -&gt; float:
    &#34;&#34;&#34;
    Convert value with a source unit to the target unit.

    Parameters
    ----------
    source_unit: Unit
        Source unit
    target_unit: Unit
        Target unit
    value: float
        Value in source unit

    Returns
    -------
    value: `float`
        value converted to target unit

    Raises
    ------
    ValueError:
        Unit is not supported
    &#34;&#34;&#34;
    if source_unit == Unit.UNDEFINED or target_unit == Unit.UNDEFINED:
        return value
    if source_unit not in CONVERSION_SCALAR:
        raise ValueError(&#39;Source unit not supported. Unit:={}&#39;.format(source_unit))
    if target_unit not in CONVERSION_SCALAR[source_unit]:
        raise ValueError(&#39;Target unit not supported. Unit:={}&#39;.format(target_unit))
    return CONVERSION_SCALAR[source_unit][target_unit] * value


def unit2unit_matrix(source_unit: Unit, target_unit: Unit) -&gt; np.array:
    &#34;&#34;&#34;
    Matrix for unit 2 unit conversion.

    Parameters
    ----------
    source_unit: Unit
        Source unit
    target_unit: Unit
        Target unit

    Returns
    -------
        matrix: `np.array`
            matrix for conversion
    &#34;&#34;&#34;
    matrix: np.array = np.identity(3)
    if source_unit == Unit.UNDEFINED or target_unit == Unit.UNDEFINED:
        return matrix
    if source_unit not in CONVERSION_SCALAR:
        raise ValueError(&#39;Source unit not supported.&#39;)
    if target_unit not in CONVERSION_SCALAR[source_unit]:
        raise ValueError(&#39;Target unit not supported.&#39;)
    matrix[0, 0] = CONVERSION_SCALAR[source_unit][target_unit]
    matrix[1, 1] = CONVERSION_SCALAR[source_unit][target_unit]
    return matrix


# --------------------------------- Data context --------------------------------------------------------------------


class InputDevice(HashIdentifier):
    &#34;&#34;&#34;
    InputDevice
    ===========
    The class `InputDevice` represents the hardware device, on which the sensor data has been produced
    (touch enabled mobile device, touch capable monitor, digitizer, etc).
    InputDevice with properties.

    The properties can contain:

      - Communication Protocol: USB, BTC, BLE, SPP, WIFI,
      - Communication ID: VID, PID; MAC; UID; COM_PORT,
      - Device Name: Wacom Intuos Pro M, Apple iPad 8, Samsung GalaxyTab 10,
      - PenID,
      - Serial number,
      - Firmware Version (MCU),
      - Secondary Firmware Version (BT, WIFI) - different modules provides version for itself,
      - Orientation: PORTRAIT, LANDSCAPE, PORTRAIT_REVERSE, LANDSCAPE_REVERSE or 0, 90, 180, 270,
      - Sensor size.

    Parameters
    ----------
    device_id: `UUID`
        Internal input device id
    properties: List[Tuple[str, str]]
        Properties of the input device

    Examples
    --------
    &gt;&gt;&gt; from uim.model.inkinput.inputdata import InputDevice
    &gt;&gt;&gt; # Input device is the sensor (pen tablet, screen, etc.)
    &gt;&gt;&gt; input_device: InputDevice = InputDevice()
    &gt;&gt;&gt; input_device.properties.append((&#34;dev.id&#34;, &#34;123454321&#34;))
    &gt;&gt;&gt; input_device.properties.append((&#34;dev.manufacturer&#34;, &#34;Wacom&#34;))
    &gt;&gt;&gt; input_device.properties.append((&#34;dev.model&#34;, &#34;Mobile Studio Pro&#34;))
    &gt;&gt;&gt; input_device.properties.append((&#34;dev.cpu&#34;, &#34;Intel&#34;))
    &gt;&gt;&gt; input_device.properties.append((&#34;dev.graphics.display&#34;, &#34;Dell 1920x1080 32bit&#34;))
    &gt;&gt;&gt; input_device.properties.append((&#34;dev.graphics.adapter&#34;, &#34;NVidia&#34;))
    &#34;&#34;&#34;

    def __init__(self, device_id: uuid.UUID = None, properties: List[Tuple[str, str]] = None):
        super().__init__(device_id)
        self.__properties: List[Tuple[str, str]] = properties or []

    @property
    def properties(self) -&gt; List[Tuple[str, str]]:
        &#34;&#34;&#34;Properties of the InputDevice. (` List[Tuple[str, str]]`, read-only)&#34;&#34;&#34;
        return self.__properties

    def add_property(self, key: str, value):
        &#34;&#34;&#34;Adding property.

        Parameters
        ----------
        key: str
            Name of the property
        value: str
            Value of the property
        &#34;&#34;&#34;
        self.__properties.append((key, value))

    def __tokenize__(self):
        return [&#39;InputDevice&#39;, self.properties]

    def __repr__(self):
        return &#39;&lt;InputDevice : [id:={}, num properties:={}&gt;&#39;.format(self.id, self.properties)


class InputContext(HashIdentifier):
    &#34;&#34;&#34;
    InputContext
    ============
    Capturing context of the uim input data with reference to the Environment and the SensorContext.

    Parameters
    ----------
    ctx_id: `UUID`
        Internal id
    environment_id: `UUID`
        Reference to environment
    sensor_context_id: `UUID`
        Rendering to sensor context
    &#34;&#34;&#34;

    def __init__(self, ctx_id: uuid.UUID = None, environment_id: uuid.UUID = None, sensor_context_id: uuid.UUID = None):
        super().__init__(ctx_id)
        self.__environment_id = environment_id
        self.__sensor_context_id = sensor_context_id

    def __tokenize__(self) -&gt; list:
        return [&#34;InputContext&#34;, self.environment_id, self.sensor_context_id]

    @property
    def environment_id(self) -&gt; uuid.UUID:
        &#34;&#34;&#34;Reference to environment. (`UUID`, read-only)&#34;&#34;&#34;
        return self.__environment_id

    @property
    def sensor_context_id(self) -&gt; uuid.UUID:
        &#34;&#34;&#34;Reference for sensor context. (`UUID`, read-only)&#34;&#34;&#34;
        return self.__sensor_context_id

    def __repr__(self):
        env_id: str = Identifier.uimid_to_s_form(self.environment_id)
        sc_id: str = Identifier.uimid_to_s_form(self.sensor_context_id)
        return &#39;&lt;InputContext : [id:={}, environment id:={}, sensor context id:={}&gt;&#39;.format(self.id_h_form,
                                                                                            env_id, sc_id)


class Environment(HashIdentifier):
    &#34;&#34;&#34;
    Environment
    ===========
    The class `Environment` represents for the virtual environment in which the sensor data has been produced, e.g,:

        - os.name - Name of the operating system
        - os.version.name - Name of the version
        - os.version.release - Release build number
        - wacom.ink.sdk.name - Name of the Wacom Ink technology
        - wacom.ink.sdk.version - Version number of the SDK

    Parameters
    ----------
    env_id: `UUID`
        Internal environment UUID
    properties: List[Tuple[str, str]]
        Properties of the environment

    Examples
    --------
    &gt;&gt;&gt; from uim.model.inkinput.inputdata import Environment
    &gt;&gt;&gt; # Create an environment
    &gt;&gt;&gt; env: Environment = Environment()
    &gt;&gt;&gt; env.properties.append((&#34;env.name&#34;, &#34;My Environment&#34;))
    &gt;&gt;&gt; env.properties.append((&#34;os.id&#34;, &#34;98765&#34;))
    &gt;&gt;&gt; env.properties.append((&#34;os.name&#34;, &#34;Windows&#34;))
    &gt;&gt;&gt; env.properties.append((&#34;os.version&#34;, &#34;10.0.18362.239&#34;))
    &gt;&gt;&gt; env.properties.append((&#34;os.build&#34;, &#34;239&#34;))
    &gt;&gt;&gt; env.properties.append((&#34;os.platform&#34;, &#34;whatever&#34;))
    &#34;&#34;&#34;

    def __init__(self, env_id: uuid.UUID = None, properties: List[Tuple[str, str]] = None):
        super().__init__(env_id)
        self.__properties = properties or []

    def __tokenize__(self) -&gt; List[Any]:
        token: List[Any] = [&#39;Environment&#39;, self.properties]
        return token

    @property
    def properties(self) -&gt; List[Tuple[str, str]]:
        &#34;&#34;&#34;Environment properties. (`List[Tuple[str, str]]`, read-only) &#34;&#34;&#34;
        return self.__properties

    def add_environment_property(self, key: str, value: str):
        &#34;&#34;&#34;
        Adding a property for environment.

        Parameters
        ----------
        key: str
            Name of the property
        value: str
            Value of the property
        &#34;&#34;&#34;
        self.properties.append((key, value))

    def __repr__(self):
        return &#39;&lt;Environment: [id:={}, #properties:={}&gt;&#39;.format(self.id.hex, self.properties)


class InkInputProvider(HashIdentifier):
    &#34;&#34;&#34;
    InkInputProvider
    ================
    The class InkInputProvider stands for the generic input data source - it identifies how the data has been generated
    (using touch input, mouse, stylus, hardware controller, etc).

    The properties which can be used to describe the InkInputProvider:

        - pen.type - Type of the pen device

    Parameters
    ----------
    provider_id: UUID
        internal id or input data name.
    input_type: InkInputType -
        type of used hardware - PEN, TOUCH, MOUSE, or CONTROLLER.
    properties: List[Tuple[str, str]] -
        Properties assigned to ink input provider

    Examples
    --------
    &gt;&gt;&gt; from uim.model.inkinput.inputdata import InkInputProvider
    &gt;&gt;&gt; # Ink input provider can be pen, mouse or touch.
    &gt;&gt;&gt; provider: InkInputProvider = InkInputProvider(input_type=InkInputType.MOUSE)
    &gt;&gt;&gt; provider.properties.append((&#34;pen.id&#34;, &#34;1234567&#34;))
    &#34;&#34;&#34;

    def __init__(self, provider_id: uuid.UUID = None, input_type: InkInputType = None,
                 properties: List[Tuple[str, str]] = None):
        super().__init__(provider_id)
        self.__type: InkInputType = input_type
        self.__properties: List[Tuple[str, str]] = properties or []

    def __tokenize__(self):
        return [&#39;InkInputProvider&#39;, TOKEN_MAP[self.type], self.properties]

    @property
    def type(self) -&gt; InkInputType:
        &#34;&#34;&#34;Input provider type. (`InkInputType`,  read-only)&#34;&#34;&#34;
        return self.__type

    @property
    def properties(self) -&gt; List[Tuple[str, str]]:
        &#34;&#34;&#34;Properties of input data provider. (`List[Tuple[str, str]]`, read-only)&#34;&#34;&#34;
        return self.__properties

    def __repr__(self):
        return &#39;&lt;InkInputProvider: [id:={}, type:={}, properties:={}]&gt;&#39;.format(self.id, self.type, self.properties)


class SensorChannel(HashIdentifier):
    &#34;&#34;&#34;
    SensorChannel
    =============
    The `SensorChannel` represents a generic sensor channel definition, which has the following properties:

    - **type** - URI uniquely identifying the type of the sensor channel
    - **metric** - The type of the data to the SI metric system
    - **resolution** - A factor multiplication value (power of 10) used to convert the stored data values to the
                      specified SI metric
    - **min, max** - Lower and upper bounds of the reported values range
    - **precision** - The precision of the sensor when reporting floating-point values (defined as an int value,
                      used as a power of 10 during the serialization/deserialization phase)
    
    Parameters
    ----------
    channel_id: `UUID`
        Sensor channel descriptor. If no channel_id is set the MD5 hashing is generating the id
    channel_type:`InkSensorType`
        Indicates metric used in calculating the resolution for the data item.
    metric: `InkSensorMetricType`
        Indicates metric used in calculating the resolution for the data item.
    resolution: `float`
        Is a decimal number giving the number of data item increments. Per physical unit., e.g. if the
        physical unit is in m and input data units. Resolution is 100000, then the value 150 would be
        0.0015 m.
    channel_min: `float`
        Minimal value of the channel
    channel_max: `float`
        Maximal value of the channel
    precision: `int`
        Precision of integer encoding, needed for encoded float values
    index: `int`
        Index of the channel
    name: `str`
        Name of the channel
    data_type: `DataType`
        Type of data within the channel
    ink_input_provider_id: `UUID`
        Reference to the ink input provider
    input_device_id: `UUID`
        Reference to the ink input device

    Examples
    --------
    &gt;&gt;&gt; from uim.model.inkinput.inputdata import SensorChannel, InkSensorType
    &gt;&gt;&gt; # Create a group of sensor channels
    &gt;&gt;&gt; sensor_channels_tablet: list = [
    &gt;&gt;&gt;     SensorChannel(channel_type=InkSensorType.TIMESTAMP, metric=InkSensorMetricType.TIME, resolution=1.0),
    &gt;&gt;&gt;     SensorChannel(channel_type=InkSensorType.X, metric=InkSensorMetricType.LENGTH, resolution=1.0),
    &gt;&gt;&gt;     SensorChannel(channel_type=InkSensorType.Y, metric=InkSensorMetricType.LENGTH, resolution=1.0)
    &gt;&gt;&gt; ]
    &#34;&#34;&#34;

    def __init__(self, channel_id: uuid.UUID = None,
                 channel_type: InkSensorType = None, metric: InkSensorMetricType = None,
                 resolution: float = 1., channel_min: float = 0., channel_max: float = 0.,
                 precision: int = 2, index: int = 0, name: str = None, data_type: DataType = DataType.FLOAT32,
                 ink_input_provider_id: uuid.UUID = None, input_device_id: uuid.UUID = None):
        super().__init__(channel_id)
        self.__type: InkSensorType = channel_type
        self.__metric: InkSensorMetricType = metric
        self.__resolution: float = float(resolution)
        self.__min: float = float(channel_min)
        self.__max: float = float(channel_max)
        self.__precision: int = precision
        self.__index: int = index
        self.__name: str = name
        self.__data_type: DataType = data_type
        self.__ink_input_provider: uuid.UUID = ink_input_provider_id
        self.__input_device_id: uuid.UUID = input_device_id

    def __tokenize__(self) -&gt; list:
        return [&#34;SensorChannel&#34;, self.__ink_input_provider, self.__input_device_id, TOKEN_MAP[self.type],
                TOKEN_MAP[self.metric], self.resolution, self.min, self.max, self.precision]

    @property
    def ink_input_provider(self) -&gt; uuid.UUID:
        &#34;&#34;&#34;Reference to the `InkInputProvider` of the channel. (`UUID`)&#34;&#34;&#34;
        return self.__ink_input_provider

    @ink_input_provider.setter
    def ink_input_provider(self, value: uuid.UUID):
        self.__ink_input_provider = value

    @property
    def input_device_id(self) -&gt; uuid.UUID:
        &#34;&#34;&#34;Reference to the `InputDevice` of the channel. (`UUID`)&#34;&#34;&#34;
        return self.__input_device_id

    @input_device_id.setter
    def input_device_id(self, value: uuid.UUID):
        self.__input_device_id = value

    @property
    def type(self) -&gt; InkSensorType:
        &#34;&#34;&#34;Type of the sensor channel.(`InkSensorType`, read-only) &#34;&#34;&#34;
        return self.__type

    @property
    def metric(self) -&gt; InkSensorMetricType:
        &#34;&#34;&#34;Metric of the sensor channel. (`InkSensorMetricType`)&#34;&#34;&#34;
        return self.__metric

    @property
    def resolution(self) -&gt; float:
        &#34;&#34;&#34;Resolution. Is a decimal number giving the number of data item increments. Per physical unit., e.g. if the
        physical unit is in m and input data units. (`float`, read-only)&#34;&#34;&#34;
        return self.__resolution

    @property
    def min(self) -&gt; float:
        &#34;&#34;&#34;Minimal value of the channel. (`float`, read-only)&#34;&#34;&#34;
        return self.__min

    @property
    def max(self) -&gt; float:
        &#34;&#34;&#34;Maximum value of the channel. (`float`, read-only)&#34;&#34;&#34;
        return self.__max

    @property
    def precision(self) -&gt; int:
        &#34;&#34;&#34;Precision of integer encoding, needed for encoded float values. (`int`, read-only)&#34;&#34;&#34;
        return self.__precision

    @property
    def index(self) -&gt; int:
        &#34;&#34;&#34;Index within a list of values, e.g. used in InkML encoding. (`int`, read-only)&#34;&#34;&#34;
        return self.__index

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;Name of the channel. (`str`, read-only)&#34;&#34;&#34;
        return self.__name

    @property
    def data_type(self) -&gt; DataType:
        &#34;&#34;&#34; Data type encoding. (`DataType`, read-only)&#34;&#34;&#34;
        return self.__data_type

    def __repr__(self):
        return &#39;&lt;SensorChannel: [id:={}, type:={}, metric:={}, resolution:={}, min:={}, max:={}, &#39; \
               &#39;precision:={}, index:={}, name:={}&gt;&#39;.format(self.id.hex, self.__type, self.__metric, self.__resolution,
                                                            self.__min, self.__max, self.__precision, self.__index,
                                                            self.__name)


class SensorChannelsContext(HashIdentifier):
    &#34;&#34;&#34;
    SensorChannelsContext
    =====================

    The class `SensorChannelsContext` is defined as an unique combination of:
    
        - An `InkInputProvider` instance
        - An `InputDevice` instance and
        - A list of sensor channel definitions (by holding a collection of `SensorChannel` instances)
        
    Parameters
    ----------
    sid: `str`
        Group that provides X and Y channels is the one that is referred from StrokeRelation and it&#39;s id could be
        always XY.
    channels: `List[SensorChannel]`
        A list of sensor channel descriptors.
    sampling_rate_hint: `int`
        Optional hint for the intended sampling rate of the sensor.[Optional].
    latency: `int`
        Latency measure in milliseconds [Optional].
    ink_input_provider_id: `str`
        Reference to the &#39;InkInputProvider`.
    input_device_id: `str`
        Reference to the `InputDevice`.

    Notes
    ------
    Once a SensorChannelsContext instance is added to the InputContext repository, it is considered immutable.
    The SensorChannelsContext identifier is unique in the scope of the InkModel and is auto-generated based on the
    MD5-hash based Unique Identifier Generation Algorithm using tag &#34;SensorChannelsContext&#34; and the
    following components:

        - Identifier of the InkInputProvider instance
        - Identifier of the InputDevice instance
        - List of the identifiers of the SensorChannel instances contained within the current SensorChannelsContext

    Examples
    --------
    &gt;&gt;&gt; from uim.model.inkinput.inputdata import InkInputProvider, InkInputType, SensorChannel, \
    &gt;&gt;&gt;       InkSensorType, InkSensorMetricType, SensorChannelsContext, SensorContext
    &gt;&gt;&gt; # Ink input provider can be pen, mouse or touch.
    &gt;&gt;&gt; provider: InkInputProvider = InkInputProvider(input_type=InkInputType.MOUSE)
    &gt;&gt;&gt; provider.properties.append((&#34;pen.id&#34;, &#34;1234567&#34;))
    &gt;&gt;&gt;
    &gt;&gt;&gt; # We can create an additional input device, for example one providing pressure via Bluetooth
    &gt;&gt;&gt; input_device: InputDevice = InputDevice()
    &gt;&gt;&gt; input_device.properties.append((&#34;dev.id&#34;, &#34;345456567&#34;))
    &gt;&gt;&gt; input_device.properties.append((&#34;dev.manufacturer&#34;, &#34;Apple&#34;))
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Create a group of sensor channels
    &gt;&gt;&gt; sensor_channels_tablet: list = [
    &gt;&gt;&gt;     SensorChannel(channel_type=InkSensorType.TIMESTAMP, metric=InkSensorMetricType.TIME, resolution=1.0),
    &gt;&gt;&gt;     SensorChannel(channel_type=InkSensorType.X, metric=InkSensorMetricType.LENGTH, resolution=1.0),
    &gt;&gt;&gt;     SensorChannel(channel_type=InkSensorType.Y, metric=InkSensorMetricType.LENGTH, resolution=1.0)
    &gt;&gt;&gt; ]
    &gt;&gt;&gt;
    &gt;&gt;&gt; scc_tablet: SensorChannelsContext = SensorChannelsContext(channels=sensor_channels_tablet,
    &gt;&gt;&gt;                                                           ink_input_provider_id=provider.id,
    &gt;&gt;&gt;                                                           input_device_id=input_device.id)
    &#34;&#34;&#34;

    def __init__(self, sid: uuid.UUID = None, channels: List[SensorChannel] = None, sampling_rate_hint: int = None,
                 latency: int = None, ink_input_provider_id: uuid.UUID = None, input_device_id: uuid.UUID = None):
        super().__init__(sid)
        self.__channels: List[SensorChannel] = channels or []
        self.__sampling_rate_hint: int = sampling_rate_hint
        self.__latency: int = latency
        self.__ink_input_provider_id: uuid.UUID = ink_input_provider_id
        self.__input_device_id: uuid.UUID = input_device_id
        # Set bind channels to input provider and input device
        for c in self.__channels:
            c.ink_input_provider = ink_input_provider_id
            c.input_device_id = input_device_id

    def __tokenize__(self) -&gt; list:
        token: list = [&#34;SensorChannelsContext&#34;]
        token.extend([c.id for c in self.channels])
        token.append(self.sampling_rate)
        token.append(self.latency)
        token.append(self.input_provider_id)
        token.append(self.input_device_id)
        return token

    @property
    def channels(self) -&gt; List[SensorChannel]:
        &#34;&#34;&#34;Array of the `SensorChannel`s associated with the context. (`List[SensorChannel]`, read-only) &#34;&#34;&#34;
        return self.__channels

    @property
    def sampling_rate(self) -&gt; int:
        &#34;&#34;&#34;Hint for sampling rate valid for all channels. (`int`, read-only)&#34;&#34;&#34;
        return self.__sampling_rate_hint

    @property
    def latency(self) -&gt; int:
        &#34;&#34;&#34;Gets the latency measurement in milliseconds. (`int`, read-only)&#34;&#34;&#34;
        return self.__latency

    @property
    def input_provider_id(self) -&gt; uuid.UUID:
        &#34;&#34;&#34;Reference id to the ink `InputProvider` that produces the ink. (`UUID`, read-only)&#34;&#34;&#34;
        return self.__ink_input_provider_id

    @property
    def input_device_id(self) -&gt; uuid.UUID:
        &#34;&#34;&#34;Reference to `InkInputDevice`. (`UUID`, read-only)&#34;&#34;&#34;
        return self.__input_device_id

    def add_sensor_channel(self, channel: SensorChannel):
        &#34;&#34;&#34;
        Adding a channel.

        Parameters
        ----------
        channel: `SensorChannel`
            sensor channel
        &#34;&#34;&#34;
        self.__channels.append(channel)

    def has_channel_type(self, channel_type: InkSensorType):
        &#34;&#34;&#34;
        Checks if channel types is available.

        Parameters
        ----------
        channel_type: `InkSensorType`
            sensor type

        Returns
        -------
        flag: `boolean`
            True if available, False if not
        &#34;&#34;&#34;
        for c in self.channels:
            if c.type == channel_type:
                return True
        return False

    def get_channel_by_type(self, channel_type: InkSensorType) -&gt; SensorChannel:
        &#34;&#34;&#34;Returns instance of Channel.

        Parameters
        ----------
        channel_type: `InkSensorType`
            type  of the channel

        Returns
        -------
        instance: SensorChannel
            Instance of the `SensorChannel` for the `InkSensorType`

        Raises
        ------
        InkModelException
            If the `SensorChannel` is not available.
        &#34;&#34;&#34;
        for c in self.__channels:
            if c.type == channel_type:
                return c
        raise InkModelException(f&#39;No channel available for the type: {channel_type}&#39;)

    def __repr__(self):
        return &#39;&lt;SensorChannelsContext: [id:={}, sampling rate hint:={}, latency:={}, input data provider id:={}, &#39; \
               &#39;input data id:={}&gt;&#39;.format(self.id_h_form, self.sampling_rate, self.latency,
                                           UUIDIdentifier.uimid_to_h_form(self.input_provider_id),
                                           UUIDIdentifier.uimid_to_h_form(self.input_device_id))


class SensorContext(HashIdentifier):
    &#34;&#34;&#34;
    SensorContext
    =============
    Each input data has a SensorContext describing the available sensors of a input data.
    One file can contains Ink data from two input data of the same type with a shared context.

    Parameters
    -----------
    context_id: UUID
        Id of the context
    sensor_channels_contexts: `List[SensorChannelsContext]`
        List of `SensorChannelsContext`
    &#34;&#34;&#34;

    def __init__(self, context_id: uuid.UUID = None, sensor_channels_contexts: List[SensorChannelsContext] = None):
        &#34;&#34;&#34;Constructor.

        &#34;&#34;&#34;
        super().__init__(context_id)
        self.__sensor_channels_contexts: List[SensorChannelsContext] = sensor_channels_contexts or []

    def __tokenize__(self) -&gt; list:
        token: list = [&#34;SensorContext&#34;]
        token.extend([c.id for c in self.sensor_channels_contexts])
        return token

    @property
    def sensor_channels_contexts(self) -&gt; List[SensorChannelsContext]:
        &#34;&#34;&#34;
        List of channel contexts. (`List[SensorChannelsContext]`, read-only)&#34;&#34;&#34;
        return self.__sensor_channels_contexts

    def add_sensor_channels_context(self, channel_ctx: SensorChannelsContext):
        &#34;&#34;&#34;Adding a sensor.

        Parameters
        ----------
        channel_ctx: `SensorChannelsContext`
            Adding a channel
        &#34;&#34;&#34;
        self.__sensor_channels_contexts.append(channel_ctx)

    def has_channel_type(self, channel_type: InkSensorType) -&gt; bool:
        &#34;&#34;&#34;
        Check if the SensorContext has a channel with type.

        Parameters
        ----------
        channel_type: `InkSensorType`
            type of channel

        Returns
        -------
        flag: `bool`
            True if channel exists, False if not
        &#34;&#34;&#34;
        for c in self.__sensor_channels_contexts:
            if c.has_channel_type(channel_type):
                return True
        return False

    def get_channel_by_id(self, channel_id: uuid.UUID) -&gt; SensorChannel:
        &#34;&#34;&#34;
         Returns the channel for a specific id.

         Parameters
         ----------
        channel_id: bytes -
            id of channel

        Returns
        -------
        instance: `SensorChannel`
            Instance of `SensorChannel`

        Raises
        ------
            InkModelException: Raised if no channel for channel id.
        &#34;&#34;&#34;
        for cs in self.sensor_channels_contexts:
            for c in cs.channels:
                if c.id == channel_id:
                    return c
        raise InkModelException(&#39;No channel with channel id: {}.&#39;.format(channel_id))

    def get_channel_by_type(self, channel_type: InkSensorType) -&gt; SensorChannel:
        &#34;&#34;&#34;
        Returns the channel for a specific `InkSensorType`.
        
        Parameters
        ----------
        channel_type: `InkSensorType`
            Channel type
        
        Returns
        -------
        instance: `SensorChannel`
            Instance of channel
            
        Raises
        ------
        InkModelException
            Raised if no `SensorChannel` for the id is not available.
        &#34;&#34;&#34;
        for c in self.__sensor_channels_contexts:
            if c.has_channel_type(channel_type):
                return c.get_channel_by_type(channel_type)
        raise InkModelException(&#39;No channel with channel type: {}.&#39;.format(channel_type))

    def __repr__(self):
        return &#39;&lt;SensorContext: [context_id:={}, sensor_channels_contexts:={}]&gt;&#39;.format(self.id,
                                                                                        self.sensor_channels_contexts)


class InputContextRepository(ABC):
    &#34;&#34;&#34;
    InputContext Repository
    =======================

    The InputContext Repository is a data repository responsible for storing information about where the raw input
    data-frame originates from, by allowing unique identification of the exact input source. The repository stores
    information about the device itself, the environment and the on-board device sensors for each data point.

    The repository holds the following data collections:

        - **ink_input_providers** - a collection of InkInputProvider instances
        - **input_devices** - a collection of InputDevice instances
        - **environments** - a collection of Environment instances
        - **sensor_contexts** - a collection of SensorContext instances
        - **input_contexts** - a collection of InputContext instances
        
    Parameters
    ----------
    input_contexts: List[InputContext] -
        List of input data contexts
    ink_input_providers: List[InkInputProvider]
        List of input data providers
    input_devices: List[InputDevice]
        List of input data devices
    environments: List[Environment]
        List of environment setups
    sensor_contexts: List[SensorContext]
        List of sensor contexts
    &#34;&#34;&#34;

    def __init__(self, input_contexts: List[InputContext] = None, ink_input_providers: List[InkInputProvider] = None,
                 input_devices: List[InputDevice] = None, environments: List[Environment] = None,
                 sensor_contexts: List[SensorContext] = None):
        self.__input_contexts: List[InputContext] = input_contexts or []
        self.__ink_input_providers: List[InkInputProvider] = ink_input_providers or []
        self.__input_devices: List[InputDevice] = input_devices or []
        self.__environments: List[Environment] = environments or []
        self.__sensor_contexts: List[SensorContext] = sensor_contexts or []

    def add_ink_device(self, ink_device: InputDevice):
        &#34;&#34;&#34;
        Adding input device.

        Parameters
        ----------
        ink_device: `InputDevice`
            Adds an input device
        &#34;&#34;&#34;
        self.__input_devices.append(ink_device)

    @property
    def devices(self) -&gt; List[InputDevice]:
        &#34;&#34;&#34;
        Input devices. (`List[InputDevice]`)&#34;&#34;&#34;
        return self.__input_devices

    def add_input_context(self, input_context: InputContext):
        &#34;&#34;&#34;
        Adding context.

        Parameters
        ----------
        input_context: `InputContext`
            Input context instance
        &#34;&#34;&#34;
        self.__input_contexts.append(input_context)

    @property
    def input_contexts(self) -&gt; List[InputContext]:
        &#34;&#34;&#34; List of input contexts. (`List[InputContext]`, read-only)&#34;&#34;&#34;
        return self.__input_contexts

    def get_input_context(self, ctx_id: uuid.UUID) -&gt; InputContext:
        &#34;&#34;&#34;
        Returns the InputContext.

        Parameters
        ----------
        ctx_id: `UUID`
            Input context id

        Returns
        -------
        context: InputContext
            Input  context

        Raises
        ------
        InkModelException
            If the `InputContext` for the id is not available.
        &#34;&#34;&#34;
        for ctx in self.input_contexts:
            if ctx.id == ctx_id:
                return ctx
        raise InkModelException(&#39;No input context with id:={}.&#39;.format(ctx_id))

    def get_input_device(self, device_id: uuid.UUID) -&gt; InputDevice:
        &#34;&#34;&#34;
        Returns the InputDevice.

        Parameters
        ----------
        device_id: `UUID`
            Input device id

        Returns
        -------
        context: InputDevice
            Input  device

        Raises
        ------
        InkModelException
            If the `InputDevice` for the id is not available.
        &#34;&#34;&#34;
        for dev in self.devices:
            if dev.id == device_id:
                return dev
        raise InkModelException(&#39;No input device with id:={}.&#39;.format(device_id))

    def get_sensor_context(self, ctx_id: uuid.UUID) -&gt; SensorContext:
        &#34;&#34;&#34;
        Returns the `SensorContext` for the id.

        Parameters
        ----------
        ctx_id: `UUID`input context id

        Returns
        --------
        instance: `SensorContext`
            `SensorContext` instance

        Raises
        ------
        InkModelException
            If the `SensorContext` for the id is not available
        &#34;&#34;&#34;
        for ctx in self.sensor_contexts:
            if ctx.id == ctx_id:
                return ctx
        raise InkModelException(&#39;No sensor context with id:={}.&#39;.format(ctx_id))

    def add_input_provider(self, input_provider: InkInputProvider):
        &#34;&#34;&#34;
        Adding input data provider.

        Parameters
        ----------
        input_provider: `InkInputProvider`
            Input data provider instance
        &#34;&#34;&#34;
        self.__ink_input_providers.append(input_provider)

    @property
    def ink_input_providers(self) -&gt; List[InkInputProvider]:
        &#34;&#34;&#34;List of `InkInputProvider`s. (`List[InkInputProvider]`, read-only)&#34;&#34;&#34;
        return self.__ink_input_providers

    def add_environment(self, environment: Environment):
        &#34;&#34;&#34;
        Adding environment.

        Parameters
        ----------
        environment: Environment
            Environment instance
        &#34;&#34;&#34;
        self.environments.append(environment)

    @property
    def environments(self) -&gt; List[Environment]:
        &#34;&#34;&#34;List of Environments. (`List[Environment]`, read-only)&#34;&#34;&#34;
        return self.__environments

    def add_sensor_context(self, sensor_context: SensorContext):
        &#34;&#34;&#34;
        Adding sensor context.

        Parameters
        ----------
        sensor_context: `SensorContext`
            Instance of `SensorContext`
        &#34;&#34;&#34;
        self.__sensor_contexts.append(sensor_context)

    @property
    def sensor_contexts(self) -&gt; List[SensorContext]:
        &#34;&#34;&#34;List of SensorContexts. (`List[SensorContext]`)&#34;&#34;&#34;
        return self.__sensor_contexts

    def has_configuration(self) -&gt; bool:
        &#34;&#34;&#34;Check if any configuration is available.

        Returns
        -------
        flag: bool
            Flag if either ink input provide, input device, or sensor context are defined
        &#34;&#34;&#34;
        return len(self.input_contexts) &gt; 0 or len(self.sensor_contexts) &gt; 0 or len(self.ink_input_providers) &gt; 0 or \
            len(self.devices) &gt; 0 or len(self.environments)

    def __repr__(self):
        return &#39;&lt;InputContextData: [#context:={}, #providers:={}, #devices:={}, #environments:={}, #sensors:={}]&gt;&#39; \
            .format(len(self.input_contexts), len(self.ink_input_providers), len(self.devices),
                    len(self.environments), len(self.sensor_contexts))</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="uim.model.inkinput.inputdata.CONVERSION_SCALAR"><code class="name">var <span class="ident">CONVERSION_SCALAR</span></code></dt>
<dd>
<div class="desc"><p>Mapping containing the factors to convert from one unit: <source-unit> into the other: <target-unit>.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="uim.model.inkinput.inputdata.si_unit"><code class="name flex">
<span>def <span class="ident">si_unit</span></span>(<span>unit_type:Â <a title="uim.model.inkinput.inputdata.Unit" href="#uim.model.inkinput.inputdata.Unit">Unit</a>) â>Â <a title="uim.model.inkinput.inputdata.Unit" href="#uim.model.inkinput.inputdata.Unit">Unit</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return the SI unit for a specific unit type.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>unit_type</code></strong> :&ensp;<code><a title="uim.model.inkinput.inputdata.Unit" href="#uim.model.inkinput.inputdata.Unit">Unit</a></code></dt>
<dd>Unit</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>si_unit</code></strong> :&ensp;<code><a title="uim.model.inkinput.inputdata.Unit" href="#uim.model.inkinput.inputdata.Unit">Unit</a></code></dt>
<dd>SI unit for a unit, e.g., for a lengths unit cm the SI unit is m.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def si_unit(unit_type: Unit) -&gt; Unit:
    &#34;&#34;&#34;
    Return the SI unit for a specific unit type.

    Parameters
    ----------
    unit_type: `Unit`
        Unit

    Returns
    -------
    si_unit: Unit
        SI unit for a unit, e.g., for a lengths unit cm the SI unit is m.
    &#34;&#34;&#34;
    # SI unit for length is m
    if unit_type in [Unit.M, Unit.CM, Unit.MM, Unit.IN, Unit.PT, Unit.PC, Unit.DIP]:
        return Unit.M
    # SI unit for time is s
    if unit_type in [Unit.S, Unit.MS, Unit.NS]:
        return Unit.S
    return Unit.UNDEFINED</code></pre>
</details>
</dd>
<dt id="uim.model.inkinput.inputdata.unit2unit"><code class="name flex">
<span>def <span class="ident">unit2unit</span></span>(<span>source_unit:Â <a title="uim.model.inkinput.inputdata.Unit" href="#uim.model.inkinput.inputdata.Unit">Unit</a>, target_unit:Â <a title="uim.model.inkinput.inputdata.Unit" href="#uim.model.inkinput.inputdata.Unit">Unit</a>, value:Â float) â>Â float</span>
</code></dt>
<dd>
<div class="desc"><p>Convert value with a source unit to the target unit.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>source_unit</code></strong> :&ensp;<code><a title="uim.model.inkinput.inputdata.Unit" href="#uim.model.inkinput.inputdata.Unit">Unit</a></code></dt>
<dd>Source unit</dd>
<dt><strong><code>target_unit</code></strong> :&ensp;<code><a title="uim.model.inkinput.inputdata.Unit" href="#uim.model.inkinput.inputdata.Unit">Unit</a></code></dt>
<dd>Target unit</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>Value in source unit</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>value converted to target unit</dd>
</dl>
<h2 id="raises">Raises</h2>
<h2 id="valueerror">Valueerror</h2>
<p>Unit is not supported</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unit2unit(source_unit: Unit, target_unit: Unit, value: float) -&gt; float:
    &#34;&#34;&#34;
    Convert value with a source unit to the target unit.

    Parameters
    ----------
    source_unit: Unit
        Source unit
    target_unit: Unit
        Target unit
    value: float
        Value in source unit

    Returns
    -------
    value: `float`
        value converted to target unit

    Raises
    ------
    ValueError:
        Unit is not supported
    &#34;&#34;&#34;
    if source_unit == Unit.UNDEFINED or target_unit == Unit.UNDEFINED:
        return value
    if source_unit not in CONVERSION_SCALAR:
        raise ValueError(&#39;Source unit not supported. Unit:={}&#39;.format(source_unit))
    if target_unit not in CONVERSION_SCALAR[source_unit]:
        raise ValueError(&#39;Target unit not supported. Unit:={}&#39;.format(target_unit))
    return CONVERSION_SCALAR[source_unit][target_unit] * value</code></pre>
</details>
</dd>
<dt id="uim.model.inkinput.inputdata.unit2unit_matrix"><code class="name flex">
<span>def <span class="ident">unit2unit_matrix</span></span>(<span>source_unit:Â <a title="uim.model.inkinput.inputdata.Unit" href="#uim.model.inkinput.inputdata.Unit">Unit</a>, target_unit:Â <a title="uim.model.inkinput.inputdata.Unit" href="#uim.model.inkinput.inputdata.Unit">Unit</a>) â>Â <built-inÂ functionÂ array></span>
</code></dt>
<dd>
<div class="desc"><p>Matrix for unit 2 unit conversion.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>source_unit</code></strong> :&ensp;<code><a title="uim.model.inkinput.inputdata.Unit" href="#uim.model.inkinput.inputdata.Unit">Unit</a></code></dt>
<dd>Source unit</dd>
<dt><strong><code>target_unit</code></strong> :&ensp;<code><a title="uim.model.inkinput.inputdata.Unit" href="#uim.model.inkinput.inputdata.Unit">Unit</a></code></dt>
<dd>Target unit</dd>
</dl>
<h2 id="returns">Returns</h2>
<pre><code>matrix: &lt;code&gt;np.array&lt;/code&gt;
    matrix for conversion
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unit2unit_matrix(source_unit: Unit, target_unit: Unit) -&gt; np.array:
    &#34;&#34;&#34;
    Matrix for unit 2 unit conversion.

    Parameters
    ----------
    source_unit: Unit
        Source unit
    target_unit: Unit
        Target unit

    Returns
    -------
        matrix: `np.array`
            matrix for conversion
    &#34;&#34;&#34;
    matrix: np.array = np.identity(3)
    if source_unit == Unit.UNDEFINED or target_unit == Unit.UNDEFINED:
        return matrix
    if source_unit not in CONVERSION_SCALAR:
        raise ValueError(&#39;Source unit not supported.&#39;)
    if target_unit not in CONVERSION_SCALAR[source_unit]:
        raise ValueError(&#39;Target unit not supported.&#39;)
    matrix[0, 0] = CONVERSION_SCALAR[source_unit][target_unit]
    matrix[1, 1] = CONVERSION_SCALAR[source_unit][target_unit]
    return matrix</code></pre>
</details>
</dd>
<dt id="uim.model.inkinput.inputdata.virtual_resolution_for_si_unit"><code class="name flex">
<span>def <span class="ident">virtual_resolution_for_si_unit</span></span>(<span>source_unit:Â <a title="uim.model.inkinput.inputdata.Unit" href="#uim.model.inkinput.inputdata.Unit">Unit</a>) â>Â float</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate a virtual resolution for source unit.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>source_unit</code></strong> :&ensp;<code>unit</code></dt>
<dd>Source unit</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>resolution</code></strong> :&ensp;<code>float</code></dt>
<dd>Virtual resolution</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def virtual_resolution_for_si_unit(source_unit: Unit) -&gt; float:
    &#34;&#34;&#34;
    Calculate a virtual resolution for source unit.

    Parameters
    ----------
    source_unit: unit
        Source unit
    Returns
    -------
    resolution: `float`
        Virtual resolution
    &#34;&#34;&#34;
    si: Unit = si_unit(source_unit)
    if si == Unit.UNDEFINED:
        return 1.
    return 1. / CONVERSION_SCALAR[source_unit][si]</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="uim.model.inkinput.inputdata.DataType"><code class="flex name class">
<span>class <span class="ident">DataType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Data types for channels.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataType(Enum):
    &#34;&#34;&#34;Data types for channels.&#34;&#34;&#34;
    BOOLEAN = 0
    FLOAT32 = 1
    FLOAT64 = 2
    INT32 = 3
    INT64 = 4
    UINT32 = 5
    UINT64 = 6</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="uim.model.inkinput.inputdata.DataType.BOOLEAN"><code class="name">var <span class="ident">BOOLEAN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="uim.model.inkinput.inputdata.DataType.FLOAT32"><code class="name">var <span class="ident">FLOAT32</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="uim.model.inkinput.inputdata.DataType.FLOAT64"><code class="name">var <span class="ident">FLOAT64</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="uim.model.inkinput.inputdata.DataType.INT32"><code class="name">var <span class="ident">INT32</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="uim.model.inkinput.inputdata.DataType.INT64"><code class="name">var <span class="ident">INT64</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="uim.model.inkinput.inputdata.DataType.UINT32"><code class="name">var <span class="ident">UINT32</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="uim.model.inkinput.inputdata.DataType.UINT64"><code class="name">var <span class="ident">UINT64</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="uim.model.inkinput.inputdata.Environment"><code class="flex name class">
<span>class <span class="ident">Environment</span></span>
<span>(</span><span>env_id:Â uuid.UUIDÂ =Â None, properties:Â List[Tuple[str,Â str]]Â =Â None)</span>
</code></dt>
<dd>
<div class="desc"><h1 id="environment">Environment</h1>
<p>The class <code><a title="uim.model.inkinput.inputdata.Environment" href="#uim.model.inkinput.inputdata.Environment">Environment</a></code> represents for the virtual environment in which the sensor data has been produced, e.g,:</p>
<pre><code>- os.name - Name of the operating system
- os.version.name - Name of the version
- os.version.release - Release build number
- wacom.ink.sdk.name - Name of the Wacom Ink technology
- wacom.ink.sdk.version - Version number of the SDK
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>env_id</code></strong> :&ensp;<code>UUID</code></dt>
<dd>Internal environment UUID</dd>
<dt><strong><code>properties</code></strong> :&ensp;<code>List[Tuple[str, str]]</code></dt>
<dd>Properties of the environment</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from uim.model.inkinput.inputdata import Environment
&gt;&gt;&gt; # Create an environment
&gt;&gt;&gt; env: Environment = Environment()
&gt;&gt;&gt; env.properties.append((&quot;env.name&quot;, &quot;My Environment&quot;))
&gt;&gt;&gt; env.properties.append((&quot;os.id&quot;, &quot;98765&quot;))
&gt;&gt;&gt; env.properties.append((&quot;os.name&quot;, &quot;Windows&quot;))
&gt;&gt;&gt; env.properties.append((&quot;os.version&quot;, &quot;10.0.18362.239&quot;))
&gt;&gt;&gt; env.properties.append((&quot;os.build&quot;, &quot;239&quot;))
&gt;&gt;&gt; env.properties.append((&quot;os.platform&quot;, &quot;whatever&quot;))
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Environment(HashIdentifier):
    &#34;&#34;&#34;
    Environment
    ===========
    The class `Environment` represents for the virtual environment in which the sensor data has been produced, e.g,:

        - os.name - Name of the operating system
        - os.version.name - Name of the version
        - os.version.release - Release build number
        - wacom.ink.sdk.name - Name of the Wacom Ink technology
        - wacom.ink.sdk.version - Version number of the SDK

    Parameters
    ----------
    env_id: `UUID`
        Internal environment UUID
    properties: List[Tuple[str, str]]
        Properties of the environment

    Examples
    --------
    &gt;&gt;&gt; from uim.model.inkinput.inputdata import Environment
    &gt;&gt;&gt; # Create an environment
    &gt;&gt;&gt; env: Environment = Environment()
    &gt;&gt;&gt; env.properties.append((&#34;env.name&#34;, &#34;My Environment&#34;))
    &gt;&gt;&gt; env.properties.append((&#34;os.id&#34;, &#34;98765&#34;))
    &gt;&gt;&gt; env.properties.append((&#34;os.name&#34;, &#34;Windows&#34;))
    &gt;&gt;&gt; env.properties.append((&#34;os.version&#34;, &#34;10.0.18362.239&#34;))
    &gt;&gt;&gt; env.properties.append((&#34;os.build&#34;, &#34;239&#34;))
    &gt;&gt;&gt; env.properties.append((&#34;os.platform&#34;, &#34;whatever&#34;))
    &#34;&#34;&#34;

    def __init__(self, env_id: uuid.UUID = None, properties: List[Tuple[str, str]] = None):
        super().__init__(env_id)
        self.__properties = properties or []

    def __tokenize__(self) -&gt; List[Any]:
        token: List[Any] = [&#39;Environment&#39;, self.properties]
        return token

    @property
    def properties(self) -&gt; List[Tuple[str, str]]:
        &#34;&#34;&#34;Environment properties. (`List[Tuple[str, str]]`, read-only) &#34;&#34;&#34;
        return self.__properties

    def add_environment_property(self, key: str, value: str):
        &#34;&#34;&#34;
        Adding a property for environment.

        Parameters
        ----------
        key: str
            Name of the property
        value: str
            Value of the property
        &#34;&#34;&#34;
        self.properties.append((key, value))

    def __repr__(self):
        return &#39;&lt;Environment: [id:={}, #properties:={}&gt;&#39;.format(self.id.hex, self.properties)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="uim.model.base.HashIdentifier" href="../base.html#uim.model.base.HashIdentifier">HashIdentifier</a></li>
<li><a title="uim.model.base.Identifier" href="../base.html#uim.model.base.Identifier">Identifier</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="uim.model.inkinput.inputdata.Environment.SEPARATOR"><code class="name">var <span class="ident">SEPARATOR</span> :Â str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="uim.model.inkinput.inputdata.Environment.properties"><code class="name">var <span class="ident">properties</span> :Â List[Tuple[str,Â str]]</code></dt>
<dd>
<div class="desc"><p>Environment properties. (<code>List[Tuple[str, str]]</code>, read-only)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def properties(self) -&gt; List[Tuple[str, str]]:
    &#34;&#34;&#34;Environment properties. (`List[Tuple[str, str]]`, read-only) &#34;&#34;&#34;
    return self.__properties</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="uim.model.inkinput.inputdata.Environment.add_environment_property"><code class="name flex">
<span>def <span class="ident">add_environment_property</span></span>(<span>self, key:Â str, value:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>Adding a property for environment.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the property</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>str</code></dt>
<dd>Value of the property</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_environment_property(self, key: str, value: str):
    &#34;&#34;&#34;
    Adding a property for environment.

    Parameters
    ----------
    key: str
        Name of the property
    value: str
        Value of the property
    &#34;&#34;&#34;
    self.properties.append((key, value))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="uim.model.base.HashIdentifier" href="../base.html#uim.model.base.HashIdentifier">HashIdentifier</a></b></code>:
<ul class="hlist">
<li><code><a title="uim.model.base.HashIdentifier.from_bytes" href="../base.html#uim.model.base.Identifier.from_bytes">from_bytes</a></code></li>
<li><code><a title="uim.model.base.HashIdentifier.id" href="../base.html#uim.model.base.Identifier.id">id</a></code></li>
<li><code><a title="uim.model.base.HashIdentifier.id_h_form" href="../base.html#uim.model.base.Identifier.id_h_form">id_h_form</a></code></li>
<li><code><a title="uim.model.base.HashIdentifier.id_s_form" href="../base.html#uim.model.base.Identifier.id_s_form">id_s_form</a></code></li>
<li><code><a title="uim.model.base.HashIdentifier.str_to_uimid" href="../base.html#uim.model.base.Identifier.str_to_uimid">str_to_uimid</a></code></li>
<li><code><a title="uim.model.base.HashIdentifier.uimid_to_h_form" href="../base.html#uim.model.base.Identifier.uimid_to_h_form">uimid_to_h_form</a></code></li>
<li><code><a title="uim.model.base.HashIdentifier.uimid_to_s_form" href="../base.html#uim.model.base.Identifier.uimid_to_s_form">uimid_to_s_form</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="uim.model.inkinput.inputdata.InkInputProvider"><code class="flex name class">
<span>class <span class="ident">InkInputProvider</span></span>
<span>(</span><span>provider_id:Â uuid.UUIDÂ =Â None, input_type:Â <a title="uim.model.inkinput.inputdata.InkInputType" href="#uim.model.inkinput.inputdata.InkInputType">InkInputType</a>Â =Â None, properties:Â List[Tuple[str,Â str]]Â =Â None)</span>
</code></dt>
<dd>
<div class="desc"><h1 id="inkinputprovider">InkInputProvider</h1>
<p>The class InkInputProvider stands for the generic input data source - it identifies how the data has been generated
(using touch input, mouse, stylus, hardware controller, etc).</p>
<p>The properties which can be used to describe the InkInputProvider:</p>
<pre><code>- pen.type - Type of the pen device
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>provider_id</code></strong> :&ensp;<code>UUID</code></dt>
<dd>internal id or input data name.</dd>
<dt><strong><code>input_type</code></strong> :&ensp;<code>InkInputType -</code></dt>
<dd>type of used hardware - PEN, TOUCH, MOUSE, or CONTROLLER.</dd>
<dt><strong><code>properties</code></strong> :&ensp;<code>List[Tuple[str, str]] -</code></dt>
<dd>Properties assigned to ink input provider</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from uim.model.inkinput.inputdata import InkInputProvider
&gt;&gt;&gt; # Ink input provider can be pen, mouse or touch.
&gt;&gt;&gt; provider: InkInputProvider = InkInputProvider(input_type=InkInputType.MOUSE)
&gt;&gt;&gt; provider.properties.append((&quot;pen.id&quot;, &quot;1234567&quot;))
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InkInputProvider(HashIdentifier):
    &#34;&#34;&#34;
    InkInputProvider
    ================
    The class InkInputProvider stands for the generic input data source - it identifies how the data has been generated
    (using touch input, mouse, stylus, hardware controller, etc).

    The properties which can be used to describe the InkInputProvider:

        - pen.type - Type of the pen device

    Parameters
    ----------
    provider_id: UUID
        internal id or input data name.
    input_type: InkInputType -
        type of used hardware - PEN, TOUCH, MOUSE, or CONTROLLER.
    properties: List[Tuple[str, str]] -
        Properties assigned to ink input provider

    Examples
    --------
    &gt;&gt;&gt; from uim.model.inkinput.inputdata import InkInputProvider
    &gt;&gt;&gt; # Ink input provider can be pen, mouse or touch.
    &gt;&gt;&gt; provider: InkInputProvider = InkInputProvider(input_type=InkInputType.MOUSE)
    &gt;&gt;&gt; provider.properties.append((&#34;pen.id&#34;, &#34;1234567&#34;))
    &#34;&#34;&#34;

    def __init__(self, provider_id: uuid.UUID = None, input_type: InkInputType = None,
                 properties: List[Tuple[str, str]] = None):
        super().__init__(provider_id)
        self.__type: InkInputType = input_type
        self.__properties: List[Tuple[str, str]] = properties or []

    def __tokenize__(self):
        return [&#39;InkInputProvider&#39;, TOKEN_MAP[self.type], self.properties]

    @property
    def type(self) -&gt; InkInputType:
        &#34;&#34;&#34;Input provider type. (`InkInputType`,  read-only)&#34;&#34;&#34;
        return self.__type

    @property
    def properties(self) -&gt; List[Tuple[str, str]]:
        &#34;&#34;&#34;Properties of input data provider. (`List[Tuple[str, str]]`, read-only)&#34;&#34;&#34;
        return self.__properties

    def __repr__(self):
        return &#39;&lt;InkInputProvider: [id:={}, type:={}, properties:={}]&gt;&#39;.format(self.id, self.type, self.properties)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="uim.model.base.HashIdentifier" href="../base.html#uim.model.base.HashIdentifier">HashIdentifier</a></li>
<li><a title="uim.model.base.Identifier" href="../base.html#uim.model.base.Identifier">Identifier</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="uim.model.inkinput.inputdata.InkInputProvider.SEPARATOR"><code class="name">var <span class="ident">SEPARATOR</span> :Â str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="uim.model.inkinput.inputdata.InkInputProvider.properties"><code class="name">var <span class="ident">properties</span> :Â List[Tuple[str,Â str]]</code></dt>
<dd>
<div class="desc"><p>Properties of input data provider. (<code>List[Tuple[str, str]]</code>, read-only)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def properties(self) -&gt; List[Tuple[str, str]]:
    &#34;&#34;&#34;Properties of input data provider. (`List[Tuple[str, str]]`, read-only)&#34;&#34;&#34;
    return self.__properties</code></pre>
</details>
</dd>
<dt id="uim.model.inkinput.inputdata.InkInputProvider.type"><code class="name">var <span class="ident">type</span> :Â <a title="uim.model.inkinput.inputdata.InkInputType" href="#uim.model.inkinput.inputdata.InkInputType">InkInputType</a></code></dt>
<dd>
<div class="desc"><p>Input provider type. (<code><a title="uim.model.inkinput.inputdata.InkInputType" href="#uim.model.inkinput.inputdata.InkInputType">InkInputType</a></code>,
read-only)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def type(self) -&gt; InkInputType:
    &#34;&#34;&#34;Input provider type. (`InkInputType`,  read-only)&#34;&#34;&#34;
    return self.__type</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="uim.model.base.HashIdentifier" href="../base.html#uim.model.base.HashIdentifier">HashIdentifier</a></b></code>:
<ul class="hlist">
<li><code><a title="uim.model.base.HashIdentifier.from_bytes" href="../base.html#uim.model.base.Identifier.from_bytes">from_bytes</a></code></li>
<li><code><a title="uim.model.base.HashIdentifier.id" href="../base.html#uim.model.base.Identifier.id">id</a></code></li>
<li><code><a title="uim.model.base.HashIdentifier.id_h_form" href="../base.html#uim.model.base.Identifier.id_h_form">id_h_form</a></code></li>
<li><code><a title="uim.model.base.HashIdentifier.id_s_form" href="../base.html#uim.model.base.Identifier.id_s_form">id_s_form</a></code></li>
<li><code><a title="uim.model.base.HashIdentifier.str_to_uimid" href="../base.html#uim.model.base.Identifier.str_to_uimid">str_to_uimid</a></code></li>
<li><code><a title="uim.model.base.HashIdentifier.uimid_to_h_form" href="../base.html#uim.model.base.Identifier.uimid_to_h_form">uimid_to_h_form</a></code></li>
<li><code><a title="uim.model.base.HashIdentifier.uimid_to_s_form" href="../base.html#uim.model.base.Identifier.uimid_to_s_form">uimid_to_s_form</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="uim.model.inkinput.inputdata.InkInputType"><code class="flex name class">
<span>class <span class="ident">InkInputType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Defining the different types of input data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InkInputType(Enum):
    &#34;&#34;&#34;
    Defining the different types of input data.
    &#34;&#34;&#34;
    PEN = uim.PEN
    &#34;&#34;&#34;Stylus, smart pens, pen displays, signature capturing input data, ...&#34;&#34;&#34;
    TOUCH = uim.TOUCH
    &#34;&#34;&#34;Touch controller input data: Finger or passive stylus.&#34;&#34;&#34;
    MOUSE = uim.MOUSE
    &#34;&#34;&#34;Mouse input data.&#34;&#34;&#34;
    CONTROLLER = uim.CONTROLLER
    &#34;&#34;&#34;3-DOF or 6-DOF input data devices.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="uim.model.inkinput.inputdata.InkInputType.CONTROLLER"><code class="name">var <span class="ident">CONTROLLER</span></code></dt>
<dd>
<div class="desc"><p>3-DOF or 6-DOF input data devices.</p></div>
</dd>
<dt id="uim.model.inkinput.inputdata.InkInputType.MOUSE"><code class="name">var <span class="ident">MOUSE</span></code></dt>
<dd>
<div class="desc"><p>Mouse input data.</p></div>
</dd>
<dt id="uim.model.inkinput.inputdata.InkInputType.PEN"><code class="name">var <span class="ident">PEN</span></code></dt>
<dd>
<div class="desc"><p>Stylus, smart pens, pen displays, signature capturing input data, &hellip;</p></div>
</dd>
<dt id="uim.model.inkinput.inputdata.InkInputType.TOUCH"><code class="name">var <span class="ident">TOUCH</span></code></dt>
<dd>
<div class="desc"><p>Touch controller input data: Finger or passive stylus.</p></div>
</dd>
</dl>
</dd>
<dt id="uim.model.inkinput.inputdata.InkSensorMetricType"><code class="flex name class">
<span>class <span class="ident">InkSensorMetricType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Metric for the channel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InkSensorMetricType(Enum):
    &#34;&#34;&#34;Metric for the channel.&#34;&#34;&#34;
    LENGTH = uim.LENGTH
    &#34;&#34;&#34;Length; underling si unit is meter&#34;&#34;&#34;
    TIME = uim.TIME
    &#34;&#34;&#34;Time; underling  si unit is second&#34;&#34;&#34;
    FORCE = uim.FORCE
    &#34;&#34;&#34;Force; underling si unit is newton&#34;&#34;&#34;
    ANGLE = uim.ANGLE
    &#34;&#34;&#34;Angle; underling si unit is radian&#34;&#34;&#34;
    NORMALIZED = uim.NORMALIZED
    &#34;&#34;&#34;Normalized; percentage, expressed as a fraction(1.0 = 100 %) relative to max - min&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="uim.model.inkinput.inputdata.InkSensorMetricType.ANGLE"><code class="name">var <span class="ident">ANGLE</span></code></dt>
<dd>
<div class="desc"><p>Angle; underling si unit is radian</p></div>
</dd>
<dt id="uim.model.inkinput.inputdata.InkSensorMetricType.FORCE"><code class="name">var <span class="ident">FORCE</span></code></dt>
<dd>
<div class="desc"><p>Force; underling si unit is newton</p></div>
</dd>
<dt id="uim.model.inkinput.inputdata.InkSensorMetricType.LENGTH"><code class="name">var <span class="ident">LENGTH</span></code></dt>
<dd>
<div class="desc"><p>Length; underling si unit is meter</p></div>
</dd>
<dt id="uim.model.inkinput.inputdata.InkSensorMetricType.NORMALIZED"><code class="name">var <span class="ident">NORMALIZED</span></code></dt>
<dd>
<div class="desc"><p>Normalized; percentage, expressed as a fraction(1.0 = 100 %) relative to max - min</p></div>
</dd>
<dt id="uim.model.inkinput.inputdata.InkSensorMetricType.TIME"><code class="name">var <span class="ident">TIME</span></code></dt>
<dd>
<div class="desc"><p>Time; underling
si unit is second</p></div>
</dd>
</dl>
</dd>
<dt id="uim.model.inkinput.inputdata.InkSensorType"><code class="flex name class">
<span>class <span class="ident">InkSensorType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Pre-defined SensorData types.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InkSensorType(Enum):
    &#34;&#34;&#34;
        Pre-defined SensorData types.
    &#34;&#34;&#34;

    X = &#39;will://input/3.0/channel/X&#39;
    &#34;&#34;&#34;X coordinate. This is the horizontal pen position on the writing surface.&#34;&#34;&#34;
    Y = &#39;will://input/3.0/channel/Y&#39;
    &#34;&#34;&#34;Y coordinate. This is the vertical position on the writing surface. &#34;&#34;&#34;
    Z = &#39;will://input/3.0/channel/Z&#39;
    &#34;&#34;&#34;Z coordinate. This is the height of pen above the writing surface.&#34;&#34;&#34;
    TIMESTAMP = &#39;will://input/3.0/channel/Timestamp&#39;
    &#34;&#34;&#34;Time (of the sample point)&#34;&#34;&#34;
    PRESSURE = &#39;will://input/3.0/channel/Pressure&#39;
    &#34;&#34;&#34;Input pressure.&#34;&#34;&#34;
    RADIUS_X = &#39;will://input/3.0/channel/RadiusX&#39;
    &#34;&#34;&#34;Touch radius by X&#34;&#34;&#34;
    RADIUS_Y = &#39;will://input/3.0/channel/RadiusY&#39;
    &#34;&#34;&#34;Touch radius by Y&#34;&#34;&#34;
    AZIMUTH = &#39;will://input/3.0/channel/Azimuth&#39;
    &#34;&#34;&#34;Azimuth angle of the pen (yaw)&#34;&#34;&#34;
    ALTITUDE = &#39;will://input/3.0/channel/Altitude&#39;
    &#34;&#34;&#34;Elevation angle of the pen (pitch)&#34;&#34;&#34;
    ROTATION = &#39;will://input/3.0/channel/Rotation&#39;
    &#34;&#34;&#34;Rotation (counter-clockwise rotation about pen axis)&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="uim.model.inkinput.inputdata.InkSensorType.ALTITUDE"><code class="name">var <span class="ident">ALTITUDE</span></code></dt>
<dd>
<div class="desc"><p>Elevation angle of the pen (pitch)</p></div>
</dd>
<dt id="uim.model.inkinput.inputdata.InkSensorType.AZIMUTH"><code class="name">var <span class="ident">AZIMUTH</span></code></dt>
<dd>
<div class="desc"><p>Azimuth angle of the pen (yaw)</p></div>
</dd>
<dt id="uim.model.inkinput.inputdata.InkSensorType.PRESSURE"><code class="name">var <span class="ident">PRESSURE</span></code></dt>
<dd>
<div class="desc"><p>Input pressure.</p></div>
</dd>
<dt id="uim.model.inkinput.inputdata.InkSensorType.RADIUS_X"><code class="name">var <span class="ident">RADIUS_X</span></code></dt>
<dd>
<div class="desc"><p>Touch radius by X</p></div>
</dd>
<dt id="uim.model.inkinput.inputdata.InkSensorType.RADIUS_Y"><code class="name">var <span class="ident">RADIUS_Y</span></code></dt>
<dd>
<div class="desc"><p>Touch radius by Y</p></div>
</dd>
<dt id="uim.model.inkinput.inputdata.InkSensorType.ROTATION"><code class="name">var <span class="ident">ROTATION</span></code></dt>
<dd>
<div class="desc"><p>Rotation (counter-clockwise rotation about pen axis)</p></div>
</dd>
<dt id="uim.model.inkinput.inputdata.InkSensorType.TIMESTAMP"><code class="name">var <span class="ident">TIMESTAMP</span></code></dt>
<dd>
<div class="desc"><p>Time (of the sample point)</p></div>
</dd>
<dt id="uim.model.inkinput.inputdata.InkSensorType.X"><code class="name">var <span class="ident">X</span></code></dt>
<dd>
<div class="desc"><p>X coordinate. This is the horizontal pen position on the writing surface.</p></div>
</dd>
<dt id="uim.model.inkinput.inputdata.InkSensorType.Y"><code class="name">var <span class="ident">Y</span></code></dt>
<dd>
<div class="desc"><p>Y coordinate. This is the vertical position on the writing surface.</p></div>
</dd>
<dt id="uim.model.inkinput.inputdata.InkSensorType.Z"><code class="name">var <span class="ident">Z</span></code></dt>
<dd>
<div class="desc"><p>Z coordinate. This is the height of pen above the writing surface.</p></div>
</dd>
</dl>
</dd>
<dt id="uim.model.inkinput.inputdata.InputContext"><code class="flex name class">
<span>class <span class="ident">InputContext</span></span>
<span>(</span><span>ctx_id:Â uuid.UUIDÂ =Â None, environment_id:Â uuid.UUIDÂ =Â None, sensor_context_id:Â uuid.UUIDÂ =Â None)</span>
</code></dt>
<dd>
<div class="desc"><h1 id="inputcontext">InputContext</h1>
<p>Capturing context of the uim input data with reference to the Environment and the SensorContext.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ctx_id</code></strong> :&ensp;<code>UUID</code></dt>
<dd>Internal id</dd>
<dt><strong><code>environment_id</code></strong> :&ensp;<code>UUID</code></dt>
<dd>Reference to environment</dd>
<dt><strong><code>sensor_context_id</code></strong> :&ensp;<code>UUID</code></dt>
<dd>Rendering to sensor context</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InputContext(HashIdentifier):
    &#34;&#34;&#34;
    InputContext
    ============
    Capturing context of the uim input data with reference to the Environment and the SensorContext.

    Parameters
    ----------
    ctx_id: `UUID`
        Internal id
    environment_id: `UUID`
        Reference to environment
    sensor_context_id: `UUID`
        Rendering to sensor context
    &#34;&#34;&#34;

    def __init__(self, ctx_id: uuid.UUID = None, environment_id: uuid.UUID = None, sensor_context_id: uuid.UUID = None):
        super().__init__(ctx_id)
        self.__environment_id = environment_id
        self.__sensor_context_id = sensor_context_id

    def __tokenize__(self) -&gt; list:
        return [&#34;InputContext&#34;, self.environment_id, self.sensor_context_id]

    @property
    def environment_id(self) -&gt; uuid.UUID:
        &#34;&#34;&#34;Reference to environment. (`UUID`, read-only)&#34;&#34;&#34;
        return self.__environment_id

    @property
    def sensor_context_id(self) -&gt; uuid.UUID:
        &#34;&#34;&#34;Reference for sensor context. (`UUID`, read-only)&#34;&#34;&#34;
        return self.__sensor_context_id

    def __repr__(self):
        env_id: str = Identifier.uimid_to_s_form(self.environment_id)
        sc_id: str = Identifier.uimid_to_s_form(self.sensor_context_id)
        return &#39;&lt;InputContext : [id:={}, environment id:={}, sensor context id:={}&gt;&#39;.format(self.id_h_form,
                                                                                            env_id, sc_id)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="uim.model.base.HashIdentifier" href="../base.html#uim.model.base.HashIdentifier">HashIdentifier</a></li>
<li><a title="uim.model.base.Identifier" href="../base.html#uim.model.base.Identifier">Identifier</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="uim.model.inkinput.inputdata.InputContext.SEPARATOR"><code class="name">var <span class="ident">SEPARATOR</span> :Â str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="uim.model.inkinput.inputdata.InputContext.environment_id"><code class="name">var <span class="ident">environment_id</span> :Â uuid.UUID</code></dt>
<dd>
<div class="desc"><p>Reference to environment. (<code>UUID</code>, read-only)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def environment_id(self) -&gt; uuid.UUID:
    &#34;&#34;&#34;Reference to environment. (`UUID`, read-only)&#34;&#34;&#34;
    return self.__environment_id</code></pre>
</details>
</dd>
<dt id="uim.model.inkinput.inputdata.InputContext.sensor_context_id"><code class="name">var <span class="ident">sensor_context_id</span> :Â uuid.UUID</code></dt>
<dd>
<div class="desc"><p>Reference for sensor context. (<code>UUID</code>, read-only)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sensor_context_id(self) -&gt; uuid.UUID:
    &#34;&#34;&#34;Reference for sensor context. (`UUID`, read-only)&#34;&#34;&#34;
    return self.__sensor_context_id</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="uim.model.base.HashIdentifier" href="../base.html#uim.model.base.HashIdentifier">HashIdentifier</a></b></code>:
<ul class="hlist">
<li><code><a title="uim.model.base.HashIdentifier.from_bytes" href="../base.html#uim.model.base.Identifier.from_bytes">from_bytes</a></code></li>
<li><code><a title="uim.model.base.HashIdentifier.id" href="../base.html#uim.model.base.Identifier.id">id</a></code></li>
<li><code><a title="uim.model.base.HashIdentifier.id_h_form" href="../base.html#uim.model.base.Identifier.id_h_form">id_h_form</a></code></li>
<li><code><a title="uim.model.base.HashIdentifier.id_s_form" href="../base.html#uim.model.base.Identifier.id_s_form">id_s_form</a></code></li>
<li><code><a title="uim.model.base.HashIdentifier.str_to_uimid" href="../base.html#uim.model.base.Identifier.str_to_uimid">str_to_uimid</a></code></li>
<li><code><a title="uim.model.base.HashIdentifier.uimid_to_h_form" href="../base.html#uim.model.base.Identifier.uimid_to_h_form">uimid_to_h_form</a></code></li>
<li><code><a title="uim.model.base.HashIdentifier.uimid_to_s_form" href="../base.html#uim.model.base.Identifier.uimid_to_s_form">uimid_to_s_form</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="uim.model.inkinput.inputdata.InputContextRepository"><code class="flex name class">
<span>class <span class="ident">InputContextRepository</span></span>
<span>(</span><span>input_contexts:Â List[<a title="uim.model.inkinput.inputdata.InputContext" href="#uim.model.inkinput.inputdata.InputContext">InputContext</a>]Â =Â None, ink_input_providers:Â List[<a title="uim.model.inkinput.inputdata.InkInputProvider" href="#uim.model.inkinput.inputdata.InkInputProvider">InkInputProvider</a>]Â =Â None, input_devices:Â List[<a title="uim.model.inkinput.inputdata.InputDevice" href="#uim.model.inkinput.inputdata.InputDevice">InputDevice</a>]Â =Â None, environments:Â List[<a title="uim.model.inkinput.inputdata.Environment" href="#uim.model.inkinput.inputdata.Environment">Environment</a>]Â =Â None, sensor_contexts:Â List[<a title="uim.model.inkinput.inputdata.SensorContext" href="#uim.model.inkinput.inputdata.SensorContext">SensorContext</a>]Â =Â None)</span>
</code></dt>
<dd>
<div class="desc"><h1 id="inputcontext-repository">InputContext Repository</h1>
<p>The InputContext Repository is a data repository responsible for storing information about where the raw input
data-frame originates from, by allowing unique identification of the exact input source. The repository stores
information about the device itself, the environment and the on-board device sensors for each data point.</p>
<p>The repository holds the following data collections:</p>
<pre><code>- **ink_input_providers** - a collection of InkInputProvider instances
- **input_devices** - a collection of InputDevice instances
- **environments** - a collection of Environment instances
- **sensor_contexts** - a collection of SensorContext instances
- **input_contexts** - a collection of InputContext instances
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>input_contexts</code></strong> :&ensp;<code>List[InputContext] -</code></dt>
<dd>List of input data contexts</dd>
<dt><strong><code>ink_input_providers</code></strong> :&ensp;<code>List[<a title="uim.model.inkinput.inputdata.InkInputProvider" href="#uim.model.inkinput.inputdata.InkInputProvider">InkInputProvider</a>]</code></dt>
<dd>List of input data providers</dd>
<dt><strong><code>input_devices</code></strong> :&ensp;<code>List[<a title="uim.model.inkinput.inputdata.InputDevice" href="#uim.model.inkinput.inputdata.InputDevice">InputDevice</a>]</code></dt>
<dd>List of input data devices</dd>
<dt><strong><code>environments</code></strong> :&ensp;<code>List[<a title="uim.model.inkinput.inputdata.Environment" href="#uim.model.inkinput.inputdata.Environment">Environment</a>]</code></dt>
<dd>List of environment setups</dd>
<dt><strong><code>sensor_contexts</code></strong> :&ensp;<code>List[<a title="uim.model.inkinput.inputdata.SensorContext" href="#uim.model.inkinput.inputdata.SensorContext">SensorContext</a>]</code></dt>
<dd>List of sensor contexts</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InputContextRepository(ABC):
    &#34;&#34;&#34;
    InputContext Repository
    =======================

    The InputContext Repository is a data repository responsible for storing information about where the raw input
    data-frame originates from, by allowing unique identification of the exact input source. The repository stores
    information about the device itself, the environment and the on-board device sensors for each data point.

    The repository holds the following data collections:

        - **ink_input_providers** - a collection of InkInputProvider instances
        - **input_devices** - a collection of InputDevice instances
        - **environments** - a collection of Environment instances
        - **sensor_contexts** - a collection of SensorContext instances
        - **input_contexts** - a collection of InputContext instances
        
    Parameters
    ----------
    input_contexts: List[InputContext] -
        List of input data contexts
    ink_input_providers: List[InkInputProvider]
        List of input data providers
    input_devices: List[InputDevice]
        List of input data devices
    environments: List[Environment]
        List of environment setups
    sensor_contexts: List[SensorContext]
        List of sensor contexts
    &#34;&#34;&#34;

    def __init__(self, input_contexts: List[InputContext] = None, ink_input_providers: List[InkInputProvider] = None,
                 input_devices: List[InputDevice] = None, environments: List[Environment] = None,
                 sensor_contexts: List[SensorContext] = None):
        self.__input_contexts: List[InputContext] = input_contexts or []
        self.__ink_input_providers: List[InkInputProvider] = ink_input_providers or []
        self.__input_devices: List[InputDevice] = input_devices or []
        self.__environments: List[Environment] = environments or []
        self.__sensor_contexts: List[SensorContext] = sensor_contexts or []

    def add_ink_device(self, ink_device: InputDevice):
        &#34;&#34;&#34;
        Adding input device.

        Parameters
        ----------
        ink_device: `InputDevice`
            Adds an input device
        &#34;&#34;&#34;
        self.__input_devices.append(ink_device)

    @property
    def devices(self) -&gt; List[InputDevice]:
        &#34;&#34;&#34;
        Input devices. (`List[InputDevice]`)&#34;&#34;&#34;
        return self.__input_devices

    def add_input_context(self, input_context: InputContext):
        &#34;&#34;&#34;
        Adding context.

        Parameters
        ----------
        input_context: `InputContext`
            Input context instance
        &#34;&#34;&#34;
        self.__input_contexts.append(input_context)

    @property
    def input_contexts(self) -&gt; List[InputContext]:
        &#34;&#34;&#34; List of input contexts. (`List[InputContext]`, read-only)&#34;&#34;&#34;
        return self.__input_contexts

    def get_input_context(self, ctx_id: uuid.UUID) -&gt; InputContext:
        &#34;&#34;&#34;
        Returns the InputContext.

        Parameters
        ----------
        ctx_id: `UUID`
            Input context id

        Returns
        -------
        context: InputContext
            Input  context

        Raises
        ------
        InkModelException
            If the `InputContext` for the id is not available.
        &#34;&#34;&#34;
        for ctx in self.input_contexts:
            if ctx.id == ctx_id:
                return ctx
        raise InkModelException(&#39;No input context with id:={}.&#39;.format(ctx_id))

    def get_input_device(self, device_id: uuid.UUID) -&gt; InputDevice:
        &#34;&#34;&#34;
        Returns the InputDevice.

        Parameters
        ----------
        device_id: `UUID`
            Input device id

        Returns
        -------
        context: InputDevice
            Input  device

        Raises
        ------
        InkModelException
            If the `InputDevice` for the id is not available.
        &#34;&#34;&#34;
        for dev in self.devices:
            if dev.id == device_id:
                return dev
        raise InkModelException(&#39;No input device with id:={}.&#39;.format(device_id))

    def get_sensor_context(self, ctx_id: uuid.UUID) -&gt; SensorContext:
        &#34;&#34;&#34;
        Returns the `SensorContext` for the id.

        Parameters
        ----------
        ctx_id: `UUID`input context id

        Returns
        --------
        instance: `SensorContext`
            `SensorContext` instance

        Raises
        ------
        InkModelException
            If the `SensorContext` for the id is not available
        &#34;&#34;&#34;
        for ctx in self.sensor_contexts:
            if ctx.id == ctx_id:
                return ctx
        raise InkModelException(&#39;No sensor context with id:={}.&#39;.format(ctx_id))

    def add_input_provider(self, input_provider: InkInputProvider):
        &#34;&#34;&#34;
        Adding input data provider.

        Parameters
        ----------
        input_provider: `InkInputProvider`
            Input data provider instance
        &#34;&#34;&#34;
        self.__ink_input_providers.append(input_provider)

    @property
    def ink_input_providers(self) -&gt; List[InkInputProvider]:
        &#34;&#34;&#34;List of `InkInputProvider`s. (`List[InkInputProvider]`, read-only)&#34;&#34;&#34;
        return self.__ink_input_providers

    def add_environment(self, environment: Environment):
        &#34;&#34;&#34;
        Adding environment.

        Parameters
        ----------
        environment: Environment
            Environment instance
        &#34;&#34;&#34;
        self.environments.append(environment)

    @property
    def environments(self) -&gt; List[Environment]:
        &#34;&#34;&#34;List of Environments. (`List[Environment]`, read-only)&#34;&#34;&#34;
        return self.__environments

    def add_sensor_context(self, sensor_context: SensorContext):
        &#34;&#34;&#34;
        Adding sensor context.

        Parameters
        ----------
        sensor_context: `SensorContext`
            Instance of `SensorContext`
        &#34;&#34;&#34;
        self.__sensor_contexts.append(sensor_context)

    @property
    def sensor_contexts(self) -&gt; List[SensorContext]:
        &#34;&#34;&#34;List of SensorContexts. (`List[SensorContext]`)&#34;&#34;&#34;
        return self.__sensor_contexts

    def has_configuration(self) -&gt; bool:
        &#34;&#34;&#34;Check if any configuration is available.

        Returns
        -------
        flag: bool
            Flag if either ink input provide, input device, or sensor context are defined
        &#34;&#34;&#34;
        return len(self.input_contexts) &gt; 0 or len(self.sensor_contexts) &gt; 0 or len(self.ink_input_providers) &gt; 0 or \
            len(self.devices) &gt; 0 or len(self.environments)

    def __repr__(self):
        return &#39;&lt;InputContextData: [#context:={}, #providers:={}, #devices:={}, #environments:={}, #sensors:={}]&gt;&#39; \
            .format(len(self.input_contexts), len(self.ink_input_providers), len(self.devices),
                    len(self.environments), len(self.sensor_contexts))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="uim.model.inkinput.inputdata.InputContextRepository.devices"><code class="name">var <span class="ident">devices</span> :Â List[<a title="uim.model.inkinput.inputdata.InputDevice" href="#uim.model.inkinput.inputdata.InputDevice">InputDevice</a>]</code></dt>
<dd>
<div class="desc"><p>Input devices. (<code>List[<a title="uim.model.inkinput.inputdata.InputDevice" href="#uim.model.inkinput.inputdata.InputDevice">InputDevice</a>]</code>)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def devices(self) -&gt; List[InputDevice]:
    &#34;&#34;&#34;
    Input devices. (`List[InputDevice]`)&#34;&#34;&#34;
    return self.__input_devices</code></pre>
</details>
</dd>
<dt id="uim.model.inkinput.inputdata.InputContextRepository.environments"><code class="name">var <span class="ident">environments</span> :Â List[<a title="uim.model.inkinput.inputdata.Environment" href="#uim.model.inkinput.inputdata.Environment">Environment</a>]</code></dt>
<dd>
<div class="desc"><p>List of Environments. (<code>List[<a title="uim.model.inkinput.inputdata.Environment" href="#uim.model.inkinput.inputdata.Environment">Environment</a>]</code>, read-only)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def environments(self) -&gt; List[Environment]:
    &#34;&#34;&#34;List of Environments. (`List[Environment]`, read-only)&#34;&#34;&#34;
    return self.__environments</code></pre>
</details>
</dd>
<dt id="uim.model.inkinput.inputdata.InputContextRepository.ink_input_providers"><code class="name">var <span class="ident">ink_input_providers</span> :Â List[<a title="uim.model.inkinput.inputdata.InkInputProvider" href="#uim.model.inkinput.inputdata.InkInputProvider">InkInputProvider</a>]</code></dt>
<dd>
<div class="desc"><p>List of <code><a title="uim.model.inkinput.inputdata.InkInputProvider" href="#uim.model.inkinput.inputdata.InkInputProvider">InkInputProvider</a></code>s. (<code>List[<a title="uim.model.inkinput.inputdata.InkInputProvider" href="#uim.model.inkinput.inputdata.InkInputProvider">InkInputProvider</a>]</code>, read-only)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ink_input_providers(self) -&gt; List[InkInputProvider]:
    &#34;&#34;&#34;List of `InkInputProvider`s. (`List[InkInputProvider]`, read-only)&#34;&#34;&#34;
    return self.__ink_input_providers</code></pre>
</details>
</dd>
<dt id="uim.model.inkinput.inputdata.InputContextRepository.input_contexts"><code class="name">var <span class="ident">input_contexts</span> :Â List[<a title="uim.model.inkinput.inputdata.InputContext" href="#uim.model.inkinput.inputdata.InputContext">InputContext</a>]</code></dt>
<dd>
<div class="desc"><p>List of input contexts. (<code>List[<a title="uim.model.inkinput.inputdata.InputContext" href="#uim.model.inkinput.inputdata.InputContext">InputContext</a>]</code>, read-only)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def input_contexts(self) -&gt; List[InputContext]:
    &#34;&#34;&#34; List of input contexts. (`List[InputContext]`, read-only)&#34;&#34;&#34;
    return self.__input_contexts</code></pre>
</details>
</dd>
<dt id="uim.model.inkinput.inputdata.InputContextRepository.sensor_contexts"><code class="name">var <span class="ident">sensor_contexts</span> :Â List[<a title="uim.model.inkinput.inputdata.SensorContext" href="#uim.model.inkinput.inputdata.SensorContext">SensorContext</a>]</code></dt>
<dd>
<div class="desc"><p>List of SensorContexts. (<code>List[<a title="uim.model.inkinput.inputdata.SensorContext" href="#uim.model.inkinput.inputdata.SensorContext">SensorContext</a>]</code>)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sensor_contexts(self) -&gt; List[SensorContext]:
    &#34;&#34;&#34;List of SensorContexts. (`List[SensorContext]`)&#34;&#34;&#34;
    return self.__sensor_contexts</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="uim.model.inkinput.inputdata.InputContextRepository.add_environment"><code class="name flex">
<span>def <span class="ident">add_environment</span></span>(<span>self, environment:Â <a title="uim.model.inkinput.inputdata.Environment" href="#uim.model.inkinput.inputdata.Environment">Environment</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Adding environment.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>environment</code></strong> :&ensp;<code><a title="uim.model.inkinput.inputdata.Environment" href="#uim.model.inkinput.inputdata.Environment">Environment</a></code></dt>
<dd>Environment instance</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_environment(self, environment: Environment):
    &#34;&#34;&#34;
    Adding environment.

    Parameters
    ----------
    environment: Environment
        Environment instance
    &#34;&#34;&#34;
    self.environments.append(environment)</code></pre>
</details>
</dd>
<dt id="uim.model.inkinput.inputdata.InputContextRepository.add_ink_device"><code class="name flex">
<span>def <span class="ident">add_ink_device</span></span>(<span>self, ink_device:Â <a title="uim.model.inkinput.inputdata.InputDevice" href="#uim.model.inkinput.inputdata.InputDevice">InputDevice</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Adding input device.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ink_device</code></strong> :&ensp;<code><a title="uim.model.inkinput.inputdata.InputDevice" href="#uim.model.inkinput.inputdata.InputDevice">InputDevice</a></code></dt>
<dd>Adds an input device</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_ink_device(self, ink_device: InputDevice):
    &#34;&#34;&#34;
    Adding input device.

    Parameters
    ----------
    ink_device: `InputDevice`
        Adds an input device
    &#34;&#34;&#34;
    self.__input_devices.append(ink_device)</code></pre>
</details>
</dd>
<dt id="uim.model.inkinput.inputdata.InputContextRepository.add_input_context"><code class="name flex">
<span>def <span class="ident">add_input_context</span></span>(<span>self, input_context:Â <a title="uim.model.inkinput.inputdata.InputContext" href="#uim.model.inkinput.inputdata.InputContext">InputContext</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Adding context.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>input_context</code></strong> :&ensp;<code><a title="uim.model.inkinput.inputdata.InputContext" href="#uim.model.inkinput.inputdata.InputContext">InputContext</a></code></dt>
<dd>Input context instance</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_input_context(self, input_context: InputContext):
    &#34;&#34;&#34;
    Adding context.

    Parameters
    ----------
    input_context: `InputContext`
        Input context instance
    &#34;&#34;&#34;
    self.__input_contexts.append(input_context)</code></pre>
</details>
</dd>
<dt id="uim.model.inkinput.inputdata.InputContextRepository.add_input_provider"><code class="name flex">
<span>def <span class="ident">add_input_provider</span></span>(<span>self, input_provider:Â <a title="uim.model.inkinput.inputdata.InkInputProvider" href="#uim.model.inkinput.inputdata.InkInputProvider">InkInputProvider</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Adding input data provider.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>input_provider</code></strong> :&ensp;<code><a title="uim.model.inkinput.inputdata.InkInputProvider" href="#uim.model.inkinput.inputdata.InkInputProvider">InkInputProvider</a></code></dt>
<dd>Input data provider instance</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_input_provider(self, input_provider: InkInputProvider):
    &#34;&#34;&#34;
    Adding input data provider.

    Parameters
    ----------
    input_provider: `InkInputProvider`
        Input data provider instance
    &#34;&#34;&#34;
    self.__ink_input_providers.append(input_provider)</code></pre>
</details>
</dd>
<dt id="uim.model.inkinput.inputdata.InputContextRepository.add_sensor_context"><code class="name flex">
<span>def <span class="ident">add_sensor_context</span></span>(<span>self, sensor_context:Â <a title="uim.model.inkinput.inputdata.SensorContext" href="#uim.model.inkinput.inputdata.SensorContext">SensorContext</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Adding sensor context.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>sensor_context</code></strong> :&ensp;<code><a title="uim.model.inkinput.inputdata.SensorContext" href="#uim.model.inkinput.inputdata.SensorContext">SensorContext</a></code></dt>
<dd>Instance of <code><a title="uim.model.inkinput.inputdata.SensorContext" href="#uim.model.inkinput.inputdata.SensorContext">SensorContext</a></code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_sensor_context(self, sensor_context: SensorContext):
    &#34;&#34;&#34;
    Adding sensor context.

    Parameters
    ----------
    sensor_context: `SensorContext`
        Instance of `SensorContext`
    &#34;&#34;&#34;
    self.__sensor_contexts.append(sensor_context)</code></pre>
</details>
</dd>
<dt id="uim.model.inkinput.inputdata.InputContextRepository.get_input_context"><code class="name flex">
<span>def <span class="ident">get_input_context</span></span>(<span>self, ctx_id:Â uuid.UUID) â>Â <a title="uim.model.inkinput.inputdata.InputContext" href="#uim.model.inkinput.inputdata.InputContext">InputContext</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns the InputContext.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ctx_id</code></strong> :&ensp;<code>UUID</code></dt>
<dd>Input context id</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>context</code></strong> :&ensp;<code><a title="uim.model.inkinput.inputdata.InputContext" href="#uim.model.inkinput.inputdata.InputContext">InputContext</a></code></dt>
<dd>Input
context</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>InkModelException</code></dt>
<dd>If the <code><a title="uim.model.inkinput.inputdata.InputContext" href="#uim.model.inkinput.inputdata.InputContext">InputContext</a></code> for the id is not available.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_input_context(self, ctx_id: uuid.UUID) -&gt; InputContext:
    &#34;&#34;&#34;
    Returns the InputContext.

    Parameters
    ----------
    ctx_id: `UUID`
        Input context id

    Returns
    -------
    context: InputContext
        Input  context

    Raises
    ------
    InkModelException
        If the `InputContext` for the id is not available.
    &#34;&#34;&#34;
    for ctx in self.input_contexts:
        if ctx.id == ctx_id:
            return ctx
    raise InkModelException(&#39;No input context with id:={}.&#39;.format(ctx_id))</code></pre>
</details>
</dd>
<dt id="uim.model.inkinput.inputdata.InputContextRepository.get_input_device"><code class="name flex">
<span>def <span class="ident">get_input_device</span></span>(<span>self, device_id:Â uuid.UUID) â>Â <a title="uim.model.inkinput.inputdata.InputDevice" href="#uim.model.inkinput.inputdata.InputDevice">InputDevice</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns the InputDevice.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>device_id</code></strong> :&ensp;<code>UUID</code></dt>
<dd>Input device id</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>context</code></strong> :&ensp;<code><a title="uim.model.inkinput.inputdata.InputDevice" href="#uim.model.inkinput.inputdata.InputDevice">InputDevice</a></code></dt>
<dd>Input
device</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>InkModelException</code></dt>
<dd>If the <code><a title="uim.model.inkinput.inputdata.InputDevice" href="#uim.model.inkinput.inputdata.InputDevice">InputDevice</a></code> for the id is not available.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_input_device(self, device_id: uuid.UUID) -&gt; InputDevice:
    &#34;&#34;&#34;
    Returns the InputDevice.

    Parameters
    ----------
    device_id: `UUID`
        Input device id

    Returns
    -------
    context: InputDevice
        Input  device

    Raises
    ------
    InkModelException
        If the `InputDevice` for the id is not available.
    &#34;&#34;&#34;
    for dev in self.devices:
        if dev.id == device_id:
            return dev
    raise InkModelException(&#39;No input device with id:={}.&#39;.format(device_id))</code></pre>
</details>
</dd>
<dt id="uim.model.inkinput.inputdata.InputContextRepository.get_sensor_context"><code class="name flex">
<span>def <span class="ident">get_sensor_context</span></span>(<span>self, ctx_id:Â uuid.UUID) â>Â <a title="uim.model.inkinput.inputdata.SensorContext" href="#uim.model.inkinput.inputdata.SensorContext">SensorContext</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns the <code><a title="uim.model.inkinput.inputdata.SensorContext" href="#uim.model.inkinput.inputdata.SensorContext">SensorContext</a></code> for the id.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ctx_id</code></strong> :&ensp;<code><code>UUID&lt;/code&gt;input context id</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>instance</code></strong> :&ensp;<code><a title="uim.model.inkinput.inputdata.SensorContext" href="#uim.model.inkinput.inputdata.SensorContext">SensorContext</a></code></dt>
<dd><code><a title="uim.model.inkinput.inputdata.SensorContext" href="#uim.model.inkinput.inputdata.SensorContext">SensorContext</a></code> instance</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>InkModelException</code></dt>
<dd>If the <code><a title="uim.model.inkinput.inputdata.SensorContext" href="#uim.model.inkinput.inputdata.SensorContext">SensorContext</a></code> for the id is not available</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_sensor_context(self, ctx_id: uuid.UUID) -&gt; SensorContext:
    &#34;&#34;&#34;
    Returns the `SensorContext` for the id.

    Parameters
    ----------
    ctx_id: `UUID`input context id

    Returns
    --------
    instance: `SensorContext`
        `SensorContext` instance

    Raises
    ------
    InkModelException
        If the `SensorContext` for the id is not available
    &#34;&#34;&#34;
    for ctx in self.sensor_contexts:
        if ctx.id == ctx_id:
            return ctx
    raise InkModelException(&#39;No sensor context with id:={}.&#39;.format(ctx_id))</code></pre>
</details>
</dd>
<dt id="uim.model.inkinput.inputdata.InputContextRepository.has_configuration"><code class="name flex">
<span>def <span class="ident">has_configuration</span></span>(<span>self) â>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if any configuration is available.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>flag</code></strong> :&ensp;<code>bool</code></dt>
<dd>Flag if either ink input provide, input device, or sensor context are defined</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_configuration(self) -&gt; bool:
    &#34;&#34;&#34;Check if any configuration is available.

    Returns
    -------
    flag: bool
        Flag if either ink input provide, input device, or sensor context are defined
    &#34;&#34;&#34;
    return len(self.input_contexts) &gt; 0 or len(self.sensor_contexts) &gt; 0 or len(self.ink_input_providers) &gt; 0 or \
        len(self.devices) &gt; 0 or len(self.environments)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="uim.model.inkinput.inputdata.InputDevice"><code class="flex name class">
<span>class <span class="ident">InputDevice</span></span>
<span>(</span><span>device_id:Â uuid.UUIDÂ =Â None, properties:Â List[Tuple[str,Â str]]Â =Â None)</span>
</code></dt>
<dd>
<div class="desc"><h1 id="inputdevice">InputDevice</h1>
<p>The class <code><a title="uim.model.inkinput.inputdata.InputDevice" href="#uim.model.inkinput.inputdata.InputDevice">InputDevice</a></code> represents the hardware device, on which the sensor data has been produced
(touch enabled mobile device, touch capable monitor, digitizer, etc).
InputDevice with properties.</p>
<p>The properties can contain:</p>
<ul>
<li>Communication Protocol: USB, BTC, BLE, SPP, WIFI,</li>
<li>Communication ID: VID, PID; MAC; UID; COM_PORT,</li>
<li>Device Name: Wacom Intuos Pro M, Apple iPad 8, Samsung GalaxyTab 10,</li>
<li>PenID,</li>
<li>Serial number,</li>
<li>Firmware Version (MCU),</li>
<li>Secondary Firmware Version (BT, WIFI) - different modules provides version for itself,</li>
<li>Orientation: PORTRAIT, LANDSCAPE, PORTRAIT_REVERSE, LANDSCAPE_REVERSE or 0, 90, 180, 270,</li>
<li>Sensor size.</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>device_id</code></strong> :&ensp;<code>UUID</code></dt>
<dd>Internal input device id</dd>
<dt><strong><code>properties</code></strong> :&ensp;<code>List[Tuple[str, str]]</code></dt>
<dd>Properties of the input device</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from uim.model.inkinput.inputdata import InputDevice
&gt;&gt;&gt; # Input device is the sensor (pen tablet, screen, etc.)
&gt;&gt;&gt; input_device: InputDevice = InputDevice()
&gt;&gt;&gt; input_device.properties.append((&quot;dev.id&quot;, &quot;123454321&quot;))
&gt;&gt;&gt; input_device.properties.append((&quot;dev.manufacturer&quot;, &quot;Wacom&quot;))
&gt;&gt;&gt; input_device.properties.append((&quot;dev.model&quot;, &quot;Mobile Studio Pro&quot;))
&gt;&gt;&gt; input_device.properties.append((&quot;dev.cpu&quot;, &quot;Intel&quot;))
&gt;&gt;&gt; input_device.properties.append((&quot;dev.graphics.display&quot;, &quot;Dell 1920x1080 32bit&quot;))
&gt;&gt;&gt; input_device.properties.append((&quot;dev.graphics.adapter&quot;, &quot;NVidia&quot;))
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InputDevice(HashIdentifier):
    &#34;&#34;&#34;
    InputDevice
    ===========
    The class `InputDevice` represents the hardware device, on which the sensor data has been produced
    (touch enabled mobile device, touch capable monitor, digitizer, etc).
    InputDevice with properties.

    The properties can contain:

      - Communication Protocol: USB, BTC, BLE, SPP, WIFI,
      - Communication ID: VID, PID; MAC; UID; COM_PORT,
      - Device Name: Wacom Intuos Pro M, Apple iPad 8, Samsung GalaxyTab 10,
      - PenID,
      - Serial number,
      - Firmware Version (MCU),
      - Secondary Firmware Version (BT, WIFI) - different modules provides version for itself,
      - Orientation: PORTRAIT, LANDSCAPE, PORTRAIT_REVERSE, LANDSCAPE_REVERSE or 0, 90, 180, 270,
      - Sensor size.

    Parameters
    ----------
    device_id: `UUID`
        Internal input device id
    properties: List[Tuple[str, str]]
        Properties of the input device

    Examples
    --------
    &gt;&gt;&gt; from uim.model.inkinput.inputdata import InputDevice
    &gt;&gt;&gt; # Input device is the sensor (pen tablet, screen, etc.)
    &gt;&gt;&gt; input_device: InputDevice = InputDevice()
    &gt;&gt;&gt; input_device.properties.append((&#34;dev.id&#34;, &#34;123454321&#34;))
    &gt;&gt;&gt; input_device.properties.append((&#34;dev.manufacturer&#34;, &#34;Wacom&#34;))
    &gt;&gt;&gt; input_device.properties.append((&#34;dev.model&#34;, &#34;Mobile Studio Pro&#34;))
    &gt;&gt;&gt; input_device.properties.append((&#34;dev.cpu&#34;, &#34;Intel&#34;))
    &gt;&gt;&gt; input_device.properties.append((&#34;dev.graphics.display&#34;, &#34;Dell 1920x1080 32bit&#34;))
    &gt;&gt;&gt; input_device.properties.append((&#34;dev.graphics.adapter&#34;, &#34;NVidia&#34;))
    &#34;&#34;&#34;

    def __init__(self, device_id: uuid.UUID = None, properties: List[Tuple[str, str]] = None):
        super().__init__(device_id)
        self.__properties: List[Tuple[str, str]] = properties or []

    @property
    def properties(self) -&gt; List[Tuple[str, str]]:
        &#34;&#34;&#34;Properties of the InputDevice. (` List[Tuple[str, str]]`, read-only)&#34;&#34;&#34;
        return self.__properties

    def add_property(self, key: str, value):
        &#34;&#34;&#34;Adding property.

        Parameters
        ----------
        key: str
            Name of the property
        value: str
            Value of the property
        &#34;&#34;&#34;
        self.__properties.append((key, value))

    def __tokenize__(self):
        return [&#39;InputDevice&#39;, self.properties]

    def __repr__(self):
        return &#39;&lt;InputDevice : [id:={}, num properties:={}&gt;&#39;.format(self.id, self.properties)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="uim.model.base.HashIdentifier" href="../base.html#uim.model.base.HashIdentifier">HashIdentifier</a></li>
<li><a title="uim.model.base.Identifier" href="../base.html#uim.model.base.Identifier">Identifier</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="uim.model.inkinput.inputdata.InputDevice.SEPARATOR"><code class="name">var <span class="ident">SEPARATOR</span> :Â str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="uim.model.inkinput.inputdata.InputDevice.properties"><code class="name">var <span class="ident">properties</span> :Â List[Tuple[str,Â str]]</code></dt>
<dd>
<div class="desc"><p>Properties of the InputDevice. (<code> List[Tuple[str, str]]</code>, read-only)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def properties(self) -&gt; List[Tuple[str, str]]:
    &#34;&#34;&#34;Properties of the InputDevice. (` List[Tuple[str, str]]`, read-only)&#34;&#34;&#34;
    return self.__properties</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="uim.model.inkinput.inputdata.InputDevice.add_property"><code class="name flex">
<span>def <span class="ident">add_property</span></span>(<span>self, key:Â str, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Adding property.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the property</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>str</code></dt>
<dd>Value of the property</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_property(self, key: str, value):
    &#34;&#34;&#34;Adding property.

    Parameters
    ----------
    key: str
        Name of the property
    value: str
        Value of the property
    &#34;&#34;&#34;
    self.__properties.append((key, value))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="uim.model.base.HashIdentifier" href="../base.html#uim.model.base.HashIdentifier">HashIdentifier</a></b></code>:
<ul class="hlist">
<li><code><a title="uim.model.base.HashIdentifier.from_bytes" href="../base.html#uim.model.base.Identifier.from_bytes">from_bytes</a></code></li>
<li><code><a title="uim.model.base.HashIdentifier.id" href="../base.html#uim.model.base.Identifier.id">id</a></code></li>
<li><code><a title="uim.model.base.HashIdentifier.id_h_form" href="../base.html#uim.model.base.Identifier.id_h_form">id_h_form</a></code></li>
<li><code><a title="uim.model.base.HashIdentifier.id_s_form" href="../base.html#uim.model.base.Identifier.id_s_form">id_s_form</a></code></li>
<li><code><a title="uim.model.base.HashIdentifier.str_to_uimid" href="../base.html#uim.model.base.Identifier.str_to_uimid">str_to_uimid</a></code></li>
<li><code><a title="uim.model.base.HashIdentifier.uimid_to_h_form" href="../base.html#uim.model.base.Identifier.uimid_to_h_form">uimid_to_h_form</a></code></li>
<li><code><a title="uim.model.base.HashIdentifier.uimid_to_s_form" href="../base.html#uim.model.base.Identifier.uimid_to_s_form">uimid_to_s_form</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="uim.model.inkinput.inputdata.SensorChannel"><code class="flex name class">
<span>class <span class="ident">SensorChannel</span></span>
<span>(</span><span>channel_id:Â uuid.UUIDÂ =Â None, channel_type:Â <a title="uim.model.inkinput.inputdata.InkSensorType" href="#uim.model.inkinput.inputdata.InkSensorType">InkSensorType</a>Â =Â None, metric:Â <a title="uim.model.inkinput.inputdata.InkSensorMetricType" href="#uim.model.inkinput.inputdata.InkSensorMetricType">InkSensorMetricType</a>Â =Â None, resolution:Â floatÂ =Â 1.0, channel_min:Â floatÂ =Â 0.0, channel_max:Â floatÂ =Â 0.0, precision:Â intÂ =Â 2, index:Â intÂ =Â 0, name:Â strÂ =Â None, data_type:Â <a title="uim.model.inkinput.inputdata.DataType" href="#uim.model.inkinput.inputdata.DataType">DataType</a>Â =Â DataType.FLOAT32, ink_input_provider_id:Â uuid.UUIDÂ =Â None, input_device_id:Â uuid.UUIDÂ =Â None)</span>
</code></dt>
<dd>
<div class="desc"><h1 id="sensorchannel">SensorChannel</h1>
<p>The <code><a title="uim.model.inkinput.inputdata.SensorChannel" href="#uim.model.inkinput.inputdata.SensorChannel">SensorChannel</a></code> represents a generic sensor channel definition, which has the following properties:</p>
<ul>
<li><strong>type</strong> - URI uniquely identifying the type of the sensor channel</li>
<li><strong>metric</strong> - The type of the data to the SI metric system</li>
<li><strong>resolution</strong> - A factor multiplication value (power of 10) used to convert the stored data values to the
specified SI metric</li>
<li><strong>min, max</strong> - Lower and upper bounds of the reported values range</li>
<li><strong>precision</strong> - The precision of the sensor when reporting floating-point values (defined as an int value,
used as a power of 10 during the serialization/deserialization phase)</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel_id</code></strong> :&ensp;<code>UUID</code></dt>
<dd>Sensor channel descriptor. If no channel_id is set the MD5 hashing is generating the id</dd>
<dt>channel_type:<code><a title="uim.model.inkinput.inputdata.InkSensorType" href="#uim.model.inkinput.inputdata.InkSensorType">InkSensorType</a></code></dt>
<dt>Indicates metric used in calculating the resolution for the data item.</dt>
<dt><strong><code>metric</code></strong> :&ensp;<code><a title="uim.model.inkinput.inputdata.InkSensorMetricType" href="#uim.model.inkinput.inputdata.InkSensorMetricType">InkSensorMetricType</a></code></dt>
<dd>Indicates metric used in calculating the resolution for the data item.</dd>
<dt><strong><code>resolution</code></strong> :&ensp;<code>float</code></dt>
<dd>Is a decimal number giving the number of data item increments. Per physical unit., e.g. if the
physical unit is in m and input data units. Resolution is 100000, then the value 150 would be
0.0015 m.</dd>
<dt><strong><code>channel_min</code></strong> :&ensp;<code>float</code></dt>
<dd>Minimal value of the channel</dd>
<dt><strong><code>channel_max</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximal value of the channel</dd>
<dt><strong><code>precision</code></strong> :&ensp;<code>int</code></dt>
<dd>Precision of integer encoding, needed for encoded float values</dd>
<dt><strong><code>index</code></strong> :&ensp;<code>int</code></dt>
<dd>Index of the channel</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the channel</dd>
<dt><strong><code>data_type</code></strong> :&ensp;<code><a title="uim.model.inkinput.inputdata.DataType" href="#uim.model.inkinput.inputdata.DataType">DataType</a></code></dt>
<dd>Type of data within the channel</dd>
<dt><strong><code>ink_input_provider_id</code></strong> :&ensp;<code>UUID</code></dt>
<dd>Reference to the ink input provider</dd>
<dt><strong><code>input_device_id</code></strong> :&ensp;<code>UUID</code></dt>
<dd>Reference to the ink input device</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from uim.model.inkinput.inputdata import SensorChannel, InkSensorType
&gt;&gt;&gt; # Create a group of sensor channels
&gt;&gt;&gt; sensor_channels_tablet: list = [
&gt;&gt;&gt;     SensorChannel(channel_type=InkSensorType.TIMESTAMP, metric=InkSensorMetricType.TIME, resolution=1.0),
&gt;&gt;&gt;     SensorChannel(channel_type=InkSensorType.X, metric=InkSensorMetricType.LENGTH, resolution=1.0),
&gt;&gt;&gt;     SensorChannel(channel_type=InkSensorType.Y, metric=InkSensorMetricType.LENGTH, resolution=1.0)
&gt;&gt;&gt; ]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SensorChannel(HashIdentifier):
    &#34;&#34;&#34;
    SensorChannel
    =============
    The `SensorChannel` represents a generic sensor channel definition, which has the following properties:

    - **type** - URI uniquely identifying the type of the sensor channel
    - **metric** - The type of the data to the SI metric system
    - **resolution** - A factor multiplication value (power of 10) used to convert the stored data values to the
                      specified SI metric
    - **min, max** - Lower and upper bounds of the reported values range
    - **precision** - The precision of the sensor when reporting floating-point values (defined as an int value,
                      used as a power of 10 during the serialization/deserialization phase)
    
    Parameters
    ----------
    channel_id: `UUID`
        Sensor channel descriptor. If no channel_id is set the MD5 hashing is generating the id
    channel_type:`InkSensorType`
        Indicates metric used in calculating the resolution for the data item.
    metric: `InkSensorMetricType`
        Indicates metric used in calculating the resolution for the data item.
    resolution: `float`
        Is a decimal number giving the number of data item increments. Per physical unit., e.g. if the
        physical unit is in m and input data units. Resolution is 100000, then the value 150 would be
        0.0015 m.
    channel_min: `float`
        Minimal value of the channel
    channel_max: `float`
        Maximal value of the channel
    precision: `int`
        Precision of integer encoding, needed for encoded float values
    index: `int`
        Index of the channel
    name: `str`
        Name of the channel
    data_type: `DataType`
        Type of data within the channel
    ink_input_provider_id: `UUID`
        Reference to the ink input provider
    input_device_id: `UUID`
        Reference to the ink input device

    Examples
    --------
    &gt;&gt;&gt; from uim.model.inkinput.inputdata import SensorChannel, InkSensorType
    &gt;&gt;&gt; # Create a group of sensor channels
    &gt;&gt;&gt; sensor_channels_tablet: list = [
    &gt;&gt;&gt;     SensorChannel(channel_type=InkSensorType.TIMESTAMP, metric=InkSensorMetricType.TIME, resolution=1.0),
    &gt;&gt;&gt;     SensorChannel(channel_type=InkSensorType.X, metric=InkSensorMetricType.LENGTH, resolution=1.0),
    &gt;&gt;&gt;     SensorChannel(channel_type=InkSensorType.Y, metric=InkSensorMetricType.LENGTH, resolution=1.0)
    &gt;&gt;&gt; ]
    &#34;&#34;&#34;

    def __init__(self, channel_id: uuid.UUID = None,
                 channel_type: InkSensorType = None, metric: InkSensorMetricType = None,
                 resolution: float = 1., channel_min: float = 0., channel_max: float = 0.,
                 precision: int = 2, index: int = 0, name: str = None, data_type: DataType = DataType.FLOAT32,
                 ink_input_provider_id: uuid.UUID = None, input_device_id: uuid.UUID = None):
        super().__init__(channel_id)
        self.__type: InkSensorType = channel_type
        self.__metric: InkSensorMetricType = metric
        self.__resolution: float = float(resolution)
        self.__min: float = float(channel_min)
        self.__max: float = float(channel_max)
        self.__precision: int = precision
        self.__index: int = index
        self.__name: str = name
        self.__data_type: DataType = data_type
        self.__ink_input_provider: uuid.UUID = ink_input_provider_id
        self.__input_device_id: uuid.UUID = input_device_id

    def __tokenize__(self) -&gt; list:
        return [&#34;SensorChannel&#34;, self.__ink_input_provider, self.__input_device_id, TOKEN_MAP[self.type],
                TOKEN_MAP[self.metric], self.resolution, self.min, self.max, self.precision]

    @property
    def ink_input_provider(self) -&gt; uuid.UUID:
        &#34;&#34;&#34;Reference to the `InkInputProvider` of the channel. (`UUID`)&#34;&#34;&#34;
        return self.__ink_input_provider

    @ink_input_provider.setter
    def ink_input_provider(self, value: uuid.UUID):
        self.__ink_input_provider = value

    @property
    def input_device_id(self) -&gt; uuid.UUID:
        &#34;&#34;&#34;Reference to the `InputDevice` of the channel. (`UUID`)&#34;&#34;&#34;
        return self.__input_device_id

    @input_device_id.setter
    def input_device_id(self, value: uuid.UUID):
        self.__input_device_id = value

    @property
    def type(self) -&gt; InkSensorType:
        &#34;&#34;&#34;Type of the sensor channel.(`InkSensorType`, read-only) &#34;&#34;&#34;
        return self.__type

    @property
    def metric(self) -&gt; InkSensorMetricType:
        &#34;&#34;&#34;Metric of the sensor channel. (`InkSensorMetricType`)&#34;&#34;&#34;
        return self.__metric

    @property
    def resolution(self) -&gt; float:
        &#34;&#34;&#34;Resolution. Is a decimal number giving the number of data item increments. Per physical unit., e.g. if the
        physical unit is in m and input data units. (`float`, read-only)&#34;&#34;&#34;
        return self.__resolution

    @property
    def min(self) -&gt; float:
        &#34;&#34;&#34;Minimal value of the channel. (`float`, read-only)&#34;&#34;&#34;
        return self.__min

    @property
    def max(self) -&gt; float:
        &#34;&#34;&#34;Maximum value of the channel. (`float`, read-only)&#34;&#34;&#34;
        return self.__max

    @property
    def precision(self) -&gt; int:
        &#34;&#34;&#34;Precision of integer encoding, needed for encoded float values. (`int`, read-only)&#34;&#34;&#34;
        return self.__precision

    @property
    def index(self) -&gt; int:
        &#34;&#34;&#34;Index within a list of values, e.g. used in InkML encoding. (`int`, read-only)&#34;&#34;&#34;
        return self.__index

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;Name of the channel. (`str`, read-only)&#34;&#34;&#34;
        return self.__name

    @property
    def data_type(self) -&gt; DataType:
        &#34;&#34;&#34; Data type encoding. (`DataType`, read-only)&#34;&#34;&#34;
        return self.__data_type

    def __repr__(self):
        return &#39;&lt;SensorChannel: [id:={}, type:={}, metric:={}, resolution:={}, min:={}, max:={}, &#39; \
               &#39;precision:={}, index:={}, name:={}&gt;&#39;.format(self.id.hex, self.__type, self.__metric, self.__resolution,
                                                            self.__min, self.__max, self.__precision, self.__index,
                                                            self.__name)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="uim.model.base.HashIdentifier" href="../base.html#uim.model.base.HashIdentifier">HashIdentifier</a></li>
<li><a title="uim.model.base.Identifier" href="../base.html#uim.model.base.Identifier">Identifier</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="uim.model.inkinput.inputdata.SensorChannel.SEPARATOR"><code class="name">var <span class="ident">SEPARATOR</span> :Â str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="uim.model.inkinput.inputdata.SensorChannel.data_type"><code class="name">var <span class="ident">data_type</span> :Â <a title="uim.model.inkinput.inputdata.DataType" href="#uim.model.inkinput.inputdata.DataType">DataType</a></code></dt>
<dd>
<div class="desc"><p>Data type encoding. (<code><a title="uim.model.inkinput.inputdata.DataType" href="#uim.model.inkinput.inputdata.DataType">DataType</a></code>, read-only)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data_type(self) -&gt; DataType:
    &#34;&#34;&#34; Data type encoding. (`DataType`, read-only)&#34;&#34;&#34;
    return self.__data_type</code></pre>
</details>
</dd>
<dt id="uim.model.inkinput.inputdata.SensorChannel.index"><code class="name">var <span class="ident">index</span> :Â int</code></dt>
<dd>
<div class="desc"><p>Index within a list of values, e.g. used in InkML encoding. (<code>int</code>, read-only)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def index(self) -&gt; int:
    &#34;&#34;&#34;Index within a list of values, e.g. used in InkML encoding. (`int`, read-only)&#34;&#34;&#34;
    return self.__index</code></pre>
</details>
</dd>
<dt id="uim.model.inkinput.inputdata.SensorChannel.ink_input_provider"><code class="name">var <span class="ident">ink_input_provider</span> :Â uuid.UUID</code></dt>
<dd>
<div class="desc"><p>Reference to the <code><a title="uim.model.inkinput.inputdata.InkInputProvider" href="#uim.model.inkinput.inputdata.InkInputProvider">InkInputProvider</a></code> of the channel. (<code>UUID</code>)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ink_input_provider(self) -&gt; uuid.UUID:
    &#34;&#34;&#34;Reference to the `InkInputProvider` of the channel. (`UUID`)&#34;&#34;&#34;
    return self.__ink_input_provider</code></pre>
</details>
</dd>
<dt id="uim.model.inkinput.inputdata.SensorChannel.input_device_id"><code class="name">var <span class="ident">input_device_id</span> :Â uuid.UUID</code></dt>
<dd>
<div class="desc"><p>Reference to the <code><a title="uim.model.inkinput.inputdata.InputDevice" href="#uim.model.inkinput.inputdata.InputDevice">InputDevice</a></code> of the channel. (<code>UUID</code>)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def input_device_id(self) -&gt; uuid.UUID:
    &#34;&#34;&#34;Reference to the `InputDevice` of the channel. (`UUID`)&#34;&#34;&#34;
    return self.__input_device_id</code></pre>
</details>
</dd>
<dt id="uim.model.inkinput.inputdata.SensorChannel.max"><code class="name">var <span class="ident">max</span> :Â float</code></dt>
<dd>
<div class="desc"><p>Maximum value of the channel. (<code>float</code>, read-only)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def max(self) -&gt; float:
    &#34;&#34;&#34;Maximum value of the channel. (`float`, read-only)&#34;&#34;&#34;
    return self.__max</code></pre>
</details>
</dd>
<dt id="uim.model.inkinput.inputdata.SensorChannel.metric"><code class="name">var <span class="ident">metric</span> :Â <a title="uim.model.inkinput.inputdata.InkSensorMetricType" href="#uim.model.inkinput.inputdata.InkSensorMetricType">InkSensorMetricType</a></code></dt>
<dd>
<div class="desc"><p>Metric of the sensor channel. (<code><a title="uim.model.inkinput.inputdata.InkSensorMetricType" href="#uim.model.inkinput.inputdata.InkSensorMetricType">InkSensorMetricType</a></code>)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def metric(self) -&gt; InkSensorMetricType:
    &#34;&#34;&#34;Metric of the sensor channel. (`InkSensorMetricType`)&#34;&#34;&#34;
    return self.__metric</code></pre>
</details>
</dd>
<dt id="uim.model.inkinput.inputdata.SensorChannel.min"><code class="name">var <span class="ident">min</span> :Â float</code></dt>
<dd>
<div class="desc"><p>Minimal value of the channel. (<code>float</code>, read-only)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def min(self) -&gt; float:
    &#34;&#34;&#34;Minimal value of the channel. (`float`, read-only)&#34;&#34;&#34;
    return self.__min</code></pre>
</details>
</dd>
<dt id="uim.model.inkinput.inputdata.SensorChannel.name"><code class="name">var <span class="ident">name</span> :Â str</code></dt>
<dd>
<div class="desc"><p>Name of the channel. (<code>str</code>, read-only)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; str:
    &#34;&#34;&#34;Name of the channel. (`str`, read-only)&#34;&#34;&#34;
    return self.__name</code></pre>
</details>
</dd>
<dt id="uim.model.inkinput.inputdata.SensorChannel.precision"><code class="name">var <span class="ident">precision</span> :Â int</code></dt>
<dd>
<div class="desc"><p>Precision of integer encoding, needed for encoded float values. (<code>int</code>, read-only)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def precision(self) -&gt; int:
    &#34;&#34;&#34;Precision of integer encoding, needed for encoded float values. (`int`, read-only)&#34;&#34;&#34;
    return self.__precision</code></pre>
</details>
</dd>
<dt id="uim.model.inkinput.inputdata.SensorChannel.resolution"><code class="name">var <span class="ident">resolution</span> :Â float</code></dt>
<dd>
<div class="desc"><p>Resolution. Is a decimal number giving the number of data item increments. Per physical unit., e.g. if the
physical unit is in m and input data units. (<code>float</code>, read-only)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def resolution(self) -&gt; float:
    &#34;&#34;&#34;Resolution. Is a decimal number giving the number of data item increments. Per physical unit., e.g. if the
    physical unit is in m and input data units. (`float`, read-only)&#34;&#34;&#34;
    return self.__resolution</code></pre>
</details>
</dd>
<dt id="uim.model.inkinput.inputdata.SensorChannel.type"><code class="name">var <span class="ident">type</span> :Â <a title="uim.model.inkinput.inputdata.InkSensorType" href="#uim.model.inkinput.inputdata.InkSensorType">InkSensorType</a></code></dt>
<dd>
<div class="desc"><p>Type of the sensor channel.(<code><a title="uim.model.inkinput.inputdata.InkSensorType" href="#uim.model.inkinput.inputdata.InkSensorType">InkSensorType</a></code>, read-only)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def type(self) -&gt; InkSensorType:
    &#34;&#34;&#34;Type of the sensor channel.(`InkSensorType`, read-only) &#34;&#34;&#34;
    return self.__type</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="uim.model.base.HashIdentifier" href="../base.html#uim.model.base.HashIdentifier">HashIdentifier</a></b></code>:
<ul class="hlist">
<li><code><a title="uim.model.base.HashIdentifier.from_bytes" href="../base.html#uim.model.base.Identifier.from_bytes">from_bytes</a></code></li>
<li><code><a title="uim.model.base.HashIdentifier.id" href="../base.html#uim.model.base.Identifier.id">id</a></code></li>
<li><code><a title="uim.model.base.HashIdentifier.id_h_form" href="../base.html#uim.model.base.Identifier.id_h_form">id_h_form</a></code></li>
<li><code><a title="uim.model.base.HashIdentifier.id_s_form" href="../base.html#uim.model.base.Identifier.id_s_form">id_s_form</a></code></li>
<li><code><a title="uim.model.base.HashIdentifier.str_to_uimid" href="../base.html#uim.model.base.Identifier.str_to_uimid">str_to_uimid</a></code></li>
<li><code><a title="uim.model.base.HashIdentifier.uimid_to_h_form" href="../base.html#uim.model.base.Identifier.uimid_to_h_form">uimid_to_h_form</a></code></li>
<li><code><a title="uim.model.base.HashIdentifier.uimid_to_s_form" href="../base.html#uim.model.base.Identifier.uimid_to_s_form">uimid_to_s_form</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="uim.model.inkinput.inputdata.SensorChannelsContext"><code class="flex name class">
<span>class <span class="ident">SensorChannelsContext</span></span>
<span>(</span><span>sid:Â uuid.UUIDÂ =Â None, channels:Â List[<a title="uim.model.inkinput.inputdata.SensorChannel" href="#uim.model.inkinput.inputdata.SensorChannel">SensorChannel</a>]Â =Â None, sampling_rate_hint:Â intÂ =Â None, latency:Â intÂ =Â None, ink_input_provider_id:Â uuid.UUIDÂ =Â None, input_device_id:Â uuid.UUIDÂ =Â None)</span>
</code></dt>
<dd>
<div class="desc"><h1 id="sensorchannelscontext">SensorChannelsContext</h1>
<p>The class <code><a title="uim.model.inkinput.inputdata.SensorChannelsContext" href="#uim.model.inkinput.inputdata.SensorChannelsContext">SensorChannelsContext</a></code> is defined as an unique combination of:</p>
<pre><code>- An &lt;code&gt;&lt;a title="uim.model.inkinput.inputdata.InkInputProvider" href="#uim.model.inkinput.inputdata.InkInputProvider"&gt;InkInputProvider&lt;/a&gt;&lt;/code&gt; instance
- An &lt;code&gt;&lt;a title="uim.model.inkinput.inputdata.InputDevice" href="#uim.model.inkinput.inputdata.InputDevice"&gt;InputDevice&lt;/a&gt;&lt;/code&gt; instance and
- A list of sensor channel definitions (by holding a collection of &lt;code&gt;&lt;a title="uim.model.inkinput.inputdata.SensorChannel" href="#uim.model.inkinput.inputdata.SensorChannel"&gt;SensorChannel&lt;/a&gt;&lt;/code&gt; instances)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>sid</code></strong> :&ensp;<code>str</code></dt>
<dd>Group that provides X and Y channels is the one that is referred from StrokeRelation and it's id could be
always XY.</dd>
<dt><strong><code>channels</code></strong> :&ensp;<code>List[<a title="uim.model.inkinput.inputdata.SensorChannel" href="#uim.model.inkinput.inputdata.SensorChannel">SensorChannel</a>]</code></dt>
<dd>A list of sensor channel descriptors.</dd>
<dt><strong><code>sampling_rate_hint</code></strong> :&ensp;<code>int</code></dt>
<dd>Optional hint for the intended sampling rate of the sensor.[Optional].</dd>
<dt><strong><code>latency</code></strong> :&ensp;<code>int</code></dt>
<dd>Latency measure in milliseconds [Optional].</dd>
<dt><strong><code>ink_input_provider_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Reference to the 'InkInputProvider`.</dd>
<dt><strong><code>input_device_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Reference to the <code><a title="uim.model.inkinput.inputdata.InputDevice" href="#uim.model.inkinput.inputdata.InputDevice">InputDevice</a></code>.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Once a SensorChannelsContext instance is added to the InputContext repository, it is considered immutable.
The SensorChannelsContext identifier is unique in the scope of the InkModel and is auto-generated based on the
MD5-hash based Unique Identifier Generation Algorithm using tag "SensorChannelsContext" and the
following components:</p>
<pre><code>- Identifier of the InkInputProvider instance
- Identifier of the InputDevice instance
- List of the identifiers of the SensorChannel instances contained within the current SensorChannelsContext
</code></pre>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from uim.model.inkinput.inputdata import InkInputProvider, InkInputType, SensorChannel,     &gt;&gt;&gt;       InkSensorType, InkSensorMetricType, SensorChannelsContext, SensorContext
&gt;&gt;&gt; # Ink input provider can be pen, mouse or touch.
&gt;&gt;&gt; provider: InkInputProvider = InkInputProvider(input_type=InkInputType.MOUSE)
&gt;&gt;&gt; provider.properties.append((&quot;pen.id&quot;, &quot;1234567&quot;))
&gt;&gt;&gt;
&gt;&gt;&gt; # We can create an additional input device, for example one providing pressure via Bluetooth
&gt;&gt;&gt; input_device: InputDevice = InputDevice()
&gt;&gt;&gt; input_device.properties.append((&quot;dev.id&quot;, &quot;345456567&quot;))
&gt;&gt;&gt; input_device.properties.append((&quot;dev.manufacturer&quot;, &quot;Apple&quot;))
&gt;&gt;&gt;
&gt;&gt;&gt; # Create a group of sensor channels
&gt;&gt;&gt; sensor_channels_tablet: list = [
&gt;&gt;&gt;     SensorChannel(channel_type=InkSensorType.TIMESTAMP, metric=InkSensorMetricType.TIME, resolution=1.0),
&gt;&gt;&gt;     SensorChannel(channel_type=InkSensorType.X, metric=InkSensorMetricType.LENGTH, resolution=1.0),
&gt;&gt;&gt;     SensorChannel(channel_type=InkSensorType.Y, metric=InkSensorMetricType.LENGTH, resolution=1.0)
&gt;&gt;&gt; ]
&gt;&gt;&gt;
&gt;&gt;&gt; scc_tablet: SensorChannelsContext = SensorChannelsContext(channels=sensor_channels_tablet,
&gt;&gt;&gt;                                                           ink_input_provider_id=provider.id,
&gt;&gt;&gt;                                                           input_device_id=input_device.id)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SensorChannelsContext(HashIdentifier):
    &#34;&#34;&#34;
    SensorChannelsContext
    =====================

    The class `SensorChannelsContext` is defined as an unique combination of:
    
        - An `InkInputProvider` instance
        - An `InputDevice` instance and
        - A list of sensor channel definitions (by holding a collection of `SensorChannel` instances)
        
    Parameters
    ----------
    sid: `str`
        Group that provides X and Y channels is the one that is referred from StrokeRelation and it&#39;s id could be
        always XY.
    channels: `List[SensorChannel]`
        A list of sensor channel descriptors.
    sampling_rate_hint: `int`
        Optional hint for the intended sampling rate of the sensor.[Optional].
    latency: `int`
        Latency measure in milliseconds [Optional].
    ink_input_provider_id: `str`
        Reference to the &#39;InkInputProvider`.
    input_device_id: `str`
        Reference to the `InputDevice`.

    Notes
    ------
    Once a SensorChannelsContext instance is added to the InputContext repository, it is considered immutable.
    The SensorChannelsContext identifier is unique in the scope of the InkModel and is auto-generated based on the
    MD5-hash based Unique Identifier Generation Algorithm using tag &#34;SensorChannelsContext&#34; and the
    following components:

        - Identifier of the InkInputProvider instance
        - Identifier of the InputDevice instance
        - List of the identifiers of the SensorChannel instances contained within the current SensorChannelsContext

    Examples
    --------
    &gt;&gt;&gt; from uim.model.inkinput.inputdata import InkInputProvider, InkInputType, SensorChannel, \
    &gt;&gt;&gt;       InkSensorType, InkSensorMetricType, SensorChannelsContext, SensorContext
    &gt;&gt;&gt; # Ink input provider can be pen, mouse or touch.
    &gt;&gt;&gt; provider: InkInputProvider = InkInputProvider(input_type=InkInputType.MOUSE)
    &gt;&gt;&gt; provider.properties.append((&#34;pen.id&#34;, &#34;1234567&#34;))
    &gt;&gt;&gt;
    &gt;&gt;&gt; # We can create an additional input device, for example one providing pressure via Bluetooth
    &gt;&gt;&gt; input_device: InputDevice = InputDevice()
    &gt;&gt;&gt; input_device.properties.append((&#34;dev.id&#34;, &#34;345456567&#34;))
    &gt;&gt;&gt; input_device.properties.append((&#34;dev.manufacturer&#34;, &#34;Apple&#34;))
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Create a group of sensor channels
    &gt;&gt;&gt; sensor_channels_tablet: list = [
    &gt;&gt;&gt;     SensorChannel(channel_type=InkSensorType.TIMESTAMP, metric=InkSensorMetricType.TIME, resolution=1.0),
    &gt;&gt;&gt;     SensorChannel(channel_type=InkSensorType.X, metric=InkSensorMetricType.LENGTH, resolution=1.0),
    &gt;&gt;&gt;     SensorChannel(channel_type=InkSensorType.Y, metric=InkSensorMetricType.LENGTH, resolution=1.0)
    &gt;&gt;&gt; ]
    &gt;&gt;&gt;
    &gt;&gt;&gt; scc_tablet: SensorChannelsContext = SensorChannelsContext(channels=sensor_channels_tablet,
    &gt;&gt;&gt;                                                           ink_input_provider_id=provider.id,
    &gt;&gt;&gt;                                                           input_device_id=input_device.id)
    &#34;&#34;&#34;

    def __init__(self, sid: uuid.UUID = None, channels: List[SensorChannel] = None, sampling_rate_hint: int = None,
                 latency: int = None, ink_input_provider_id: uuid.UUID = None, input_device_id: uuid.UUID = None):
        super().__init__(sid)
        self.__channels: List[SensorChannel] = channels or []
        self.__sampling_rate_hint: int = sampling_rate_hint
        self.__latency: int = latency
        self.__ink_input_provider_id: uuid.UUID = ink_input_provider_id
        self.__input_device_id: uuid.UUID = input_device_id
        # Set bind channels to input provider and input device
        for c in self.__channels:
            c.ink_input_provider = ink_input_provider_id
            c.input_device_id = input_device_id

    def __tokenize__(self) -&gt; list:
        token: list = [&#34;SensorChannelsContext&#34;]
        token.extend([c.id for c in self.channels])
        token.append(self.sampling_rate)
        token.append(self.latency)
        token.append(self.input_provider_id)
        token.append(self.input_device_id)
        return token

    @property
    def channels(self) -&gt; List[SensorChannel]:
        &#34;&#34;&#34;Array of the `SensorChannel`s associated with the context. (`List[SensorChannel]`, read-only) &#34;&#34;&#34;
        return self.__channels

    @property
    def sampling_rate(self) -&gt; int:
        &#34;&#34;&#34;Hint for sampling rate valid for all channels. (`int`, read-only)&#34;&#34;&#34;
        return self.__sampling_rate_hint

    @property
    def latency(self) -&gt; int:
        &#34;&#34;&#34;Gets the latency measurement in milliseconds. (`int`, read-only)&#34;&#34;&#34;
        return self.__latency

    @property
    def input_provider_id(self) -&gt; uuid.UUID:
        &#34;&#34;&#34;Reference id to the ink `InputProvider` that produces the ink. (`UUID`, read-only)&#34;&#34;&#34;
        return self.__ink_input_provider_id

    @property
    def input_device_id(self) -&gt; uuid.UUID:
        &#34;&#34;&#34;Reference to `InkInputDevice`. (`UUID`, read-only)&#34;&#34;&#34;
        return self.__input_device_id

    def add_sensor_channel(self, channel: SensorChannel):
        &#34;&#34;&#34;
        Adding a channel.

        Parameters
        ----------
        channel: `SensorChannel`
            sensor channel
        &#34;&#34;&#34;
        self.__channels.append(channel)

    def has_channel_type(self, channel_type: InkSensorType):
        &#34;&#34;&#34;
        Checks if channel types is available.

        Parameters
        ----------
        channel_type: `InkSensorType`
            sensor type

        Returns
        -------
        flag: `boolean`
            True if available, False if not
        &#34;&#34;&#34;
        for c in self.channels:
            if c.type == channel_type:
                return True
        return False

    def get_channel_by_type(self, channel_type: InkSensorType) -&gt; SensorChannel:
        &#34;&#34;&#34;Returns instance of Channel.

        Parameters
        ----------
        channel_type: `InkSensorType`
            type  of the channel

        Returns
        -------
        instance: SensorChannel
            Instance of the `SensorChannel` for the `InkSensorType`

        Raises
        ------
        InkModelException
            If the `SensorChannel` is not available.
        &#34;&#34;&#34;
        for c in self.__channels:
            if c.type == channel_type:
                return c
        raise InkModelException(f&#39;No channel available for the type: {channel_type}&#39;)

    def __repr__(self):
        return &#39;&lt;SensorChannelsContext: [id:={}, sampling rate hint:={}, latency:={}, input data provider id:={}, &#39; \
               &#39;input data id:={}&gt;&#39;.format(self.id_h_form, self.sampling_rate, self.latency,
                                           UUIDIdentifier.uimid_to_h_form(self.input_provider_id),
                                           UUIDIdentifier.uimid_to_h_form(self.input_device_id))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="uim.model.base.HashIdentifier" href="../base.html#uim.model.base.HashIdentifier">HashIdentifier</a></li>
<li><a title="uim.model.base.Identifier" href="../base.html#uim.model.base.Identifier">Identifier</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="uim.model.inkinput.inputdata.SensorChannelsContext.SEPARATOR"><code class="name">var <span class="ident">SEPARATOR</span> :Â str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="uim.model.inkinput.inputdata.SensorChannelsContext.channels"><code class="name">var <span class="ident">channels</span> :Â List[<a title="uim.model.inkinput.inputdata.SensorChannel" href="#uim.model.inkinput.inputdata.SensorChannel">SensorChannel</a>]</code></dt>
<dd>
<div class="desc"><p>Array of the <code><a title="uim.model.inkinput.inputdata.SensorChannel" href="#uim.model.inkinput.inputdata.SensorChannel">SensorChannel</a></code>s associated with the context. (<code>List[<a title="uim.model.inkinput.inputdata.SensorChannel" href="#uim.model.inkinput.inputdata.SensorChannel">SensorChannel</a>]</code>, read-only)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def channels(self) -&gt; List[SensorChannel]:
    &#34;&#34;&#34;Array of the `SensorChannel`s associated with the context. (`List[SensorChannel]`, read-only) &#34;&#34;&#34;
    return self.__channels</code></pre>
</details>
</dd>
<dt id="uim.model.inkinput.inputdata.SensorChannelsContext.input_device_id"><code class="name">var <span class="ident">input_device_id</span> :Â uuid.UUID</code></dt>
<dd>
<div class="desc"><p>Reference to <code>InkInputDevice</code>. (<code>UUID</code>, read-only)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def input_device_id(self) -&gt; uuid.UUID:
    &#34;&#34;&#34;Reference to `InkInputDevice`. (`UUID`, read-only)&#34;&#34;&#34;
    return self.__input_device_id</code></pre>
</details>
</dd>
<dt id="uim.model.inkinput.inputdata.SensorChannelsContext.input_provider_id"><code class="name">var <span class="ident">input_provider_id</span> :Â uuid.UUID</code></dt>
<dd>
<div class="desc"><p>Reference id to the ink <code>InputProvider</code> that produces the ink. (<code>UUID</code>, read-only)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def input_provider_id(self) -&gt; uuid.UUID:
    &#34;&#34;&#34;Reference id to the ink `InputProvider` that produces the ink. (`UUID`, read-only)&#34;&#34;&#34;
    return self.__ink_input_provider_id</code></pre>
</details>
</dd>
<dt id="uim.model.inkinput.inputdata.SensorChannelsContext.latency"><code class="name">var <span class="ident">latency</span> :Â int</code></dt>
<dd>
<div class="desc"><p>Gets the latency measurement in milliseconds. (<code>int</code>, read-only)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def latency(self) -&gt; int:
    &#34;&#34;&#34;Gets the latency measurement in milliseconds. (`int`, read-only)&#34;&#34;&#34;
    return self.__latency</code></pre>
</details>
</dd>
<dt id="uim.model.inkinput.inputdata.SensorChannelsContext.sampling_rate"><code class="name">var <span class="ident">sampling_rate</span> :Â int</code></dt>
<dd>
<div class="desc"><p>Hint for sampling rate valid for all channels. (<code>int</code>, read-only)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sampling_rate(self) -&gt; int:
    &#34;&#34;&#34;Hint for sampling rate valid for all channels. (`int`, read-only)&#34;&#34;&#34;
    return self.__sampling_rate_hint</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="uim.model.inkinput.inputdata.SensorChannelsContext.add_sensor_channel"><code class="name flex">
<span>def <span class="ident">add_sensor_channel</span></span>(<span>self, channel:Â <a title="uim.model.inkinput.inputdata.SensorChannel" href="#uim.model.inkinput.inputdata.SensorChannel">SensorChannel</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Adding a channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code><a title="uim.model.inkinput.inputdata.SensorChannel" href="#uim.model.inkinput.inputdata.SensorChannel">SensorChannel</a></code></dt>
<dd>sensor channel</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_sensor_channel(self, channel: SensorChannel):
    &#34;&#34;&#34;
    Adding a channel.

    Parameters
    ----------
    channel: `SensorChannel`
        sensor channel
    &#34;&#34;&#34;
    self.__channels.append(channel)</code></pre>
</details>
</dd>
<dt id="uim.model.inkinput.inputdata.SensorChannelsContext.get_channel_by_type"><code class="name flex">
<span>def <span class="ident">get_channel_by_type</span></span>(<span>self, channel_type:Â <a title="uim.model.inkinput.inputdata.InkSensorType" href="#uim.model.inkinput.inputdata.InkSensorType">InkSensorType</a>) â>Â <a title="uim.model.inkinput.inputdata.SensorChannel" href="#uim.model.inkinput.inputdata.SensorChannel">SensorChannel</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns instance of Channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel_type</code></strong> :&ensp;<code><a title="uim.model.inkinput.inputdata.InkSensorType" href="#uim.model.inkinput.inputdata.InkSensorType">InkSensorType</a></code></dt>
<dd>type
of the channel</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>instance</code></strong> :&ensp;<code><a title="uim.model.inkinput.inputdata.SensorChannel" href="#uim.model.inkinput.inputdata.SensorChannel">SensorChannel</a></code></dt>
<dd>Instance of the <code><a title="uim.model.inkinput.inputdata.SensorChannel" href="#uim.model.inkinput.inputdata.SensorChannel">SensorChannel</a></code> for the <code><a title="uim.model.inkinput.inputdata.InkSensorType" href="#uim.model.inkinput.inputdata.InkSensorType">InkSensorType</a></code></dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>InkModelException</code></dt>
<dd>If the <code><a title="uim.model.inkinput.inputdata.SensorChannel" href="#uim.model.inkinput.inputdata.SensorChannel">SensorChannel</a></code> is not available.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_channel_by_type(self, channel_type: InkSensorType) -&gt; SensorChannel:
    &#34;&#34;&#34;Returns instance of Channel.

    Parameters
    ----------
    channel_type: `InkSensorType`
        type  of the channel

    Returns
    -------
    instance: SensorChannel
        Instance of the `SensorChannel` for the `InkSensorType`

    Raises
    ------
    InkModelException
        If the `SensorChannel` is not available.
    &#34;&#34;&#34;
    for c in self.__channels:
        if c.type == channel_type:
            return c
    raise InkModelException(f&#39;No channel available for the type: {channel_type}&#39;)</code></pre>
</details>
</dd>
<dt id="uim.model.inkinput.inputdata.SensorChannelsContext.has_channel_type"><code class="name flex">
<span>def <span class="ident">has_channel_type</span></span>(<span>self, channel_type:Â <a title="uim.model.inkinput.inputdata.InkSensorType" href="#uim.model.inkinput.inputdata.InkSensorType">InkSensorType</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if channel types is available.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel_type</code></strong> :&ensp;<code><a title="uim.model.inkinput.inputdata.InkSensorType" href="#uim.model.inkinput.inputdata.InkSensorType">InkSensorType</a></code></dt>
<dd>sensor type</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>flag</code></strong> :&ensp;<code>boolean</code></dt>
<dd>True if available, False if not</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_channel_type(self, channel_type: InkSensorType):
    &#34;&#34;&#34;
    Checks if channel types is available.

    Parameters
    ----------
    channel_type: `InkSensorType`
        sensor type

    Returns
    -------
    flag: `boolean`
        True if available, False if not
    &#34;&#34;&#34;
    for c in self.channels:
        if c.type == channel_type:
            return True
    return False</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="uim.model.base.HashIdentifier" href="../base.html#uim.model.base.HashIdentifier">HashIdentifier</a></b></code>:
<ul class="hlist">
<li><code><a title="uim.model.base.HashIdentifier.from_bytes" href="../base.html#uim.model.base.Identifier.from_bytes">from_bytes</a></code></li>
<li><code><a title="uim.model.base.HashIdentifier.id" href="../base.html#uim.model.base.Identifier.id">id</a></code></li>
<li><code><a title="uim.model.base.HashIdentifier.id_h_form" href="../base.html#uim.model.base.Identifier.id_h_form">id_h_form</a></code></li>
<li><code><a title="uim.model.base.HashIdentifier.id_s_form" href="../base.html#uim.model.base.Identifier.id_s_form">id_s_form</a></code></li>
<li><code><a title="uim.model.base.HashIdentifier.str_to_uimid" href="../base.html#uim.model.base.Identifier.str_to_uimid">str_to_uimid</a></code></li>
<li><code><a title="uim.model.base.HashIdentifier.uimid_to_h_form" href="../base.html#uim.model.base.Identifier.uimid_to_h_form">uimid_to_h_form</a></code></li>
<li><code><a title="uim.model.base.HashIdentifier.uimid_to_s_form" href="../base.html#uim.model.base.Identifier.uimid_to_s_form">uimid_to_s_form</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="uim.model.inkinput.inputdata.SensorContext"><code class="flex name class">
<span>class <span class="ident">SensorContext</span></span>
<span>(</span><span>context_id:Â uuid.UUIDÂ =Â None, sensor_channels_contexts:Â List[<a title="uim.model.inkinput.inputdata.SensorChannelsContext" href="#uim.model.inkinput.inputdata.SensorChannelsContext">SensorChannelsContext</a>]Â =Â None)</span>
</code></dt>
<dd>
<div class="desc"><h1 id="sensorcontext">SensorContext</h1>
<p>Each input data has a SensorContext describing the available sensors of a input data.
One file can contains Ink data from two input data of the same type with a shared context.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>context_id</code></strong> :&ensp;<code>UUID</code></dt>
<dd>Id of the context</dd>
<dt><strong><code>sensor_channels_contexts</code></strong> :&ensp;<code>List[<a title="uim.model.inkinput.inputdata.SensorChannelsContext" href="#uim.model.inkinput.inputdata.SensorChannelsContext">SensorChannelsContext</a>]</code></dt>
<dd>List of <code><a title="uim.model.inkinput.inputdata.SensorChannelsContext" href="#uim.model.inkinput.inputdata.SensorChannelsContext">SensorChannelsContext</a></code></dd>
</dl>
<p>Constructor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SensorContext(HashIdentifier):
    &#34;&#34;&#34;
    SensorContext
    =============
    Each input data has a SensorContext describing the available sensors of a input data.
    One file can contains Ink data from two input data of the same type with a shared context.

    Parameters
    -----------
    context_id: UUID
        Id of the context
    sensor_channels_contexts: `List[SensorChannelsContext]`
        List of `SensorChannelsContext`
    &#34;&#34;&#34;

    def __init__(self, context_id: uuid.UUID = None, sensor_channels_contexts: List[SensorChannelsContext] = None):
        &#34;&#34;&#34;Constructor.

        &#34;&#34;&#34;
        super().__init__(context_id)
        self.__sensor_channels_contexts: List[SensorChannelsContext] = sensor_channels_contexts or []

    def __tokenize__(self) -&gt; list:
        token: list = [&#34;SensorContext&#34;]
        token.extend([c.id for c in self.sensor_channels_contexts])
        return token

    @property
    def sensor_channels_contexts(self) -&gt; List[SensorChannelsContext]:
        &#34;&#34;&#34;
        List of channel contexts. (`List[SensorChannelsContext]`, read-only)&#34;&#34;&#34;
        return self.__sensor_channels_contexts

    def add_sensor_channels_context(self, channel_ctx: SensorChannelsContext):
        &#34;&#34;&#34;Adding a sensor.

        Parameters
        ----------
        channel_ctx: `SensorChannelsContext`
            Adding a channel
        &#34;&#34;&#34;
        self.__sensor_channels_contexts.append(channel_ctx)

    def has_channel_type(self, channel_type: InkSensorType) -&gt; bool:
        &#34;&#34;&#34;
        Check if the SensorContext has a channel with type.

        Parameters
        ----------
        channel_type: `InkSensorType`
            type of channel

        Returns
        -------
        flag: `bool`
            True if channel exists, False if not
        &#34;&#34;&#34;
        for c in self.__sensor_channels_contexts:
            if c.has_channel_type(channel_type):
                return True
        return False

    def get_channel_by_id(self, channel_id: uuid.UUID) -&gt; SensorChannel:
        &#34;&#34;&#34;
         Returns the channel for a specific id.

         Parameters
         ----------
        channel_id: bytes -
            id of channel

        Returns
        -------
        instance: `SensorChannel`
            Instance of `SensorChannel`

        Raises
        ------
            InkModelException: Raised if no channel for channel id.
        &#34;&#34;&#34;
        for cs in self.sensor_channels_contexts:
            for c in cs.channels:
                if c.id == channel_id:
                    return c
        raise InkModelException(&#39;No channel with channel id: {}.&#39;.format(channel_id))

    def get_channel_by_type(self, channel_type: InkSensorType) -&gt; SensorChannel:
        &#34;&#34;&#34;
        Returns the channel for a specific `InkSensorType`.
        
        Parameters
        ----------
        channel_type: `InkSensorType`
            Channel type
        
        Returns
        -------
        instance: `SensorChannel`
            Instance of channel
            
        Raises
        ------
        InkModelException
            Raised if no `SensorChannel` for the id is not available.
        &#34;&#34;&#34;
        for c in self.__sensor_channels_contexts:
            if c.has_channel_type(channel_type):
                return c.get_channel_by_type(channel_type)
        raise InkModelException(&#39;No channel with channel type: {}.&#39;.format(channel_type))

    def __repr__(self):
        return &#39;&lt;SensorContext: [context_id:={}, sensor_channels_contexts:={}]&gt;&#39;.format(self.id,
                                                                                        self.sensor_channels_contexts)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="uim.model.base.HashIdentifier" href="../base.html#uim.model.base.HashIdentifier">HashIdentifier</a></li>
<li><a title="uim.model.base.Identifier" href="../base.html#uim.model.base.Identifier">Identifier</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="uim.model.inkinput.inputdata.SensorContext.SEPARATOR"><code class="name">var <span class="ident">SEPARATOR</span> :Â str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="uim.model.inkinput.inputdata.SensorContext.sensor_channels_contexts"><code class="name">var <span class="ident">sensor_channels_contexts</span> :Â List[<a title="uim.model.inkinput.inputdata.SensorChannelsContext" href="#uim.model.inkinput.inputdata.SensorChannelsContext">SensorChannelsContext</a>]</code></dt>
<dd>
<div class="desc"><p>List of channel contexts. (<code>List[<a title="uim.model.inkinput.inputdata.SensorChannelsContext" href="#uim.model.inkinput.inputdata.SensorChannelsContext">SensorChannelsContext</a>]</code>, read-only)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sensor_channels_contexts(self) -&gt; List[SensorChannelsContext]:
    &#34;&#34;&#34;
    List of channel contexts. (`List[SensorChannelsContext]`, read-only)&#34;&#34;&#34;
    return self.__sensor_channels_contexts</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="uim.model.inkinput.inputdata.SensorContext.add_sensor_channels_context"><code class="name flex">
<span>def <span class="ident">add_sensor_channels_context</span></span>(<span>self, channel_ctx:Â <a title="uim.model.inkinput.inputdata.SensorChannelsContext" href="#uim.model.inkinput.inputdata.SensorChannelsContext">SensorChannelsContext</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Adding a sensor.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel_ctx</code></strong> :&ensp;<code><a title="uim.model.inkinput.inputdata.SensorChannelsContext" href="#uim.model.inkinput.inputdata.SensorChannelsContext">SensorChannelsContext</a></code></dt>
<dd>Adding a channel</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_sensor_channels_context(self, channel_ctx: SensorChannelsContext):
    &#34;&#34;&#34;Adding a sensor.

    Parameters
    ----------
    channel_ctx: `SensorChannelsContext`
        Adding a channel
    &#34;&#34;&#34;
    self.__sensor_channels_contexts.append(channel_ctx)</code></pre>
</details>
</dd>
<dt id="uim.model.inkinput.inputdata.SensorContext.get_channel_by_id"><code class="name flex">
<span>def <span class="ident">get_channel_by_id</span></span>(<span>self, channel_id:Â uuid.UUID) â>Â <a title="uim.model.inkinput.inputdata.SensorChannel" href="#uim.model.inkinput.inputdata.SensorChannel">SensorChannel</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns the channel for a specific id.</p>
<p>Parameters</p>
<hr>
<p>channel_id: bytes -
id of channel</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>instance</code></strong> :&ensp;<code><a title="uim.model.inkinput.inputdata.SensorChannel" href="#uim.model.inkinput.inputdata.SensorChannel">SensorChannel</a></code></dt>
<dd>Instance of <code><a title="uim.model.inkinput.inputdata.SensorChannel" href="#uim.model.inkinput.inputdata.SensorChannel">SensorChannel</a></code></dd>
</dl>
<h2 id="raises">Raises</h2>
<pre><code>InkModelException: Raised if no channel for channel id.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_channel_by_id(self, channel_id: uuid.UUID) -&gt; SensorChannel:
    &#34;&#34;&#34;
     Returns the channel for a specific id.

     Parameters
     ----------
    channel_id: bytes -
        id of channel

    Returns
    -------
    instance: `SensorChannel`
        Instance of `SensorChannel`

    Raises
    ------
        InkModelException: Raised if no channel for channel id.
    &#34;&#34;&#34;
    for cs in self.sensor_channels_contexts:
        for c in cs.channels:
            if c.id == channel_id:
                return c
    raise InkModelException(&#39;No channel with channel id: {}.&#39;.format(channel_id))</code></pre>
</details>
</dd>
<dt id="uim.model.inkinput.inputdata.SensorContext.get_channel_by_type"><code class="name flex">
<span>def <span class="ident">get_channel_by_type</span></span>(<span>self, channel_type:Â <a title="uim.model.inkinput.inputdata.InkSensorType" href="#uim.model.inkinput.inputdata.InkSensorType">InkSensorType</a>) â>Â <a title="uim.model.inkinput.inputdata.SensorChannel" href="#uim.model.inkinput.inputdata.SensorChannel">SensorChannel</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns the channel for a specific <code><a title="uim.model.inkinput.inputdata.InkSensorType" href="#uim.model.inkinput.inputdata.InkSensorType">InkSensorType</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel_type</code></strong> :&ensp;<code><a title="uim.model.inkinput.inputdata.InkSensorType" href="#uim.model.inkinput.inputdata.InkSensorType">InkSensorType</a></code></dt>
<dd>Channel type</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>instance</code></strong> :&ensp;<code><a title="uim.model.inkinput.inputdata.SensorChannel" href="#uim.model.inkinput.inputdata.SensorChannel">SensorChannel</a></code></dt>
<dd>Instance of channel</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>InkModelException</code></dt>
<dd>Raised if no <code><a title="uim.model.inkinput.inputdata.SensorChannel" href="#uim.model.inkinput.inputdata.SensorChannel">SensorChannel</a></code> for the id is not available.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_channel_by_type(self, channel_type: InkSensorType) -&gt; SensorChannel:
    &#34;&#34;&#34;
    Returns the channel for a specific `InkSensorType`.
    
    Parameters
    ----------
    channel_type: `InkSensorType`
        Channel type
    
    Returns
    -------
    instance: `SensorChannel`
        Instance of channel
        
    Raises
    ------
    InkModelException
        Raised if no `SensorChannel` for the id is not available.
    &#34;&#34;&#34;
    for c in self.__sensor_channels_contexts:
        if c.has_channel_type(channel_type):
            return c.get_channel_by_type(channel_type)
    raise InkModelException(&#39;No channel with channel type: {}.&#39;.format(channel_type))</code></pre>
</details>
</dd>
<dt id="uim.model.inkinput.inputdata.SensorContext.has_channel_type"><code class="name flex">
<span>def <span class="ident">has_channel_type</span></span>(<span>self, channel_type:Â <a title="uim.model.inkinput.inputdata.InkSensorType" href="#uim.model.inkinput.inputdata.InkSensorType">InkSensorType</a>) â>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if the SensorContext has a channel with type.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>channel_type</code></strong> :&ensp;<code><a title="uim.model.inkinput.inputdata.InkSensorType" href="#uim.model.inkinput.inputdata.InkSensorType">InkSensorType</a></code></dt>
<dd>type of channel</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>flag</code></strong> :&ensp;<code>bool</code></dt>
<dd>True if channel exists, False if not</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_channel_type(self, channel_type: InkSensorType) -&gt; bool:
    &#34;&#34;&#34;
    Check if the SensorContext has a channel with type.

    Parameters
    ----------
    channel_type: `InkSensorType`
        type of channel

    Returns
    -------
    flag: `bool`
        True if channel exists, False if not
    &#34;&#34;&#34;
    for c in self.__sensor_channels_contexts:
        if c.has_channel_type(channel_type):
            return True
    return False</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="uim.model.base.HashIdentifier" href="../base.html#uim.model.base.HashIdentifier">HashIdentifier</a></b></code>:
<ul class="hlist">
<li><code><a title="uim.model.base.HashIdentifier.from_bytes" href="../base.html#uim.model.base.Identifier.from_bytes">from_bytes</a></code></li>
<li><code><a title="uim.model.base.HashIdentifier.id" href="../base.html#uim.model.base.Identifier.id">id</a></code></li>
<li><code><a title="uim.model.base.HashIdentifier.id_h_form" href="../base.html#uim.model.base.Identifier.id_h_form">id_h_form</a></code></li>
<li><code><a title="uim.model.base.HashIdentifier.id_s_form" href="../base.html#uim.model.base.Identifier.id_s_form">id_s_form</a></code></li>
<li><code><a title="uim.model.base.HashIdentifier.str_to_uimid" href="../base.html#uim.model.base.Identifier.str_to_uimid">str_to_uimid</a></code></li>
<li><code><a title="uim.model.base.HashIdentifier.uimid_to_h_form" href="../base.html#uim.model.base.Identifier.uimid_to_h_form">uimid_to_h_form</a></code></li>
<li><code><a title="uim.model.base.HashIdentifier.uimid_to_s_form" href="../base.html#uim.model.base.Identifier.uimid_to_s_form">uimid_to_s_form</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="uim.model.inkinput.inputdata.Unit"><code class="flex name class">
<span>class <span class="ident">Unit</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Unit(Enum):
    # Lengths units
    UNDEFINED = 0
    &#34;&#34;&#34;Undefined unit&#34;&#34;&#34;
    M = 10
    &#34;&#34;&#34;meters&#34;&#34;&#34;
    CM = 11
    &#34;&#34;&#34;centimeters&#34;&#34;&#34;
    MM = 12
    &#34;&#34;&#34;millimeters&#34;&#34;&#34;
    IN = 13
    &#34;&#34;&#34;inches&#34;&#34;&#34;
    PT = 14
    &#34;&#34;&#34;points (1pt = 1/72 in)&#34;&#34;&#34;
    PC = 15
    &#34;&#34;&#34;picas (1pc = 1/22 pt)&#34;&#34;&#34;
    DIP = 16
    &#34;&#34;&#34;device independent pixel (1DIP = 1/96 in)&#34;&#34;&#34;
    # Time units
    S = 20
    &#34;&#34;&#34;seconds&#34;&#34;&#34;
    MS = 21
    &#34;&#34;&#34;milliseconds&#34;&#34;&#34;
    NS = 22
    &#34;&#34;&#34;nanoseconds&#34;&#34;&#34;
    # Force units
    N = 30
    &#34;&#34;&#34;Newtons&#34;&#34;&#34;
    # Angle
    RAD = 42
    &#34;&#34;&#34;radians&#34;&#34;&#34;
    DEG = 41
    &#34;&#34;&#34;degrees&#34;&#34;&#34;
    # General
    PERCENTAGE = 50
    &#34;&#34;&#34;percentage, expressed as a fraction (1.0 = 100%) relative to max-min&#34;&#34;&#34;
    LOGICAL_VALUE = 60
    &#34;&#34;&#34;logical value&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="uim.model.inkinput.inputdata.Unit.CM"><code class="name">var <span class="ident">CM</span></code></dt>
<dd>
<div class="desc"><p>centimeters</p></div>
</dd>
<dt id="uim.model.inkinput.inputdata.Unit.DEG"><code class="name">var <span class="ident">DEG</span></code></dt>
<dd>
<div class="desc"><p>degrees</p></div>
</dd>
<dt id="uim.model.inkinput.inputdata.Unit.DIP"><code class="name">var <span class="ident">DIP</span></code></dt>
<dd>
<div class="desc"><p>device independent pixel (1DIP = 1/96 in)</p></div>
</dd>
<dt id="uim.model.inkinput.inputdata.Unit.IN"><code class="name">var <span class="ident">IN</span></code></dt>
<dd>
<div class="desc"><p>inches</p></div>
</dd>
<dt id="uim.model.inkinput.inputdata.Unit.LOGICAL_VALUE"><code class="name">var <span class="ident">LOGICAL_VALUE</span></code></dt>
<dd>
<div class="desc"><p>logical value</p></div>
</dd>
<dt id="uim.model.inkinput.inputdata.Unit.M"><code class="name">var <span class="ident">M</span></code></dt>
<dd>
<div class="desc"><p>meters</p></div>
</dd>
<dt id="uim.model.inkinput.inputdata.Unit.MM"><code class="name">var <span class="ident">MM</span></code></dt>
<dd>
<div class="desc"><p>millimeters</p></div>
</dd>
<dt id="uim.model.inkinput.inputdata.Unit.MS"><code class="name">var <span class="ident">MS</span></code></dt>
<dd>
<div class="desc"><p>milliseconds</p></div>
</dd>
<dt id="uim.model.inkinput.inputdata.Unit.N"><code class="name">var <span class="ident">N</span></code></dt>
<dd>
<div class="desc"><p>Newtons</p></div>
</dd>
<dt id="uim.model.inkinput.inputdata.Unit.NS"><code class="name">var <span class="ident">NS</span></code></dt>
<dd>
<div class="desc"><p>nanoseconds</p></div>
</dd>
<dt id="uim.model.inkinput.inputdata.Unit.PC"><code class="name">var <span class="ident">PC</span></code></dt>
<dd>
<div class="desc"><p>picas (1pc = 1/22 pt)</p></div>
</dd>
<dt id="uim.model.inkinput.inputdata.Unit.PERCENTAGE"><code class="name">var <span class="ident">PERCENTAGE</span></code></dt>
<dd>
<div class="desc"><p>percentage, expressed as a fraction (1.0 = 100%) relative to max-min</p></div>
</dd>
<dt id="uim.model.inkinput.inputdata.Unit.PT"><code class="name">var <span class="ident">PT</span></code></dt>
<dd>
<div class="desc"><p>points (1pt = 1/72 in)</p></div>
</dd>
<dt id="uim.model.inkinput.inputdata.Unit.RAD"><code class="name">var <span class="ident">RAD</span></code></dt>
<dd>
<div class="desc"><p>radians</p></div>
</dd>
<dt id="uim.model.inkinput.inputdata.Unit.S"><code class="name">var <span class="ident">S</span></code></dt>
<dd>
<div class="desc"><p>seconds</p></div>
</dd>
<dt id="uim.model.inkinput.inputdata.Unit.UNDEFINED"><code class="name">var <span class="ident">UNDEFINED</span></code></dt>
<dd>
<div class="desc"><p>Undefined unit</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="uim.model.inkinput" href="index.html">uim.model.inkinput</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="uim.model.inkinput.inputdata.CONVERSION_SCALAR" href="#uim.model.inkinput.inputdata.CONVERSION_SCALAR">CONVERSION_SCALAR</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="uim.model.inkinput.inputdata.si_unit" href="#uim.model.inkinput.inputdata.si_unit">si_unit</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.unit2unit" href="#uim.model.inkinput.inputdata.unit2unit">unit2unit</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.unit2unit_matrix" href="#uim.model.inkinput.inputdata.unit2unit_matrix">unit2unit_matrix</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.virtual_resolution_for_si_unit" href="#uim.model.inkinput.inputdata.virtual_resolution_for_si_unit">virtual_resolution_for_si_unit</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="uim.model.inkinput.inputdata.DataType" href="#uim.model.inkinput.inputdata.DataType">DataType</a></code></h4>
<ul class="two-column">
<li><code><a title="uim.model.inkinput.inputdata.DataType.BOOLEAN" href="#uim.model.inkinput.inputdata.DataType.BOOLEAN">BOOLEAN</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.DataType.FLOAT32" href="#uim.model.inkinput.inputdata.DataType.FLOAT32">FLOAT32</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.DataType.FLOAT64" href="#uim.model.inkinput.inputdata.DataType.FLOAT64">FLOAT64</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.DataType.INT32" href="#uim.model.inkinput.inputdata.DataType.INT32">INT32</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.DataType.INT64" href="#uim.model.inkinput.inputdata.DataType.INT64">INT64</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.DataType.UINT32" href="#uim.model.inkinput.inputdata.DataType.UINT32">UINT32</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.DataType.UINT64" href="#uim.model.inkinput.inputdata.DataType.UINT64">UINT64</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="uim.model.inkinput.inputdata.Environment" href="#uim.model.inkinput.inputdata.Environment">Environment</a></code></h4>
<ul class="">
<li><code><a title="uim.model.inkinput.inputdata.Environment.SEPARATOR" href="#uim.model.inkinput.inputdata.Environment.SEPARATOR">SEPARATOR</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.Environment.add_environment_property" href="#uim.model.inkinput.inputdata.Environment.add_environment_property">add_environment_property</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.Environment.properties" href="#uim.model.inkinput.inputdata.Environment.properties">properties</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="uim.model.inkinput.inputdata.InkInputProvider" href="#uim.model.inkinput.inputdata.InkInputProvider">InkInputProvider</a></code></h4>
<ul class="">
<li><code><a title="uim.model.inkinput.inputdata.InkInputProvider.SEPARATOR" href="#uim.model.inkinput.inputdata.InkInputProvider.SEPARATOR">SEPARATOR</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.InkInputProvider.properties" href="#uim.model.inkinput.inputdata.InkInputProvider.properties">properties</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.InkInputProvider.type" href="#uim.model.inkinput.inputdata.InkInputProvider.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="uim.model.inkinput.inputdata.InkInputType" href="#uim.model.inkinput.inputdata.InkInputType">InkInputType</a></code></h4>
<ul class="">
<li><code><a title="uim.model.inkinput.inputdata.InkInputType.CONTROLLER" href="#uim.model.inkinput.inputdata.InkInputType.CONTROLLER">CONTROLLER</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.InkInputType.MOUSE" href="#uim.model.inkinput.inputdata.InkInputType.MOUSE">MOUSE</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.InkInputType.PEN" href="#uim.model.inkinput.inputdata.InkInputType.PEN">PEN</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.InkInputType.TOUCH" href="#uim.model.inkinput.inputdata.InkInputType.TOUCH">TOUCH</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="uim.model.inkinput.inputdata.InkSensorMetricType" href="#uim.model.inkinput.inputdata.InkSensorMetricType">InkSensorMetricType</a></code></h4>
<ul class="">
<li><code><a title="uim.model.inkinput.inputdata.InkSensorMetricType.ANGLE" href="#uim.model.inkinput.inputdata.InkSensorMetricType.ANGLE">ANGLE</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.InkSensorMetricType.FORCE" href="#uim.model.inkinput.inputdata.InkSensorMetricType.FORCE">FORCE</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.InkSensorMetricType.LENGTH" href="#uim.model.inkinput.inputdata.InkSensorMetricType.LENGTH">LENGTH</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.InkSensorMetricType.NORMALIZED" href="#uim.model.inkinput.inputdata.InkSensorMetricType.NORMALIZED">NORMALIZED</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.InkSensorMetricType.TIME" href="#uim.model.inkinput.inputdata.InkSensorMetricType.TIME">TIME</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="uim.model.inkinput.inputdata.InkSensorType" href="#uim.model.inkinput.inputdata.InkSensorType">InkSensorType</a></code></h4>
<ul class="two-column">
<li><code><a title="uim.model.inkinput.inputdata.InkSensorType.ALTITUDE" href="#uim.model.inkinput.inputdata.InkSensorType.ALTITUDE">ALTITUDE</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.InkSensorType.AZIMUTH" href="#uim.model.inkinput.inputdata.InkSensorType.AZIMUTH">AZIMUTH</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.InkSensorType.PRESSURE" href="#uim.model.inkinput.inputdata.InkSensorType.PRESSURE">PRESSURE</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.InkSensorType.RADIUS_X" href="#uim.model.inkinput.inputdata.InkSensorType.RADIUS_X">RADIUS_X</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.InkSensorType.RADIUS_Y" href="#uim.model.inkinput.inputdata.InkSensorType.RADIUS_Y">RADIUS_Y</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.InkSensorType.ROTATION" href="#uim.model.inkinput.inputdata.InkSensorType.ROTATION">ROTATION</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.InkSensorType.TIMESTAMP" href="#uim.model.inkinput.inputdata.InkSensorType.TIMESTAMP">TIMESTAMP</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.InkSensorType.X" href="#uim.model.inkinput.inputdata.InkSensorType.X">X</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.InkSensorType.Y" href="#uim.model.inkinput.inputdata.InkSensorType.Y">Y</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.InkSensorType.Z" href="#uim.model.inkinput.inputdata.InkSensorType.Z">Z</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="uim.model.inkinput.inputdata.InputContext" href="#uim.model.inkinput.inputdata.InputContext">InputContext</a></code></h4>
<ul class="">
<li><code><a title="uim.model.inkinput.inputdata.InputContext.SEPARATOR" href="#uim.model.inkinput.inputdata.InputContext.SEPARATOR">SEPARATOR</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.InputContext.environment_id" href="#uim.model.inkinput.inputdata.InputContext.environment_id">environment_id</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.InputContext.sensor_context_id" href="#uim.model.inkinput.inputdata.InputContext.sensor_context_id">sensor_context_id</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="uim.model.inkinput.inputdata.InputContextRepository" href="#uim.model.inkinput.inputdata.InputContextRepository">InputContextRepository</a></code></h4>
<ul class="two-column">
<li><code><a title="uim.model.inkinput.inputdata.InputContextRepository.add_environment" href="#uim.model.inkinput.inputdata.InputContextRepository.add_environment">add_environment</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.InputContextRepository.add_ink_device" href="#uim.model.inkinput.inputdata.InputContextRepository.add_ink_device">add_ink_device</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.InputContextRepository.add_input_context" href="#uim.model.inkinput.inputdata.InputContextRepository.add_input_context">add_input_context</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.InputContextRepository.add_input_provider" href="#uim.model.inkinput.inputdata.InputContextRepository.add_input_provider">add_input_provider</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.InputContextRepository.add_sensor_context" href="#uim.model.inkinput.inputdata.InputContextRepository.add_sensor_context">add_sensor_context</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.InputContextRepository.devices" href="#uim.model.inkinput.inputdata.InputContextRepository.devices">devices</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.InputContextRepository.environments" href="#uim.model.inkinput.inputdata.InputContextRepository.environments">environments</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.InputContextRepository.get_input_context" href="#uim.model.inkinput.inputdata.InputContextRepository.get_input_context">get_input_context</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.InputContextRepository.get_input_device" href="#uim.model.inkinput.inputdata.InputContextRepository.get_input_device">get_input_device</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.InputContextRepository.get_sensor_context" href="#uim.model.inkinput.inputdata.InputContextRepository.get_sensor_context">get_sensor_context</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.InputContextRepository.has_configuration" href="#uim.model.inkinput.inputdata.InputContextRepository.has_configuration">has_configuration</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.InputContextRepository.ink_input_providers" href="#uim.model.inkinput.inputdata.InputContextRepository.ink_input_providers">ink_input_providers</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.InputContextRepository.input_contexts" href="#uim.model.inkinput.inputdata.InputContextRepository.input_contexts">input_contexts</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.InputContextRepository.sensor_contexts" href="#uim.model.inkinput.inputdata.InputContextRepository.sensor_contexts">sensor_contexts</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="uim.model.inkinput.inputdata.InputDevice" href="#uim.model.inkinput.inputdata.InputDevice">InputDevice</a></code></h4>
<ul class="">
<li><code><a title="uim.model.inkinput.inputdata.InputDevice.SEPARATOR" href="#uim.model.inkinput.inputdata.InputDevice.SEPARATOR">SEPARATOR</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.InputDevice.add_property" href="#uim.model.inkinput.inputdata.InputDevice.add_property">add_property</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.InputDevice.properties" href="#uim.model.inkinput.inputdata.InputDevice.properties">properties</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="uim.model.inkinput.inputdata.SensorChannel" href="#uim.model.inkinput.inputdata.SensorChannel">SensorChannel</a></code></h4>
<ul class="two-column">
<li><code><a title="uim.model.inkinput.inputdata.SensorChannel.SEPARATOR" href="#uim.model.inkinput.inputdata.SensorChannel.SEPARATOR">SEPARATOR</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.SensorChannel.data_type" href="#uim.model.inkinput.inputdata.SensorChannel.data_type">data_type</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.SensorChannel.index" href="#uim.model.inkinput.inputdata.SensorChannel.index">index</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.SensorChannel.ink_input_provider" href="#uim.model.inkinput.inputdata.SensorChannel.ink_input_provider">ink_input_provider</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.SensorChannel.input_device_id" href="#uim.model.inkinput.inputdata.SensorChannel.input_device_id">input_device_id</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.SensorChannel.max" href="#uim.model.inkinput.inputdata.SensorChannel.max">max</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.SensorChannel.metric" href="#uim.model.inkinput.inputdata.SensorChannel.metric">metric</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.SensorChannel.min" href="#uim.model.inkinput.inputdata.SensorChannel.min">min</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.SensorChannel.name" href="#uim.model.inkinput.inputdata.SensorChannel.name">name</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.SensorChannel.precision" href="#uim.model.inkinput.inputdata.SensorChannel.precision">precision</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.SensorChannel.resolution" href="#uim.model.inkinput.inputdata.SensorChannel.resolution">resolution</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.SensorChannel.type" href="#uim.model.inkinput.inputdata.SensorChannel.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="uim.model.inkinput.inputdata.SensorChannelsContext" href="#uim.model.inkinput.inputdata.SensorChannelsContext">SensorChannelsContext</a></code></h4>
<ul class="two-column">
<li><code><a title="uim.model.inkinput.inputdata.SensorChannelsContext.SEPARATOR" href="#uim.model.inkinput.inputdata.SensorChannelsContext.SEPARATOR">SEPARATOR</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.SensorChannelsContext.add_sensor_channel" href="#uim.model.inkinput.inputdata.SensorChannelsContext.add_sensor_channel">add_sensor_channel</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.SensorChannelsContext.channels" href="#uim.model.inkinput.inputdata.SensorChannelsContext.channels">channels</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.SensorChannelsContext.get_channel_by_type" href="#uim.model.inkinput.inputdata.SensorChannelsContext.get_channel_by_type">get_channel_by_type</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.SensorChannelsContext.has_channel_type" href="#uim.model.inkinput.inputdata.SensorChannelsContext.has_channel_type">has_channel_type</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.SensorChannelsContext.input_device_id" href="#uim.model.inkinput.inputdata.SensorChannelsContext.input_device_id">input_device_id</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.SensorChannelsContext.input_provider_id" href="#uim.model.inkinput.inputdata.SensorChannelsContext.input_provider_id">input_provider_id</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.SensorChannelsContext.latency" href="#uim.model.inkinput.inputdata.SensorChannelsContext.latency">latency</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.SensorChannelsContext.sampling_rate" href="#uim.model.inkinput.inputdata.SensorChannelsContext.sampling_rate">sampling_rate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="uim.model.inkinput.inputdata.SensorContext" href="#uim.model.inkinput.inputdata.SensorContext">SensorContext</a></code></h4>
<ul class="">
<li><code><a title="uim.model.inkinput.inputdata.SensorContext.SEPARATOR" href="#uim.model.inkinput.inputdata.SensorContext.SEPARATOR">SEPARATOR</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.SensorContext.add_sensor_channels_context" href="#uim.model.inkinput.inputdata.SensorContext.add_sensor_channels_context">add_sensor_channels_context</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.SensorContext.get_channel_by_id" href="#uim.model.inkinput.inputdata.SensorContext.get_channel_by_id">get_channel_by_id</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.SensorContext.get_channel_by_type" href="#uim.model.inkinput.inputdata.SensorContext.get_channel_by_type">get_channel_by_type</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.SensorContext.has_channel_type" href="#uim.model.inkinput.inputdata.SensorContext.has_channel_type">has_channel_type</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.SensorContext.sensor_channels_contexts" href="#uim.model.inkinput.inputdata.SensorContext.sensor_channels_contexts">sensor_channels_contexts</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="uim.model.inkinput.inputdata.Unit" href="#uim.model.inkinput.inputdata.Unit">Unit</a></code></h4>
<ul class="two-column">
<li><code><a title="uim.model.inkinput.inputdata.Unit.CM" href="#uim.model.inkinput.inputdata.Unit.CM">CM</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.Unit.DEG" href="#uim.model.inkinput.inputdata.Unit.DEG">DEG</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.Unit.DIP" href="#uim.model.inkinput.inputdata.Unit.DIP">DIP</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.Unit.IN" href="#uim.model.inkinput.inputdata.Unit.IN">IN</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.Unit.LOGICAL_VALUE" href="#uim.model.inkinput.inputdata.Unit.LOGICAL_VALUE">LOGICAL_VALUE</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.Unit.M" href="#uim.model.inkinput.inputdata.Unit.M">M</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.Unit.MM" href="#uim.model.inkinput.inputdata.Unit.MM">MM</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.Unit.MS" href="#uim.model.inkinput.inputdata.Unit.MS">MS</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.Unit.N" href="#uim.model.inkinput.inputdata.Unit.N">N</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.Unit.NS" href="#uim.model.inkinput.inputdata.Unit.NS">NS</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.Unit.PC" href="#uim.model.inkinput.inputdata.Unit.PC">PC</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.Unit.PERCENTAGE" href="#uim.model.inkinput.inputdata.Unit.PERCENTAGE">PERCENTAGE</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.Unit.PT" href="#uim.model.inkinput.inputdata.Unit.PT">PT</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.Unit.RAD" href="#uim.model.inkinput.inputdata.Unit.RAD">RAD</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.Unit.S" href="#uim.model.inkinput.inputdata.Unit.S">S</a></code></li>
<li><code><a title="uim.model.inkinput.inputdata.Unit.UNDEFINED" href="#uim.model.inkinput.inputdata.Unit.UNDEFINED">UNDEFINED</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>