<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>uim.model.helpers.text_extractor API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>uim.model.helpers.text_extractor</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
# Copyright Â© 2021 Wacom Authors. All Rights Reserved.
#
#  Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
import string
import uuid
from typing import List, Tuple, Optional

from uim.codec.parser.uim import UIMParser
from uim.model.base import InkModelException
from uim.model.helpers.treeiterator import PreOrderEnumerator
from uim.model.ink import InkModel
from uim.model.semantics.node import InkNode, StrokeGroupNode, StrokeNode
from uim.model.semantics.syntax import WORD, SEMANTIC_IS, TEXT_LINE, SEMANTIC_HAS_URI, \
    SEMANTIC_HAS_RELEVANT_CONCEPT, SEMANTIC_HAS_NAMED_ENTITY, CommonViews, SEMANTIC_HAS_TYPE


def uim_extract_text_and_semantics(uim_bytes: bytes, hwr_view: str = CommonViews.HWR_VIEW.value,
                                   ner_view: Optional[str] = None) \
        -&gt; Tuple[List[dict], List[dict]]:
    &#34;&#34;&#34;
    Extracting the text from Universal Ink Model.

    Parameters
    ----------
    uim_bytes: `bytes`
        Byte array with RIFF file from Universal Ink Model
    hwr_view: `str`
       HWR view.
    ner_view: `str`
        NER view if needed.

    Returns
    -------
    text: `List[dict]`
        List of text lines. Each line has its own dict containing the  bounding box, and all words
    entities.

    Raises
    ------
        `InkModelException`
            If the Universal Ink Model does not contain the view with the requested view name.
    &#34;&#34;&#34;
    uim_parser: UIMParser = UIMParser()
    ink_object: InkModel = uim_parser.parse(uim_bytes)
    return uim_extract_text_and_semantics_from(ink_object, hwr_view, ner_view)


def __collected_stroke_ids__(node: StrokeGroupNode) -&gt; List[uuid.UUID]:
    strokes: List[uuid.UUID] = []
    for child in node.children:
        if isinstance(child, StrokeNode):
            strokes.append(child.stroke.id)
        elif isinstance(child, StrokeGroupNode):
            strokes.extend(__collected_stroke_ids__(child))
    return strokes


def uim_extract_text_and_semantics_from(ink_model: InkModel, hwr_view: str = CommonViews.HWR_VIEW.value,
                                        ner_view: Optional[str] = None) -&gt; Tuple[List[dict], List[dict]]:
    &#34;&#34;&#34;
    Extracting the text from Universal Ink Model.

    Parameters
    ----------
    ink_model: InkModel -
        Universal Ink Model
    hwr_view: str -
       Name of the HWR view.
    ner_view: str -
        Name of the NER view if needed.

    Returns
    -------
    tuple(list of text lines (including bounding box), list knowledge uris)

    Raises
    ------
        `InkModelException`
            If the Universal Ink Model does not contain the view with the requested view name.

     Examples
    --------
    &gt;&gt;&gt; from uim.codec.parser.uim import UIMParser
    &gt;&gt;&gt; from uim.model.helpers.text_extractor import uim_extract_text_and_semantics_from
    &gt;&gt;&gt; from uim.model.ink import InkModel
    &gt;&gt;&gt; from uim.model.semantics.syntax import CommonViews, SEMANTIC_HAS_URI, SEMANTIC_HAS_LABEL, SEMANTIC_HAS_TYPE
    &gt;&gt;&gt;
    &gt;&gt;&gt; parser: UIMParser = UIMParser()
    &gt;&gt;&gt; ink_model: InkModel = parser.parse(&#39;../ink/uim_3.1.0/2) Digital Ink is processable 1 (3.1 delta).uim&#39;)
    &gt;&gt;&gt; if ink_model.has_knowledge_graph():
    &gt;&gt;&gt;     #  Extract text lines and entities from model
    &gt;&gt;&gt;     text_lines, entities = uim_extract_text_and_semantics_from(ink_model, hwr_view=CommonViews.HWR_VIEW.value,
    &gt;&gt;&gt;                                                                ner_view=CommonViews.NER_VIEW.value)
    &gt;&gt;&gt;     line_number: int = 1
    &gt;&gt;&gt;     print(&#39;---------------------------------------------------------------------------------------------------&#39;)
    &gt;&gt;&gt;     print(&#39; Text lines:&#39;)
    &gt;&gt;&gt;     print(&#39;---------------------------------------------------------------------------------------------------&#39;)
    &gt;&gt;&gt;     for line in text_lines:
    &gt;&gt;&gt;        print(f&#39;{line_number}. Text line: {line[&#34;line&#34;]} | {line[&#34;box&#34;]}&#39;)
    &gt;&gt;&gt;        word_num: int = 1
    &gt;&gt;&gt;        for word in line[&#39;words&#39;]:
    &gt;&gt;&gt;            print(f&#39; {word_num}. Word: {word[&#34;word&#34;]} | {word[&#34;box&#34;]}&#39;)
    &gt;&gt;&gt;            print(f&#39;  -&gt; Stroke UUIDs: {[str(w) for w in word[&#34;strokes&#34;]]}&#39;)
    &gt;&gt;&gt;            word_num += 1
    &gt;&gt;&gt;        line_number += 1
    &gt;&gt;&gt;     print()
    &gt;&gt;&gt;     entity_number: int = 1
    &gt;&gt;&gt;     print(&#39;---------------------------------------------------------------------------------------------------&#39;)
    &gt;&gt;&gt;     print(&#39; Entities:&#39;)
    &gt;&gt;&gt;     print(&#39;---------------------------------------------------------------------------------------------------&#39;)
    &gt;&gt;&gt;     for entity in entities:
    &gt;&gt;&gt;         print(f&#39;{entity_number}. URI: {entity[&#34;statements&#34;][SEMANTIC_HAS_URI]} - &#39;
    &gt;&gt;&gt;               f&#39;{entity[&#34;statements&#34;][SEMANTIC_HAS_LABEL]} &#39;
    &gt;&gt;&gt;               f&#39;({entity[&#34;statements&#34;][SEMANTIC_HAS_TYPE]})&#39;)
    &gt;&gt;&gt;         entity_number += 1
    &#34;&#34;&#34;
    lines: List[dict] = []
    text_nodes: dict = {}
    text_line_nodes: list = []
    ne_node_mapping: dict = {}
    uris_mapping: dict = {}
    types: List[dict] = []
    type_mapping: dict = {}
    for s in ink_model.knowledge_graph.statements:
        if s.object == WORD:
            all_statements = ink_model.knowledge_graph.all_statements_for(s.subject, predicate=SEMANTIC_IS)
            if len(all_statements) == 1:
                text_nodes[s.subject] = all_statements[0].object
        elif s.object == TEXT_LINE:
            text_line_nodes.append(s.subject)
        elif s.predicate == SEMANTIC_HAS_NAMED_ENTITY:
            if s.subject not in ne_node_mapping:
                ne_node_mapping[s.subject] = []
            ne_node_mapping[s.subject].append(s.object)
        elif s.predicate == SEMANTIC_HAS_URI:
            uris_mapping[s.subject] = s.object
        elif s.predicate == SEMANTIC_HAS_RELEVANT_CONCEPT:
            type_mapping[s.subject] = s.object
    try:
        root: InkNode = ink_model.view_root(hwr_view)
        for node in PreOrderEnumerator(root):
            # First find text lines
            if node.uri in text_line_nodes:
                line: dict = {&#39;line&#39;: &#39;&#39;, &#39;box&#39;: node.group_bounding_box, &#39;words&#39;: []}
                # Add each word to line
                for word_node in node.children:
                    if word_node.uri in text_nodes:
                        t: str = text_nodes[word_node.uri]
                        line[&#39;words&#39;].append({&#39;word&#39;: t, &#39;box&#39;: word_node.group_bounding_box,
                                              &#39;strokes&#39;: __collected_stroke_ids__(word_node)})
                        line[&#39;line&#39;] += &#39;{}&#39;.format(t if t in string.punctuation else &#39; {}&#39;.format(t))
                lines.append(line)
    except KeyError as e:
        raise InkModelException(f&#39;The  requested handwriting recognition view does not exist. {e}&#39;)
    if ner_view is not None:
        try:
            ner_root: InkNode = ink_model.view_root(ner_view)
            for group in PreOrderEnumerator(ner_root):
                if isinstance(group, StrokeGroupNode):
                    for node in group.children:
                        if node.uri in ne_node_mapping:
                            for ne_uri in ne_node_mapping[node.uri]:
                                entity: dict = {&#39;uri&#39;: ne_uri, &#39;statements&#39;: {}, &#39;strokes&#39;: []}
                                # Add statements
                                statements: list = ink_model.knowledge_graph.all_statements_for(ne_uri)
                                for st in statements:
                                    if st.predicate in [SEMANTIC_HAS_TYPE]:
                                        if st.predicate not in entity[&#39;statements&#39;]:  # List not yet created
                                            entity[&#39;statements&#39;][st.predicate] = [st.object]
                                        else:
                                            entity[&#39;statements&#39;][st.predicate].append(st.object)
                                    elif st.predicate in entity[&#39;statements&#39;]:
                                        if isinstance(entity[&#39;statements&#39;][st.predicate], list):
                                            entity[&#39;statements&#39;][st.predicate].append(st.object)
                                        else:
                                            first_entry: str = entity[&#39;statements&#39;][st.predicate]
                                            # override as list
                                            entity[&#39;statements&#39;][st.predicate] = [first_entry, st.object]
                                    else:
                                        entity[&#39;statements&#39;][st.predicate] = st.object
                                if isinstance(node, StrokeGroupNode):
                                    entity[&#39;strokes&#39;] = __collected_stroke_ids__(node)
                                types.append(dict(entity))
        except KeyError as e:
            raise InkModelException(f&#39;The  requested named entity recognition view does not exist. {e}&#39;)
    return lines, types</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="uim.model.helpers.text_extractor.uim_extract_text_and_semantics"><code class="name flex">
<span>def <span class="ident">uim_extract_text_and_semantics</span></span>(<span>uim_bytes:Â bytes, hwr_view:Â strÂ =Â 'hwr', ner_view:Â Optional[str]Â =Â None) â>Â Tuple[List[dict],Â List[dict]]</span>
</code></dt>
<dd>
<div class="desc"><p>Extracting the text from Universal Ink Model.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>uim_bytes</code></strong> :&ensp;<code>bytes</code></dt>
<dd>Byte array with RIFF file from Universal Ink Model</dd>
<dt><strong><code>hwr_view</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt>HWR view.</dt>
<dt><strong><code>ner_view</code></strong> :&ensp;<code>str</code></dt>
<dd>NER view if needed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>text</code></strong> :&ensp;<code>List[dict]</code></dt>
<dd>List of text lines. Each line has its own dict containing the
bounding box, and all words</dd>
</dl>
<p>entities.</p>
<h2 id="raises">Raises</h2>
<pre><code>&lt;code&gt;InkModelException&lt;/code&gt;
    If the Universal Ink Model does not contain the view with the requested view name.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def uim_extract_text_and_semantics(uim_bytes: bytes, hwr_view: str = CommonViews.HWR_VIEW.value,
                                   ner_view: Optional[str] = None) \
        -&gt; Tuple[List[dict], List[dict]]:
    &#34;&#34;&#34;
    Extracting the text from Universal Ink Model.

    Parameters
    ----------
    uim_bytes: `bytes`
        Byte array with RIFF file from Universal Ink Model
    hwr_view: `str`
       HWR view.
    ner_view: `str`
        NER view if needed.

    Returns
    -------
    text: `List[dict]`
        List of text lines. Each line has its own dict containing the  bounding box, and all words
    entities.

    Raises
    ------
        `InkModelException`
            If the Universal Ink Model does not contain the view with the requested view name.
    &#34;&#34;&#34;
    uim_parser: UIMParser = UIMParser()
    ink_object: InkModel = uim_parser.parse(uim_bytes)
    return uim_extract_text_and_semantics_from(ink_object, hwr_view, ner_view)</code></pre>
</details>
</dd>
<dt id="uim.model.helpers.text_extractor.uim_extract_text_and_semantics_from"><code class="name flex">
<span>def <span class="ident">uim_extract_text_and_semantics_from</span></span>(<span>ink_model:Â <a title="uim.model.ink.InkModel" href="../ink.html#uim.model.ink.InkModel">InkModel</a>, hwr_view:Â strÂ =Â 'hwr', ner_view:Â Optional[str]Â =Â None) â>Â Tuple[List[dict],Â List[dict]]</span>
</code></dt>
<dd>
<div class="desc"><p>Extracting the text from Universal Ink Model.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ink_model</code></strong> :&ensp;<code>InkModel -</code></dt>
<dd>Universal Ink Model</dd>
<dt><strong><code>hwr_view</code></strong> :&ensp;<code>str -</code></dt>
<dd>&nbsp;</dd>
<dt>Name of the HWR view.</dt>
<dt><strong><code>ner_view</code></strong> :&ensp;<code>str -</code></dt>
<dd>Name of the NER view if needed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple(list</code> of <code>text lines (including bounding box), list knowledge uris)</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<pre><code>&lt;code&gt;InkModelException&lt;/code&gt;
    If the Universal Ink Model does not contain the view with the requested view name.
</code></pre>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from uim.codec.parser.uim import UIMParser
&gt;&gt;&gt; from uim.model.helpers.text_extractor import uim_extract_text_and_semantics_from
&gt;&gt;&gt; from uim.model.ink import InkModel
&gt;&gt;&gt; from uim.model.semantics.syntax import CommonViews, SEMANTIC_HAS_URI, SEMANTIC_HAS_LABEL, SEMANTIC_HAS_TYPE
&gt;&gt;&gt;
&gt;&gt;&gt; parser: UIMParser = UIMParser()
&gt;&gt;&gt; ink_model: InkModel = parser.parse('../ink/uim_3.1.0/2) Digital Ink is processable 1 (3.1 delta).uim')
&gt;&gt;&gt; if ink_model.has_knowledge_graph():
&gt;&gt;&gt;     #  Extract text lines and entities from model
&gt;&gt;&gt;     text_lines, entities = uim_extract_text_and_semantics_from(ink_model, hwr_view=CommonViews.HWR_VIEW.value,
&gt;&gt;&gt;                                                                ner_view=CommonViews.NER_VIEW.value)
&gt;&gt;&gt;     line_number: int = 1
&gt;&gt;&gt;     print('---------------------------------------------------------------------------------------------------')
&gt;&gt;&gt;     print(' Text lines:')
&gt;&gt;&gt;     print('---------------------------------------------------------------------------------------------------')
&gt;&gt;&gt;     for line in text_lines:
&gt;&gt;&gt;        print(f'{line_number}. Text line: {line[&quot;line&quot;]} | {line[&quot;box&quot;]}')
&gt;&gt;&gt;        word_num: int = 1
&gt;&gt;&gt;        for word in line['words']:
&gt;&gt;&gt;            print(f' {word_num}. Word: {word[&quot;word&quot;]} | {word[&quot;box&quot;]}')
&gt;&gt;&gt;            print(f'  -&gt; Stroke UUIDs: {[str(w) for w in word[&quot;strokes&quot;]]}')
&gt;&gt;&gt;            word_num += 1
&gt;&gt;&gt;        line_number += 1
&gt;&gt;&gt;     print()
&gt;&gt;&gt;     entity_number: int = 1
&gt;&gt;&gt;     print('---------------------------------------------------------------------------------------------------')
&gt;&gt;&gt;     print(' Entities:')
&gt;&gt;&gt;     print('---------------------------------------------------------------------------------------------------')
&gt;&gt;&gt;     for entity in entities:
&gt;&gt;&gt;         print(f'{entity_number}. URI: {entity[&quot;statements&quot;][SEMANTIC_HAS_URI]} - '
&gt;&gt;&gt;               f'{entity[&quot;statements&quot;][SEMANTIC_HAS_LABEL]} '
&gt;&gt;&gt;               f'({entity[&quot;statements&quot;][SEMANTIC_HAS_TYPE]})')
&gt;&gt;&gt;         entity_number += 1
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def uim_extract_text_and_semantics_from(ink_model: InkModel, hwr_view: str = CommonViews.HWR_VIEW.value,
                                        ner_view: Optional[str] = None) -&gt; Tuple[List[dict], List[dict]]:
    &#34;&#34;&#34;
    Extracting the text from Universal Ink Model.

    Parameters
    ----------
    ink_model: InkModel -
        Universal Ink Model
    hwr_view: str -
       Name of the HWR view.
    ner_view: str -
        Name of the NER view if needed.

    Returns
    -------
    tuple(list of text lines (including bounding box), list knowledge uris)

    Raises
    ------
        `InkModelException`
            If the Universal Ink Model does not contain the view with the requested view name.

     Examples
    --------
    &gt;&gt;&gt; from uim.codec.parser.uim import UIMParser
    &gt;&gt;&gt; from uim.model.helpers.text_extractor import uim_extract_text_and_semantics_from
    &gt;&gt;&gt; from uim.model.ink import InkModel
    &gt;&gt;&gt; from uim.model.semantics.syntax import CommonViews, SEMANTIC_HAS_URI, SEMANTIC_HAS_LABEL, SEMANTIC_HAS_TYPE
    &gt;&gt;&gt;
    &gt;&gt;&gt; parser: UIMParser = UIMParser()
    &gt;&gt;&gt; ink_model: InkModel = parser.parse(&#39;../ink/uim_3.1.0/2) Digital Ink is processable 1 (3.1 delta).uim&#39;)
    &gt;&gt;&gt; if ink_model.has_knowledge_graph():
    &gt;&gt;&gt;     #  Extract text lines and entities from model
    &gt;&gt;&gt;     text_lines, entities = uim_extract_text_and_semantics_from(ink_model, hwr_view=CommonViews.HWR_VIEW.value,
    &gt;&gt;&gt;                                                                ner_view=CommonViews.NER_VIEW.value)
    &gt;&gt;&gt;     line_number: int = 1
    &gt;&gt;&gt;     print(&#39;---------------------------------------------------------------------------------------------------&#39;)
    &gt;&gt;&gt;     print(&#39; Text lines:&#39;)
    &gt;&gt;&gt;     print(&#39;---------------------------------------------------------------------------------------------------&#39;)
    &gt;&gt;&gt;     for line in text_lines:
    &gt;&gt;&gt;        print(f&#39;{line_number}. Text line: {line[&#34;line&#34;]} | {line[&#34;box&#34;]}&#39;)
    &gt;&gt;&gt;        word_num: int = 1
    &gt;&gt;&gt;        for word in line[&#39;words&#39;]:
    &gt;&gt;&gt;            print(f&#39; {word_num}. Word: {word[&#34;word&#34;]} | {word[&#34;box&#34;]}&#39;)
    &gt;&gt;&gt;            print(f&#39;  -&gt; Stroke UUIDs: {[str(w) for w in word[&#34;strokes&#34;]]}&#39;)
    &gt;&gt;&gt;            word_num += 1
    &gt;&gt;&gt;        line_number += 1
    &gt;&gt;&gt;     print()
    &gt;&gt;&gt;     entity_number: int = 1
    &gt;&gt;&gt;     print(&#39;---------------------------------------------------------------------------------------------------&#39;)
    &gt;&gt;&gt;     print(&#39; Entities:&#39;)
    &gt;&gt;&gt;     print(&#39;---------------------------------------------------------------------------------------------------&#39;)
    &gt;&gt;&gt;     for entity in entities:
    &gt;&gt;&gt;         print(f&#39;{entity_number}. URI: {entity[&#34;statements&#34;][SEMANTIC_HAS_URI]} - &#39;
    &gt;&gt;&gt;               f&#39;{entity[&#34;statements&#34;][SEMANTIC_HAS_LABEL]} &#39;
    &gt;&gt;&gt;               f&#39;({entity[&#34;statements&#34;][SEMANTIC_HAS_TYPE]})&#39;)
    &gt;&gt;&gt;         entity_number += 1
    &#34;&#34;&#34;
    lines: List[dict] = []
    text_nodes: dict = {}
    text_line_nodes: list = []
    ne_node_mapping: dict = {}
    uris_mapping: dict = {}
    types: List[dict] = []
    type_mapping: dict = {}
    for s in ink_model.knowledge_graph.statements:
        if s.object == WORD:
            all_statements = ink_model.knowledge_graph.all_statements_for(s.subject, predicate=SEMANTIC_IS)
            if len(all_statements) == 1:
                text_nodes[s.subject] = all_statements[0].object
        elif s.object == TEXT_LINE:
            text_line_nodes.append(s.subject)
        elif s.predicate == SEMANTIC_HAS_NAMED_ENTITY:
            if s.subject not in ne_node_mapping:
                ne_node_mapping[s.subject] = []
            ne_node_mapping[s.subject].append(s.object)
        elif s.predicate == SEMANTIC_HAS_URI:
            uris_mapping[s.subject] = s.object
        elif s.predicate == SEMANTIC_HAS_RELEVANT_CONCEPT:
            type_mapping[s.subject] = s.object
    try:
        root: InkNode = ink_model.view_root(hwr_view)
        for node in PreOrderEnumerator(root):
            # First find text lines
            if node.uri in text_line_nodes:
                line: dict = {&#39;line&#39;: &#39;&#39;, &#39;box&#39;: node.group_bounding_box, &#39;words&#39;: []}
                # Add each word to line
                for word_node in node.children:
                    if word_node.uri in text_nodes:
                        t: str = text_nodes[word_node.uri]
                        line[&#39;words&#39;].append({&#39;word&#39;: t, &#39;box&#39;: word_node.group_bounding_box,
                                              &#39;strokes&#39;: __collected_stroke_ids__(word_node)})
                        line[&#39;line&#39;] += &#39;{}&#39;.format(t if t in string.punctuation else &#39; {}&#39;.format(t))
                lines.append(line)
    except KeyError as e:
        raise InkModelException(f&#39;The  requested handwriting recognition view does not exist. {e}&#39;)
    if ner_view is not None:
        try:
            ner_root: InkNode = ink_model.view_root(ner_view)
            for group in PreOrderEnumerator(ner_root):
                if isinstance(group, StrokeGroupNode):
                    for node in group.children:
                        if node.uri in ne_node_mapping:
                            for ne_uri in ne_node_mapping[node.uri]:
                                entity: dict = {&#39;uri&#39;: ne_uri, &#39;statements&#39;: {}, &#39;strokes&#39;: []}
                                # Add statements
                                statements: list = ink_model.knowledge_graph.all_statements_for(ne_uri)
                                for st in statements:
                                    if st.predicate in [SEMANTIC_HAS_TYPE]:
                                        if st.predicate not in entity[&#39;statements&#39;]:  # List not yet created
                                            entity[&#39;statements&#39;][st.predicate] = [st.object]
                                        else:
                                            entity[&#39;statements&#39;][st.predicate].append(st.object)
                                    elif st.predicate in entity[&#39;statements&#39;]:
                                        if isinstance(entity[&#39;statements&#39;][st.predicate], list):
                                            entity[&#39;statements&#39;][st.predicate].append(st.object)
                                        else:
                                            first_entry: str = entity[&#39;statements&#39;][st.predicate]
                                            # override as list
                                            entity[&#39;statements&#39;][st.predicate] = [first_entry, st.object]
                                    else:
                                        entity[&#39;statements&#39;][st.predicate] = st.object
                                if isinstance(node, StrokeGroupNode):
                                    entity[&#39;strokes&#39;] = __collected_stroke_ids__(node)
                                types.append(dict(entity))
        except KeyError as e:
            raise InkModelException(f&#39;The  requested named entity recognition view does not exist. {e}&#39;)
    return lines, types</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="uim.model.helpers" href="index.html">uim.model.helpers</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="uim.model.helpers.text_extractor.uim_extract_text_and_semantics" href="#uim.model.helpers.text_extractor.uim_extract_text_and_semantics">uim_extract_text_and_semantics</a></code></li>
<li><code><a title="uim.model.helpers.text_extractor.uim_extract_text_and_semantics_from" href="#uim.model.helpers.text_extractor.uim_extract_text_and_semantics_from">uim_extract_text_and_semantics_from</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>