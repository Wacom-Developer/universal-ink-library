<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>uim.model.helpers.text_extractor API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>uim.model.helpers.text_extractor</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
# Copyright Â© 2021 Wacom Authors. All Rights Reserved.
#
#  Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
import string
import uuid
from typing import List, Tuple, Optional, Dict, Any

from uim.codec.parser.uim import UIMParser
from uim.model.helpers.treeiterator import PreOrderEnumerator
from uim.model.ink import InkModel
from uim.model.semantics.node import InkNode, StrokeGroupNode, StrokeNode
from uim.model.semantics.schema import WORD, TEXT_LINE, CommonViews, HAS_ALTERNATIVE, HAS_CONTENT, HAS_NAMED_ENTITY, \
    HAS_URI, HAS_LABEL


def uim_extract_text_and_semantics(uim_bytes: bytes, hwr_view: str = CommonViews.HWR_VIEW.value,
                                   ner_view: Optional[str] = None) \
        -&gt; Tuple[List[dict], List[dict]]:
    &#34;&#34;&#34;
    Extracting the text from Universal Ink Model.

    Parameters
    ----------
    uim_bytes: `bytes`
        Byte array with RIFF file from Universal Ink Model
    hwr_view: `str`
       HWR view.
    ner_view: `str`
        NER view if needed.

    Returns
    -------
    text: `List[dict]`
        List of text lines. Each line has its own dict containing the  bounding box, and all words
    entities.

    Raises
    ------
        `InkModelException`
            If the Universal Ink Model does not contain the view with the requested view name.
    &#34;&#34;&#34;
    uim_parser: UIMParser = UIMParser()
    ink_object: InkModel = uim_parser.parse(uim_bytes)
    return uim_extract_text_and_semantics_from(ink_object, hwr_view, ner_view)


def __collected_stroke_ids__(node: StrokeGroupNode) -&gt; List[uuid.UUID]:
    strokes: List[uuid.UUID] = []
    for child in node.children:
        if isinstance(child, StrokeNode):
            strokes.append(child.stroke.id)
        elif isinstance(child, StrokeGroupNode):
            strokes.extend(__collected_stroke_ids__(child))
    return strokes


def uim_extract_text_and_semantics_from(ink_model: InkModel, hwr_view: str = CommonViews.HWR_VIEW.value)\
        -&gt; Tuple[List[Dict[str, Any]], Dict[str, Dict[str, Any]], str]:
    &#34;&#34;&#34;
    Extracting the text from Universal Ink Model.

    Parameters
    ----------
    ink_model: InkModel -
        Universal Ink Model
    hwr_view: str -
       Name of the HWR view.

    Returns
    -------
    words: `List[dict]`
        List of words. Each word has its own dict containing the text, bounding box, and all alternatives.
    entities: `Dict[str, List[dict]]`
        Dictionary of entities. Each entity has its own dict containing the label, instance, and path ids.
    text: `str`
        Text extracted from the Universal Ink Model.
    Raises
    ------
        `InkModelException`
            If the Universal Ink Model does not contain the view with the requested view name.

     Examples
    --------

    &#34;&#34;&#34;
    text: str = &#39;&#39;
    words: List[Dict[str, Any]] = []
    entity_map: Dict[str, Dict[str, Any]] = {}
    root: InkNode = ink_model.view_root(str(hwr_view))
    text_nodes: Dict[str, str] = {}
    text_alternatives: Dict[str, List[str]] = {}
    text_lines: List[str] = []
    entities: Dict[str, List[Dict[str, Any]]] = {}

    # Iterate for triples with triple list and look for words
    for s in ink_model.knowledge_graph.statements:
        if s.predicate.startswith(HAS_ALTERNATIVE):
            if s.subject not in text_alternatives:
                text_alternatives[s.subject] = []
            text_alternatives[s.subject].append(s.object)
        # Collect all words
        if s.object == WORD:
            all_statements = ink_model.knowledge_graph.all_statements_for(s.subject, predicate=HAS_CONTENT)
            if len(all_statements) == 1:
                text_nodes[s.subject] = all_statements[0].object
        # Collect all entities
        if s.predicate == HAS_NAMED_ENTITY:
            all_statements = ink_model.knowledge_graph.all_statements_for(s.object)
            entity: Dict[str, Any] = {&#39;instance&#39;: s.object}
            for st in all_statements:
                if st.predicate.startswith(&#39;hasPart&#39;):
                    entity_map[st.object] = entity
                elif st.predicate == HAS_URI:
                    entity[&#39;uri&#39;] = st.object
                elif st.predicate == HAS_LABEL:
                    entity[&#39;label&#39;] = st.object
                    # Check for text lines
        elif s.object == TEXT_LINE:
            text_lines.append(s.subject)
    # Position
    pos: int = 0
    # Iterate
    for node in PreOrderEnumerator(root):
        if node.uri in text_lines:
            for word_node in node.children:
                path_ids: List[str] = [str(p.stroke.id) for p in word_node.children if isinstance(p, StrokeNode)]
                if word_node.uri in text_nodes:
                    alternatives: List[str] = text_alternatives.get(word_node.uri, [])
                    t = text_nodes[word_node.uri]
                    if t in string.punctuation or pos == 0:
                        text += t
                    else:
                        text += f&#39; {t}&#39;
                    words.append({
                        &#39;alternatives&#39;: alternatives, &#39;text&#39;: t, &#39;path_id&#39;: path_ids, &#34;word-uri&#34;: word_node.uri,
                        &#34;bounding_box&#34;: {
                            &#39;x&#39;: word_node.group_bounding_box.x,
                            &#39;y&#39;: word_node.group_bounding_box.y,
                            &#39;width&#39;: word_node.group_bounding_box.width,
                            &#39;height&#39;: word_node.group_bounding_box.height
                        }
                    })
                    # Position
                    pos += 1
                if word_node.uri in entity_map:
                    uri: str = entity_map[word_node.uri][&#39;uri&#39;]
                    if uri not in entities:
                        entities[uri] = []
                    entities[uri].append(
                        {
                            &#39;path_id&#39;: path_ids,
                            &#39;label&#39;: entity_map[word_node.uri][&#39;label&#39;],
                            &#39;instance&#39;: entity_map[word_node.uri][&#39;instance&#39;]
                        }
                    )
            text += &#39;\n&#39;
    if text.endswith(&#39;\n&#39;):
        text = text[:-1]
    return words, entities, text</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="uim.model.helpers.text_extractor.uim_extract_text_and_semantics"><code class="name flex">
<span>def <span class="ident">uim_extract_text_and_semantics</span></span>(<span>uim_bytes:Â bytes, hwr_view:Â strÂ =Â 'hwr', ner_view:Â Optional[str]Â =Â None) â>Â Tuple[List[dict],Â List[dict]]</span>
</code></dt>
<dd>
<div class="desc"><p>Extracting the text from Universal Ink Model.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>uim_bytes</code></strong> :&ensp;<code>bytes</code></dt>
<dd>Byte array with RIFF file from Universal Ink Model</dd>
<dt><strong><code>hwr_view</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt>HWR view.</dt>
<dt><strong><code>ner_view</code></strong> :&ensp;<code>str</code></dt>
<dd>NER view if needed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>text</code></strong> :&ensp;<code>List[dict]</code></dt>
<dd>List of text lines. Each line has its own dict containing the
bounding box, and all words</dd>
</dl>
<p>entities.</p>
<h2 id="raises">Raises</h2>
<pre><code>&lt;code&gt;InkModelException&lt;/code&gt;
    If the Universal Ink Model does not contain the view with the requested view name.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def uim_extract_text_and_semantics(uim_bytes: bytes, hwr_view: str = CommonViews.HWR_VIEW.value,
                                   ner_view: Optional[str] = None) \
        -&gt; Tuple[List[dict], List[dict]]:
    &#34;&#34;&#34;
    Extracting the text from Universal Ink Model.

    Parameters
    ----------
    uim_bytes: `bytes`
        Byte array with RIFF file from Universal Ink Model
    hwr_view: `str`
       HWR view.
    ner_view: `str`
        NER view if needed.

    Returns
    -------
    text: `List[dict]`
        List of text lines. Each line has its own dict containing the  bounding box, and all words
    entities.

    Raises
    ------
        `InkModelException`
            If the Universal Ink Model does not contain the view with the requested view name.
    &#34;&#34;&#34;
    uim_parser: UIMParser = UIMParser()
    ink_object: InkModel = uim_parser.parse(uim_bytes)
    return uim_extract_text_and_semantics_from(ink_object, hwr_view, ner_view)</code></pre>
</details>
</dd>
<dt id="uim.model.helpers.text_extractor.uim_extract_text_and_semantics_from"><code class="name flex">
<span>def <span class="ident">uim_extract_text_and_semantics_from</span></span>(<span>ink_model:Â <a title="uim.model.ink.InkModel" href="../ink.html#uim.model.ink.InkModel">InkModel</a>, hwr_view:Â strÂ =Â 'hwr') â>Â Tuple[List[Dict[str,Â Any]],Â Dict[str,Â Dict[str,Â Any]],Â str]</span>
</code></dt>
<dd>
<div class="desc"><p>Extracting the text from Universal Ink Model.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ink_model</code></strong> :&ensp;<code>InkModel -</code></dt>
<dd>Universal Ink Model</dd>
<dt><strong><code>hwr_view</code></strong> :&ensp;<code>str -</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>Name of the HWR view.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>words</code></strong> :&ensp;<code>List[dict]</code></dt>
<dd>List of words. Each word has its own dict containing the text, bounding box, and all alternatives.</dd>
<dt><strong><code>entities</code></strong> :&ensp;<code>Dict[str, List[dict]]</code></dt>
<dd>Dictionary of entities. Each entity has its own dict containing the label, instance, and path ids.</dd>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>Text extracted from the Universal Ink Model.</dd>
</dl>
<h2 id="raises">Raises</h2>
<pre><code>&lt;code&gt;InkModelException&lt;/code&gt;
    If the Universal Ink Model does not contain the view with the requested view name.
</code></pre>
<h2 id="examples">Examples</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def uim_extract_text_and_semantics_from(ink_model: InkModel, hwr_view: str = CommonViews.HWR_VIEW.value)\
        -&gt; Tuple[List[Dict[str, Any]], Dict[str, Dict[str, Any]], str]:
    &#34;&#34;&#34;
    Extracting the text from Universal Ink Model.

    Parameters
    ----------
    ink_model: InkModel -
        Universal Ink Model
    hwr_view: str -
       Name of the HWR view.

    Returns
    -------
    words: `List[dict]`
        List of words. Each word has its own dict containing the text, bounding box, and all alternatives.
    entities: `Dict[str, List[dict]]`
        Dictionary of entities. Each entity has its own dict containing the label, instance, and path ids.
    text: `str`
        Text extracted from the Universal Ink Model.
    Raises
    ------
        `InkModelException`
            If the Universal Ink Model does not contain the view with the requested view name.

     Examples
    --------

    &#34;&#34;&#34;
    text: str = &#39;&#39;
    words: List[Dict[str, Any]] = []
    entity_map: Dict[str, Dict[str, Any]] = {}
    root: InkNode = ink_model.view_root(str(hwr_view))
    text_nodes: Dict[str, str] = {}
    text_alternatives: Dict[str, List[str]] = {}
    text_lines: List[str] = []
    entities: Dict[str, List[Dict[str, Any]]] = {}

    # Iterate for triples with triple list and look for words
    for s in ink_model.knowledge_graph.statements:
        if s.predicate.startswith(HAS_ALTERNATIVE):
            if s.subject not in text_alternatives:
                text_alternatives[s.subject] = []
            text_alternatives[s.subject].append(s.object)
        # Collect all words
        if s.object == WORD:
            all_statements = ink_model.knowledge_graph.all_statements_for(s.subject, predicate=HAS_CONTENT)
            if len(all_statements) == 1:
                text_nodes[s.subject] = all_statements[0].object
        # Collect all entities
        if s.predicate == HAS_NAMED_ENTITY:
            all_statements = ink_model.knowledge_graph.all_statements_for(s.object)
            entity: Dict[str, Any] = {&#39;instance&#39;: s.object}
            for st in all_statements:
                if st.predicate.startswith(&#39;hasPart&#39;):
                    entity_map[st.object] = entity
                elif st.predicate == HAS_URI:
                    entity[&#39;uri&#39;] = st.object
                elif st.predicate == HAS_LABEL:
                    entity[&#39;label&#39;] = st.object
                    # Check for text lines
        elif s.object == TEXT_LINE:
            text_lines.append(s.subject)
    # Position
    pos: int = 0
    # Iterate
    for node in PreOrderEnumerator(root):
        if node.uri in text_lines:
            for word_node in node.children:
                path_ids: List[str] = [str(p.stroke.id) for p in word_node.children if isinstance(p, StrokeNode)]
                if word_node.uri in text_nodes:
                    alternatives: List[str] = text_alternatives.get(word_node.uri, [])
                    t = text_nodes[word_node.uri]
                    if t in string.punctuation or pos == 0:
                        text += t
                    else:
                        text += f&#39; {t}&#39;
                    words.append({
                        &#39;alternatives&#39;: alternatives, &#39;text&#39;: t, &#39;path_id&#39;: path_ids, &#34;word-uri&#34;: word_node.uri,
                        &#34;bounding_box&#34;: {
                            &#39;x&#39;: word_node.group_bounding_box.x,
                            &#39;y&#39;: word_node.group_bounding_box.y,
                            &#39;width&#39;: word_node.group_bounding_box.width,
                            &#39;height&#39;: word_node.group_bounding_box.height
                        }
                    })
                    # Position
                    pos += 1
                if word_node.uri in entity_map:
                    uri: str = entity_map[word_node.uri][&#39;uri&#39;]
                    if uri not in entities:
                        entities[uri] = []
                    entities[uri].append(
                        {
                            &#39;path_id&#39;: path_ids,
                            &#39;label&#39;: entity_map[word_node.uri][&#39;label&#39;],
                            &#39;instance&#39;: entity_map[word_node.uri][&#39;instance&#39;]
                        }
                    )
            text += &#39;\n&#39;
    if text.endswith(&#39;\n&#39;):
        text = text[:-1]
    return words, entities, text</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="uim.model.helpers" href="index.html">uim.model.helpers</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="uim.model.helpers.text_extractor.uim_extract_text_and_semantics" href="#uim.model.helpers.text_extractor.uim_extract_text_and_semantics">uim_extract_text_and_semantics</a></code></li>
<li><code><a title="uim.model.helpers.text_extractor.uim_extract_text_and_semantics_from" href="#uim.model.helpers.text_extractor.uim_extract_text_and_semantics_from">uim_extract_text_and_semantics_from</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>