<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>uim.codec.parser.uim API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>uim.codec.parser.uim</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
# Copyright © 2021-23 Wacom Authors. All Rights Reserved.
#
#  Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
import ctypes
import io
import logging
import os
from chunk import Chunk
from io import BytesIO
from pathlib import Path
from typing import Tuple, Any, Optional

from uim.codec.base import RIFF_HEADER, UIM_HEADER, HEAD_HEADER
from uim.codec.parser.base import Parser, FormatException, SupportedFormats
from uim.codec.parser.decoder.decoder_3_0_0 import UIMDecoder300
from uim.codec.parser.decoder.decoder_3_1_0 import UIMDecoder310
from uim.model.ink import InkModel

# Create the Logger
logger: Optional[logging.Logger] = None

if logger is None:
    logger: logging.Logger = logging.getLogger(__name__)
    logger.setLevel(logging.DEBUG)

    ch = logging.StreamHandler()
    ch.setLevel(logging.DEBUG)
    # create formatter and add it to the handlers
    formatter = logging.Formatter(&#39;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#39;)
    ch.setFormatter(formatter)
    # add the handlers to the logger
    logger.addHandler(ch)
    logger.info(&#39;Completed configuring logger()!&#39;)


class UIMParser(Parser):
    &#34;&#34;&#34;
    Parser for Universal Ink Model data codec.

    Examples
    --------
    &gt;&gt;&gt; from uim.codec.parser.uim import UIMParser
    &gt;&gt;&gt; from uim.model.ink import InkModel
    &gt;&gt;&gt; parser: UIMParser = UIMParser()
    &gt;&gt;&gt; ink_model: InkModel = parser.parse(&#39;../ink/uim_3.1.0/5) Cell Structure 1 (3.1 delta).uim&#39;)

    See also
    --------
    ´WILL2Parser´ - Parser for WILL files
    &#34;&#34;&#34;

    def __int__(self):
        pass

    @staticmethod
    def __parse_version__(stream: BytesIO) -&gt; Tuple[int, SupportedFormats]:
        head: bytes = stream.read(4)
        if head != UIM_HEADER:
            raise FormatException(&#39;Not an Universal Ink Model File.&#39;)
        if stream.read(4) != HEAD_HEADER:
            raise FormatException(&#39;Header missing.&#39;)
        size_head = ctypes.c_uint32(int.from_bytes(stream.read(4), byteorder=&#39;little&#39;)).value
        version_major = int.from_bytes(stream.read(1), byteorder=&#39;big&#39;)
        version_minor = int.from_bytes(stream.read(1), byteorder=&#39;big&#39;)
        version_patch = int.from_bytes(stream.read(1), byteorder=&#39;big&#39;)
        logger.debug(&#39;UIM Version: {}.{}.{}&#39;.format(version_major, version_minor, version_patch))
        if version_major == 3 and version_minor == 0 and version_patch == 0:
            return size_head, SupportedFormats.UIM_VERSION_3_0_0
        elif version_major == 3 and version_minor == 1 and version_patch == 0:
            return size_head, SupportedFormats.UIM_VERSION_3_1_0
        return size_head, SupportedFormats.NOT_SUPPORTED

    @classmethod
    def parse_json(cls, path: Any) -&gt; InkModel:
        &#34;&#34;&#34;
        Parse ink file from either a `Path`, `str`.

        Parameters
        ----------
        path: Any
            Location of the JSON file

        Returns
        -------
           model - `InkModel`
               Parsed `InkModel` from UIM encoded stream
        &#34;&#34;&#34;
        if isinstance(path, (str, Path)):
            # Check if path does exist
            if not os.path.exists(path):
                raise FormatException(f&#39;UIM file with path: {str(path)} does not exist.&#39;)
            # Check if the file ends with JSON extension
            json_encoding: bool = str(path).lower().endswith(&#34;.json&#34;)
            # Read file
            with io.open(path, &#39;rb&#39;) as fp:
                if json_encoding:
                    logger.info(&#39;JSON decoder chosen.&#39;)
                    # Content parser
                    return UIMDecoder300.decode_json(fp)

    def parse(self, path_or_stream: Any) -&gt; InkModel:
        &#34;&#34;&#34;
        Parse the Universal Ink Model codec.

        Parameters
        ----------
        path_or_stream: Any
            `Path` of file, path as str, stream, or byte array.

        Returns
        -------
           model - `InkModel`
               Parsed `InkModel` from UIM encoded stream
        &#34;&#34;&#34;
        if isinstance(path_or_stream, (str, Path)):
            # Check if path does exist
            if not os.path.exists(path_or_stream):
                raise FormatException(f&#39;UIM file with path: {str(path_or_stream)} does not exist.&#39;)
            # Read file
            with io.open(path_or_stream, &#39;rb&#39;) as fp:
                logger.info(&#39;RIFF decoder chosen.&#39;)
                riff_file: Chunk = Chunk(fp, bigendian=False)
                if riff_file.getname() != RIFF_HEADER:
                    raise FormatException(&#39;File does not start with RIFF id&#39;)
                logger.info(f&#39;Data packet size: {riff_file.getsize()}&#39;)
                riff: BytesIO = BytesIO(riff_file.read())
                riff_size: int = riff_file.getsize()
        else:
            # Read In-Memory
            if isinstance(path_or_stream, (bytes, memoryview)):
                riff: BytesIO = BytesIO(path_or_stream)
            elif isinstance(path_or_stream, BytesIO):
                riff: BytesIO = path_or_stream
            else:
                raise TypeError(&#39;parse() accepts path (str) or stream (bytes, BytesIO)&#39;)
            # Read header
            header: bytes = riff.read(4)
            # Read the stream
            if header != RIFF_HEADER:
                raise FormatException(&#39;Stream does not start with RIFF id&#39;)
            # Read package size
            size_packet: bytes = riff.read(4)
            riff_size: int = ctypes.c_uint32(int.from_bytes(size_packet, byteorder=&#39;little&#39;)).value
        logger.info(f&#39;Data packet size: {riff_size}&#39;)
        size_head, version = UIMParser.__parse_version__(riff)
        if version == SupportedFormats.UIM_VERSION_3_0_0:
            return UIMDecoder300.decode(riff, size_head)
        elif version == SupportedFormats.UIM_VERSION_3_1_0:
            return UIMDecoder310.decode(riff, size_head)
        raise FormatException(f&#34;Parser does not support this format. {version}&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="uim.codec.parser.uim.UIMParser"><code class="flex name class">
<span>class <span class="ident">UIMParser</span></span>
</code></dt>
<dd>
<div class="desc"><p>Parser for Universal Ink Model data codec.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from uim.codec.parser.uim import UIMParser
&gt;&gt;&gt; from uim.model.ink import InkModel
&gt;&gt;&gt; parser: UIMParser = UIMParser()
&gt;&gt;&gt; ink_model: InkModel = parser.parse('../ink/uim_3.1.0/5) Cell Structure 1 (3.1 delta).uim')
</code></pre>
<h2 id="see-also">See Also</h2>
<p><code>´WILL2Parser´ - Parser for WILL files</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UIMParser(Parser):
    &#34;&#34;&#34;
    Parser for Universal Ink Model data codec.

    Examples
    --------
    &gt;&gt;&gt; from uim.codec.parser.uim import UIMParser
    &gt;&gt;&gt; from uim.model.ink import InkModel
    &gt;&gt;&gt; parser: UIMParser = UIMParser()
    &gt;&gt;&gt; ink_model: InkModel = parser.parse(&#39;../ink/uim_3.1.0/5) Cell Structure 1 (3.1 delta).uim&#39;)

    See also
    --------
    ´WILL2Parser´ - Parser for WILL files
    &#34;&#34;&#34;

    def __int__(self):
        pass

    @staticmethod
    def __parse_version__(stream: BytesIO) -&gt; Tuple[int, SupportedFormats]:
        head: bytes = stream.read(4)
        if head != UIM_HEADER:
            raise FormatException(&#39;Not an Universal Ink Model File.&#39;)
        if stream.read(4) != HEAD_HEADER:
            raise FormatException(&#39;Header missing.&#39;)
        size_head = ctypes.c_uint32(int.from_bytes(stream.read(4), byteorder=&#39;little&#39;)).value
        version_major = int.from_bytes(stream.read(1), byteorder=&#39;big&#39;)
        version_minor = int.from_bytes(stream.read(1), byteorder=&#39;big&#39;)
        version_patch = int.from_bytes(stream.read(1), byteorder=&#39;big&#39;)
        logger.debug(&#39;UIM Version: {}.{}.{}&#39;.format(version_major, version_minor, version_patch))
        if version_major == 3 and version_minor == 0 and version_patch == 0:
            return size_head, SupportedFormats.UIM_VERSION_3_0_0
        elif version_major == 3 and version_minor == 1 and version_patch == 0:
            return size_head, SupportedFormats.UIM_VERSION_3_1_0
        return size_head, SupportedFormats.NOT_SUPPORTED

    @classmethod
    def parse_json(cls, path: Any) -&gt; InkModel:
        &#34;&#34;&#34;
        Parse ink file from either a `Path`, `str`.

        Parameters
        ----------
        path: Any
            Location of the JSON file

        Returns
        -------
           model - `InkModel`
               Parsed `InkModel` from UIM encoded stream
        &#34;&#34;&#34;
        if isinstance(path, (str, Path)):
            # Check if path does exist
            if not os.path.exists(path):
                raise FormatException(f&#39;UIM file with path: {str(path)} does not exist.&#39;)
            # Check if the file ends with JSON extension
            json_encoding: bool = str(path).lower().endswith(&#34;.json&#34;)
            # Read file
            with io.open(path, &#39;rb&#39;) as fp:
                if json_encoding:
                    logger.info(&#39;JSON decoder chosen.&#39;)
                    # Content parser
                    return UIMDecoder300.decode_json(fp)

    def parse(self, path_or_stream: Any) -&gt; InkModel:
        &#34;&#34;&#34;
        Parse the Universal Ink Model codec.

        Parameters
        ----------
        path_or_stream: Any
            `Path` of file, path as str, stream, or byte array.

        Returns
        -------
           model - `InkModel`
               Parsed `InkModel` from UIM encoded stream
        &#34;&#34;&#34;
        if isinstance(path_or_stream, (str, Path)):
            # Check if path does exist
            if not os.path.exists(path_or_stream):
                raise FormatException(f&#39;UIM file with path: {str(path_or_stream)} does not exist.&#39;)
            # Read file
            with io.open(path_or_stream, &#39;rb&#39;) as fp:
                logger.info(&#39;RIFF decoder chosen.&#39;)
                riff_file: Chunk = Chunk(fp, bigendian=False)
                if riff_file.getname() != RIFF_HEADER:
                    raise FormatException(&#39;File does not start with RIFF id&#39;)
                logger.info(f&#39;Data packet size: {riff_file.getsize()}&#39;)
                riff: BytesIO = BytesIO(riff_file.read())
                riff_size: int = riff_file.getsize()
        else:
            # Read In-Memory
            if isinstance(path_or_stream, (bytes, memoryview)):
                riff: BytesIO = BytesIO(path_or_stream)
            elif isinstance(path_or_stream, BytesIO):
                riff: BytesIO = path_or_stream
            else:
                raise TypeError(&#39;parse() accepts path (str) or stream (bytes, BytesIO)&#39;)
            # Read header
            header: bytes = riff.read(4)
            # Read the stream
            if header != RIFF_HEADER:
                raise FormatException(&#39;Stream does not start with RIFF id&#39;)
            # Read package size
            size_packet: bytes = riff.read(4)
            riff_size: int = ctypes.c_uint32(int.from_bytes(size_packet, byteorder=&#39;little&#39;)).value
        logger.info(f&#39;Data packet size: {riff_size}&#39;)
        size_head, version = UIMParser.__parse_version__(riff)
        if version == SupportedFormats.UIM_VERSION_3_0_0:
            return UIMDecoder300.decode(riff, size_head)
        elif version == SupportedFormats.UIM_VERSION_3_1_0:
            return UIMDecoder310.decode(riff, size_head)
        raise FormatException(f&#34;Parser does not support this format. {version}&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="uim.codec.parser.base.Parser" href="base.html#uim.codec.parser.base.Parser">Parser</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="uim.codec.parser.uim.UIMParser.parse_json"><code class="name flex">
<span>def <span class="ident">parse_json</span></span>(<span>path: Any) ‑> <a title="uim.model.ink.InkModel" href="../../model/ink.html#uim.model.ink.InkModel">InkModel</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse ink file from either a <code>Path</code>, <code>str</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>Any</code></dt>
<dd>Location of the JSON file</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>model - <code>InkModel</code>
Parsed <code>InkModel</code> from UIM encoded stream</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse_json(cls, path: Any) -&gt; InkModel:
    &#34;&#34;&#34;
    Parse ink file from either a `Path`, `str`.

    Parameters
    ----------
    path: Any
        Location of the JSON file

    Returns
    -------
       model - `InkModel`
           Parsed `InkModel` from UIM encoded stream
    &#34;&#34;&#34;
    if isinstance(path, (str, Path)):
        # Check if path does exist
        if not os.path.exists(path):
            raise FormatException(f&#39;UIM file with path: {str(path)} does not exist.&#39;)
        # Check if the file ends with JSON extension
        json_encoding: bool = str(path).lower().endswith(&#34;.json&#34;)
        # Read file
        with io.open(path, &#39;rb&#39;) as fp:
            if json_encoding:
                logger.info(&#39;JSON decoder chosen.&#39;)
                # Content parser
                return UIMDecoder300.decode_json(fp)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="uim.codec.parser.uim.UIMParser.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self, path_or_stream: Any) ‑> <a title="uim.model.ink.InkModel" href="../../model/ink.html#uim.model.ink.InkModel">InkModel</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse the Universal Ink Model codec.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path_or_stream</code></strong> :&ensp;<code>Any</code></dt>
<dd><code>Path</code> of file, path as str, stream, or byte array.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>model - <code>InkModel</code>
Parsed <code>InkModel</code> from UIM encoded stream</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(self, path_or_stream: Any) -&gt; InkModel:
    &#34;&#34;&#34;
    Parse the Universal Ink Model codec.

    Parameters
    ----------
    path_or_stream: Any
        `Path` of file, path as str, stream, or byte array.

    Returns
    -------
       model - `InkModel`
           Parsed `InkModel` from UIM encoded stream
    &#34;&#34;&#34;
    if isinstance(path_or_stream, (str, Path)):
        # Check if path does exist
        if not os.path.exists(path_or_stream):
            raise FormatException(f&#39;UIM file with path: {str(path_or_stream)} does not exist.&#39;)
        # Read file
        with io.open(path_or_stream, &#39;rb&#39;) as fp:
            logger.info(&#39;RIFF decoder chosen.&#39;)
            riff_file: Chunk = Chunk(fp, bigendian=False)
            if riff_file.getname() != RIFF_HEADER:
                raise FormatException(&#39;File does not start with RIFF id&#39;)
            logger.info(f&#39;Data packet size: {riff_file.getsize()}&#39;)
            riff: BytesIO = BytesIO(riff_file.read())
            riff_size: int = riff_file.getsize()
    else:
        # Read In-Memory
        if isinstance(path_or_stream, (bytes, memoryview)):
            riff: BytesIO = BytesIO(path_or_stream)
        elif isinstance(path_or_stream, BytesIO):
            riff: BytesIO = path_or_stream
        else:
            raise TypeError(&#39;parse() accepts path (str) or stream (bytes, BytesIO)&#39;)
        # Read header
        header: bytes = riff.read(4)
        # Read the stream
        if header != RIFF_HEADER:
            raise FormatException(&#39;Stream does not start with RIFF id&#39;)
        # Read package size
        size_packet: bytes = riff.read(4)
        riff_size: int = ctypes.c_uint32(int.from_bytes(size_packet, byteorder=&#39;little&#39;)).value
    logger.info(f&#39;Data packet size: {riff_size}&#39;)
    size_head, version = UIMParser.__parse_version__(riff)
    if version == SupportedFormats.UIM_VERSION_3_0_0:
        return UIMDecoder300.decode(riff, size_head)
    elif version == SupportedFormats.UIM_VERSION_3_1_0:
        return UIMDecoder310.decode(riff, size_head)
    raise FormatException(f&#34;Parser does not support this format. {version}&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="uim.codec.parser" href="index.html">uim.codec.parser</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="uim.codec.parser.uim.UIMParser" href="#uim.codec.parser.uim.UIMParser">UIMParser</a></code></h4>
<ul class="">
<li><code><a title="uim.codec.parser.uim.UIMParser.parse" href="#uim.codec.parser.uim.UIMParser.parse">parse</a></code></li>
<li><code><a title="uim.codec.parser.uim.UIMParser.parse_json" href="#uim.codec.parser.uim.UIMParser.parse_json">parse_json</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>