Module uim.codec.parser.will
============================

Classes
-------

`Path(**kwargs)`
:   Abstract base class for protocol messages.
    
    Protocol message classes are almost always generated by the protocol
    compiler.  These generated types subclass Message and implement the methods
    shown below.

    ### Ancestors (in MRO)

    * google.protobuf.message.Message

    ### Class variables

    `COMPOSITEOPERATION_FIELD_NUMBER`
    :

    `DATA_FIELD_NUMBER`
    :

    `DECIMALPRECISION_FIELD_NUMBER`
    :

    `DESCRIPTOR`
    :

    `ENDPARAMETER_FIELD_NUMBER`
    :

    `ID_FIELD_NUMBER`
    :

    `STARTPARAMETER_FIELD_NUMBER`
    :

    `STROKECOLOR_FIELD_NUMBER`
    :

    `STROKEPAINT_FIELD_NUMBER`
    :

    `STROKEPARTICLESRANDOMSEED_FIELD_NUMBER`
    :

    `STROKEWIDTH_FIELD_NUMBER`
    :

    ### Static methods

    `FromString(s)`
    :

    `RegisterExtension(extension_handle)`
    :

    ### Instance variables

    `compositeOperation`
    :   Getter for compositeOperation.

    `data`
    :   Getter for data.

    `decimalPrecision`
    :   Getter for decimalPrecision.

    `endParameter`
    :   Getter for endParameter.

    `id`
    :   Getter for id.

    `startParameter`
    :   Getter for startParameter.

    `strokeColor`
    :   Getter for strokeColor.

    `strokePaint`
    :   Getter for strokePaint.

    `strokeParticlesRandomSeed`
    :   Getter for strokeParticlesRandomSeed.

    `strokeWidth`
    :   Getter for strokeWidth.

    ### Methods

    `ByteSize(self)`
    :

    `Clear(self)`
    :

    `ClearField(self, field_name)`
    :

    `DiscardUnknownFields(self)`
    :

    `FindInitializationErrors(self)`
    :   Finds required fields which are not initialized.
        
        Returns:
          A list of strings.  Each string is a path to an uninitialized field from
          the top-level message, e.g. "foo.bar[5].baz".

    `HasField(self, field_name)`
    :

    `IsInitialized(self, errors=None)`
    :   Checks if all required fields of a message are set.
        
        Args:
          errors:  A list which, if provided, will be populated with the field
                   paths of all missing required fields.
        
        Returns:
          True iff the specified message has all required fields set.

    `ListFields(self)`
    :

    `MergeFrom(self, msg)`
    :

    `MergeFromString(self, serialized)`
    :

    `SerializePartialToString(self, **kwargs)`
    :

    `SerializeToString(self, **kwargs)`
    :

    `SetInParent(self)`
    :   Sets the _cached_byte_size_dirty bit to true,
        and propagates this to our listener iff this was a state change.

    `UnknownFields(self)`
    :

    `WhichOneof(self, oneof_name)`
    :   Returns the name of the currently set field inside a oneof, or None.

`WILL2Parser()`
:   WILL2Parser
    ===========
    
    Parser for Wacom Ink Layer Language - Data and File format.
    
    Examples
    --------
    >>> from uim.codec.parser.will import WILL2Parser
    >>> from uim.model.ink import InkModel
    >>> parser: WILL2Parser = WILL2Parser()
    >>> ink_model: InkModel = parser.parse('../ink/will/apple.will')
    
    See also
    --------
    ´UIMParser´ - Parser for UIM files
    
    Notes
    -----
    The WILL2Parser is deprecated and will be removed in a future version.

    ### Ancestors (in MRO)

    * uim.codec.parser.base.Parser
    * abc.ABC

    ### Class variables

    `APPLICATION: str`
    :   Application property tag.

    `APP_VERSION: str`
    :   App version property tag.

    `BRUSH: Dict[str, Any]`
    :   Default brush configuration.

    `DEFAULT_APPLICATION_NAME: str`
    :

    `DEFAULT_APPLICATION_VERSION: float`
    :

    `DEFAULT_DATETIME_FORMAT: str`
    :

    `DEFAULT_DECIMAL_PRECISION: int`
    :

    `DEFAULT_PATH_WIDTH: int`
    :

    `DEFAULT_TIME_STEP: float`
    :   Sampling rate of 120 Hz roughly 8 ms.

    `DEFAULT_WRITE_FORMAT: str`
    :

    `INK_DEVICE_BAMBOO_SLATE: str`
    :

    `INK_DEVICE_BAMBOO_SPARK: str`
    :

    `NODE_URI_PREFIX: str`
    :

    `SOURCE_OVER: int`
    :

    ### Methods

    `parse(self, path_or_stream: Union[str, bytes, memoryview, _io.BytesIO, will_message_format_pb2.Path]) ‑> uim.model.ink.InkModel`
    :   Parse the content of a WILL data or file format encoded ink file to the Universal Ink memory model.
        
        Parameters
        ----------
        path_or_stream: Any
            `Path` of file, path as str, stream, or byte array.
        
        Returns
        -------
           model - `InkModel`
               Parsed `InkModel` from UIM encoded stream