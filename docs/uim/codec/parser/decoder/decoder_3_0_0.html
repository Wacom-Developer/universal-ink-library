<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>uim.codec.parser.decoder.decoder_3_0_0 API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>uim.codec.parser.decoder.decoder_3_0_0</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
# Copyright © 2021-23 Wacom Authors. All Rights Reserved.
#
#  Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
import ctypes
import uuid
from io import BytesIO
from typing import List, BinaryIO, Dict, Optional

from google.protobuf import json_format

import uim.codec.format.UIM_3_0_0_pb2 as uim_3_0_0
from uim.codec.base import DATA_HEADER
from uim.codec.context.decoder import DecoderContext
from uim.codec.parser.base import FormatException, SupportedFormats
from uim.codec.parser.decoder.base import CodecDecoder
from uim.model.base import UUIDIdentifier, Identifier
from uim.model.ink import InkModel, InkTree
from uim.model.inkdata.brush import RasterBrush, VectorBrush, BrushPolygon, BlendMode, BrushPolygonUri, RotationMode
from uim.model.inkdata.strokes import Stroke, Style, PathPointProperties
from uim.model.inkinput.inputdata import InkSensorType, InputContext, SensorContext, SensorChannel, \
    InkSensorMetricType, InkInputType, InputDevice, InkInputProvider, Environment, SensorChannelsContext, DataType
from uim.model.inkinput.sensordata import SensorData, ChannelData, InkState
from uim.model.semantics.node import BoundingBox, StrokeNode, StrokeGroupNode
from uim.model.semantics.schema import CommonViews


class UIMDecoder300(CodecDecoder):
    &#34;&#34;&#34;
    The UIMDecoder300 decodes the Universal Ink Model v3.0.0 and maps it into the model for v3.1.0.

    References
    ----------
    [1]  Universal Ink Model documentation - URL https://developer-docs.wacom.com/sdk-for-ink/docs/model
    &#34;&#34;&#34;

    MAP_INK_METRICS_TYPE: Dict[int, InkSensorMetricType] = {
        uim_3_0_0.LENGTH: InkSensorMetricType.LENGTH,
        uim_3_0_0.TIME: InkSensorMetricType.TIME,
        uim_3_0_0.FORCE: InkSensorMetricType.FORCE,
        uim_3_0_0.ANGLE: InkSensorMetricType.ANGLE,
        uim_3_0_0.NORMALIZED: InkSensorMetricType.NORMALIZED
    }
    &#34;&#34;&#34;Mapping metric types from UIM v3.0.0 to internal enum.&#34;&#34;&#34;

    MAP_STATE_TYPE: Dict[int, InkState] = {
        uim_3_0_0.PLANE: InkState.PLANE,
        uim_3_0_0.HOVERING: InkState.HOVERING,
        uim_3_0_0.IN_VOLUME: InkState.IN_VOLUME,
        uim_3_0_0.VOLUME_HOVERING: InkState.VOLUME_HOVERING
    }
    &#34;&#34;&#34;Mapping of the uim input data states.&#34;&#34;&#34;

    MAP_CHANNEL_TYPE: Dict[int, InkSensorType] = {
        InkSensorType.X.value: InkSensorType.X,
        InkSensorType.Y.value: InkSensorType.Y,
        InkSensorType.Z.value: InkSensorType.Z,
        InkSensorType.TIMESTAMP.value: InkSensorType.TIMESTAMP,
        InkSensorType.PRESSURE.value: InkSensorType.PRESSURE,
        InkSensorType.AZIMUTH.value: InkSensorType.AZIMUTH,
        InkSensorType.ALTITUDE.value: InkSensorType.ALTITUDE,
        InkSensorType.ROTATION.value: InkSensorType.ROTATION,
        InkSensorType.RADIUS_X.value: InkSensorType.RADIUS_X,
        InkSensorType.RADIUS_Y.value: InkSensorType.RADIUS_Y
    }
    &#34;&#34;&#34;Mapping for channel type.&#34;&#34;&#34;

    MAP_INPUT_PROVIDER_TYPE: Dict[int, InkInputType] = {
        InkInputType.PEN.value: InkInputType.PEN,
        InkInputType.TOUCH.value: InkInputType.TOUCH,
        InkInputType.CONTROLLER.value: InkInputType.CONTROLLER,
        InkInputType.MOUSE.value: InkInputType.MOUSE
    }
    &#34;&#34;&#34;Mapping for input provider.&#34;&#34;&#34;

    MAP_BLEND_MODE: Dict[int, BlendMode] = {
        uim_3_0_0.SOURCE_OVER: BlendMode.SOURCE_OVER,
        uim_3_0_0.DESTINATION_OVER: BlendMode.DESTINATION_OVER,
        uim_3_0_0.DESTINATION_OUT: BlendMode.DESTINATION_OUT,
        uim_3_0_0.LIGHTER: BlendMode.LIGHTER,
        uim_3_0_0.COPY: BlendMode.COPY,
        uim_3_0_0.MIN: BlendMode.MIN,
        uim_3_0_0.MAX: BlendMode.MAX
    }
    &#34;&#34;&#34;Mapping for blending mode.&#34;&#34;&#34;

    # Map for rotation mode
    MAP_ROTATION_MODE: Dict[int, RotationMode] = {
        uim_3_0_0.NONE: RotationMode.NONE,
        uim_3_0_0.RANDOM: RotationMode.RANDOM,
        uim_3_0_0.TRAJECTORY: RotationMode.TRAJECTORY
    }

    def __init__(self):
        pass

    @classmethod
    def decode(cls, riff: BytesIO, size_head: int) -&gt; InkModel:
        &#34;&#34;&#34;
        Decoding Universal Ink Model (RIFF / Protobuf encoded) content file.

        Parameters
        ----------
        riff: `BytesIO`
            RIFF content with encoded UIM v3.0.0 content.
        size_head: `int`
            Size of  the header

        Returns
        -------
            model - `InkModel`
                Parsed `InkModel` from UIM v3.0.0 ink content
        &#34;&#34;&#34;
        riff.read((size_head - 3) + 1)
        if riff.read(4) != DATA_HEADER:
            raise FormatException(&#39;Data header missing.&#39;)
        data_size = ctypes.c_uint32(int.from_bytes(riff.read(4), byteorder=&#39;little&#39;)).value
        message: bytes = riff.read(data_size)
        # read document
        document: uim_3_0_0.InkObject = uim_3_0_0.InkObject()
        document.ParseFromString(message)
        return UIMDecoder300.decode_document(document)

    @classmethod
    def decode_json(cls, fp: BinaryIO) -&gt; InkModel:
        &#34;&#34;&#34;
        Decoding Universal Ink Model (JSON Protobuf encoded) content file.

        Parameters
        ----------
        fp: `BinaryIO`
            JSON with encoded UIM v3.0.0 content.

        Returns
        -------
            model - `InkModel`
                Parsed `InkModel` from UIM v3.0.0 ink content
        &#34;&#34;&#34;
        message = fp.read()
        document: uim_3_0_0.InkObject = uim_3_0_0.InkObject()
        document: uim_3_0_0.InkObject = json_format.Parse(message, document)
        return UIMDecoder300.decode_document(document)

    @classmethod
    def decode_document(cls, document: uim_3_0_0.InkObject) -&gt; InkModel:
        &#34;&#34;&#34;
        Decoding Protobuf content file.

        Parameters
        ----------
        document: `uim_3_0_0.InkObject`
            Parsed protobuf structure.

        Returns
        -------
            model - `InkModel`
                Parsed `InkModel` from UIM v3.0.0 ink content
        &#34;&#34;&#34;
        context: DecoderContext = DecoderContext(version=SupportedFormats.UIM_VERSION_3_0_0.value,
                                                 ink_model=InkModel(SupportedFormats.UIM_VERSION_3_0_0.value))
        # Set properties
        context.ink_model.properties = CodecDecoder.__parse_properties__(document.properties)
        # Parse input data
        UIMDecoder300.__parse_input_data__(context, document.inputData)
        # Parse ink data
        UIMDecoder300.__parse_ink_data__(context, document.inkData)
        # Parse brushes
        UIMDecoder300.__parse_brushes__(context, document.brushes)
        # Parse main tree
        UIMDecoder300.__parse_ink_tree__(context, document.inkTree, CommonViews.MAIN_INK_TREE.value)
        # Parse view
        for view in document.views:
            UIMDecoder300.__parse_ink_tree__(context, view.tree, view.name)
        # Parse knowledge graph
        UIMDecoder300.__parse_knowledge_graph__(context, document.knowledgeGraph)
        # Finally upgrade the URIs
        context.upgrade_uris()
        return context.ink_model

    @classmethod
    def __parse_input_data__(cls, context: DecoderContext, input_data: uim_3_0_0.InputData):
        input_context_data: uim_3_0_0.InputContextData = input_data.inputContextData
        # Parse Input Contexts
        for inputContext in input_context_data.inputContexts:
            input_context: InputContext = InputContext(
                UUIDIdentifier.str_to_uimid(inputContext.id),
                UUIDIdentifier.str_to_uimid(inputContext.environmentID),
                UUIDIdentifier.str_to_uimid(inputContext.sensorContextID))
            context.ink_model.input_configuration.input_contexts.append(input_context)

        # Parse Ink Input Providers
        for inkInputProvider in input_context_data.inkInputProviders:
            properties = CodecDecoder.__parse_properties__(inkInputProvider.properties)
            ink_input_provider = InkInputProvider(
                UUIDIdentifier.str_to_uimid(inkInputProvider.id),
                UIMDecoder300.MAP_INPUT_PROVIDER_TYPE[inkInputProvider.type],
                properties
            )
            context.ink_model.input_configuration.ink_input_providers.append(ink_input_provider)

        # Parse Input Devices
        for inputDevice in input_context_data.inputDevices:
            properties = CodecDecoder.__parse_properties__(inputDevice.properties)
            input_device: InputDevice = InputDevice(
                UUIDIdentifier.str_to_uimid(inputDevice.id),
                properties
            )
            context.ink_model.input_configuration.devices.append(input_device)

        # Parse Environments
        for environment in input_context_data.environments:
            properties = CodecDecoder.__parse_properties__(environment.properties)
            environment = Environment(UUIDIdentifier.str_to_uimid(environment.id), properties)
            context.ink_model.input_configuration.environments.append(environment)

        # Parse Sensor Data Contexts
        for sensorContext in input_context_data.sensorContexts:
            sensor_channels_contexts: list = []

            # Parse Sensor Channels Contexts
            for sensorChannelsContext in sensorContext.sensorChannelsContext:
                channels: list = []
                input_provider_uuid: Optional[uuid.UUID] = None
                if sensorChannelsContext.inkInputProviderID:
                    input_provider_uuid = Identifier.str_to_uimid(sensorChannelsContext.inkInputProviderID)
                # Parse Sensor Channels
                for sensorChannel in sensorChannelsContext.channels:
                    sensor_channel: SensorChannel = SensorChannel(
                        UUIDIdentifier.str_to_uimid(sensorChannel.id),
                        UIMDecoder300.MAP_CHANNEL_TYPE[sensorChannel.type],
                        UIMDecoder300.MAP_INK_METRICS_TYPE[sensorChannel.metric],
                        sensorChannel.resolution,
                        sensorChannel.min,
                        sensorChannel.max,
                        sensorChannel.precision,
                        data_type=DataType.FLOAT32,
                        ink_input_provider_id=input_provider_uuid,
                        input_device_id=Identifier.str_to_uimid(sensorChannelsContext.inputDeviceID)
                    )
                    channels.append(sensor_channel)
                input_provider_uuid: Optional[uuid.UUID] = None
                if sensorChannelsContext.inkInputProviderID:
                    input_provider_uuid = Identifier.str_to_uimid(sensorChannelsContext.inkInputProviderID)
                sensor_channel_context: SensorChannelsContext = SensorChannelsContext(
                    Identifier.str_to_uimid(sensorChannelsContext.id),
                    channels,
                    sensorChannelsContext.samplingRateHint.value,
                    sensorChannelsContext.latency.value,
                    input_provider_uuid,
                    Identifier.str_to_uimid(sensorChannelsContext.inputDeviceID),
                )
                sensor_channels_contexts.append(sensor_channel_context)
            sensor_context: SensorContext = SensorContext(
                Identifier.str_to_uimid(sensorContext.id),
                sensor_channels_contexts
            )
            context.ink_model.input_configuration.sensor_contexts.append(sensor_context)

        # Parse Sensor Data
        sensor_data_array: list = []
        for sensorData in input_data.sensorData:
            input_context: InputContext = context.ink_model. \
                input_configuration.get_input_context(Identifier.str_to_uimid(sensorData.inputContextID))
            sensor_ctx: SensorContext = context.ink_model.input_configuration. \
                get_sensor_context(input_context.sensor_context_id)
            # Add sensor data
            sensor_data: SensorData = SensorData(
                Identifier.str_to_uimid(sensorData.id),
                Identifier.str_to_uimid(sensorData.inputContextID),
                UIMDecoder300.MAP_STATE_TYPE[sensorData.state],
                sensorData.timestamp
            )
            for dataChannel in sensorData.dataChannels:
                sensor_type: SensorChannel = sensor_ctx.get_channel_by_id(
                    Identifier.str_to_uimid(dataChannel.sensorChannelID)
                )
                if sensor_type.type == InkSensorType.TIMESTAMP:
                    ctx: SensorChannel = sensor_ctx.get_channel_by_id(
                        Identifier.str_to_uimid(dataChannel.sensorChannelID))
                    channel_data: ChannelData = ChannelData(
                        Identifier.str_to_uimid(dataChannel.sensorChannelID),
                        CodecDecoder.__decode__(dataChannel.values, ctx.precision, ctx.resolution,
                                                start_value=sensorData.timestamp, data_type=float),
                    )
                else:
                    ctx: SensorChannel = sensor_ctx.get_channel_by_id(
                        Identifier.str_to_uimid(dataChannel.sensorChannelID)
                    )
                    channel_data: ChannelData = ChannelData(
                        Identifier.str_to_uimid(dataChannel.sensorChannelID),
                        CodecDecoder.__decode__(dataChannel.values, ctx.precision, ctx.resolution),
                    )
                sensor_data.add_data(sensor_type, channel_data.values)

            sensor_data_array.append(sensor_data)

        context.ink_model.sensor_data.sensor_data = sensor_data_array

    @classmethod
    def __parse_ink_data__(cls, context: DecoderContext, ink_data: uim_3_0_0.InkData):
        # Iterate over strokes
        for p in ink_data.strokes:
            properties = p.style.properties
            path_point_properties: PathPointProperties = PathPointProperties(
                properties.size.value,
                properties.red.value,
                properties.green.value,
                properties.blue.value,
                properties.alpha.value,
                properties.rotation.value,
                properties.scaleX.value,
                properties.scaleY.value,
                properties.scaleZ.value,
                properties.offsetX.value,
                properties.offsetY.value,
                properties.offsetZ.value,
            )
            style: Style = Style(
                path_point_properties,
                p.style.brushURI,
                p.style.particlesRandomSeed,
                p.style.renderModeURI
            )
            sensor_id: Optional[uuid.UUID] = None
            if p.sensorDataID:
                sensor_id = Identifier.str_to_uimid(p.sensorDataID)
            stroke: Stroke = Stroke(
                Identifier.str_to_uimid(p.id),
                p.sensorDataOffset,
                sensor_id,
                p.sensorDataMapping,
                style
            )
            stroke.start_parameter = p.startParameter
            stroke.end_parameter = p.endParameter
            stroke.red = list(p.red)
            stroke.green = list(p.green)
            stroke.blue = list(p.blue)
            stroke.alpha = list(p.alpha)
            stroke.splines_x = list(p.splineX)
            stroke.splines_y = list(p.splineY)
            stroke.splines_z = list(p.splineZ)
            stroke.sizes = list(p.size)
            stroke.rotations = list(p.rotation)
            stroke.scales_x = list(p.scaleX)
            stroke.scales_y = list(p.scaleY)
            stroke.scales_z = list(p.scaleZ)
            stroke.offsets_x = list(p.offsetX)
            stroke.offsets_y = list(p.offsetY)
            stroke.offsets_z = list(p.offsetZ)
            context.strokes.append(stroke)

    @classmethod
    def __parse_brushes__(cls, context: DecoderContext, brushes: uim_3_0_0.Brushes):
        # iterate over vector brushes
        for vectorBrush in brushes.vectorBrushes:
            prototypes: list = []
            for p in vectorBrush.prototype:
                if p.shapeURI:
                    brush_prototype: BrushPolygonUri = BrushPolygonUri(p.shapeURI, p.size)
                else:
                    points: list = []
                    for idx in range(len(p.coordX)):
                        points.append((p.coordX[idx], p.coordY[idx]))
                    brush_prototype: BrushPolygon = BrushPolygon(min_scale=p.size, points=points, indices=p.indices)
                prototypes.append(brush_prototype)
            brush: VectorBrush = VectorBrush(
                vectorBrush.name,
                prototypes,
                vectorBrush.spacing
            )
            context.ink_model.brushes.add_vector_brush(brush)
        # Iterate over raster brushes
        for rasterBrush in brushes.rasterBrushes:
            brush: RasterBrush = RasterBrush(
                rasterBrush.name,
                rasterBrush.spacing,
                rasterBrush.scattering,
                UIMDecoder300.MAP_ROTATION_MODE[rasterBrush.rotationMode],
                rasterBrush.shapeTexture,
                rasterBrush.shapeTextureURI,
                rasterBrush.fillTexture,
                rasterBrush.fillTextureURI,
                rasterBrush.fillWidth,
                rasterBrush.fillHeight,
                rasterBrush.randomizeFill,
                UIMDecoder300.MAP_BLEND_MODE[rasterBrush.blendMode]
            )
            context.ink_model.brushes.add_raster_brush(brush)

    @classmethod
    def __extract_bounding_box__(cls, rect: uim_3_0_0.Rectangle) -&gt; BoundingBox:
        if rect:
            return BoundingBox(rect.x, rect.y, rect.width, rect.height)
        return BoundingBox(0., 0., 0., 0.)

    @classmethod
    def __parse_ink_tree__(cls, context: DecoderContext, proto_tree: List[uim_3_0_0.Node], view: str):
        stack: List[StrokeGroupNode] = []
        # Sanity checks
        if proto_tree is None or len(proto_tree) == 0:
            raise FormatException(&#34;Tree is empty&#34;)
        if proto_tree[0].depth:
            raise FormatException(&#34;Tree root depth must be 0&#34;)
        # Differentiate between main tree and view
        if view == CommonViews.MAIN_INK_TREE.value:
            tree: InkTree = InkTree(view)
            context.ink_model.ink_tree = tree
        else:
            tree: InkTree = InkTree(view)
            context.ink_model.add_tree(tree)
        # Root element
        root_id: str = proto_tree[0].id
        prev_node: StrokeGroupNode = StrokeGroupNode(Identifier.str_to_uimid(root_id))
        tree.root = prev_node
        tree.root.group_bounding_box = UIMDecoder300.__extract_bounding_box__(proto_tree[0].groupBoundingBox)
        # Parent
        parent: StrokeGroupNode = tree.root
        # Iterate over all children of root
        for node_idx in range(1, len(proto_tree)):
            node: uim_3_0_0.Node = proto_tree[node_idx]
            if node.depth &gt; len(stack):
                stack.append(parent)
                parent = prev_node
            elif node.depth &lt; len(stack):
                while node.depth &lt; len(stack):
                    parent = stack.pop()

            bbox: BoundingBox = UIMDecoder300.__extract_bounding_box__(node.groupBoundingBox)
            # Handle different node types
            if node.type == uim_3_0_0.STROKE_GROUP:  # Stroke Group Node
                group_id: uuid.UUID = Identifier.str_to_uimid(node.id)
                new_node: StrokeGroupNode = StrokeGroupNode(group_id)
                new_node.group_bounding_box = bbox
                # remember current node
                prev_node = new_node
            else:  # Stroke Node
                index: int = node.index
                if index &gt; len(context.strokes):
                    raise FormatException(f&#34;Reference stroke with index:= {index} does not exist in UIM.&#34;)
                stroke: Stroke = context.strokes[index]
                # Create Stroke node
                new_node: StrokeNode = StrokeNode(stroke=stroke, fragment=None)
                new_node.group_bounding_box = bbox
            parent.add(new_node)

    @classmethod
    def __parse_knowledge_graph__(cls, context: DecoderContext, knowledge_graph: uim_3_0_0.TripleStore):
        for el in knowledge_graph.statements:
            if el.subject != &#39;&#39;:
                context.ink_model.add_semantic_triple(el.subject, el.predicate, el.object)

    @classmethod
    def __parse_transform__(cls, document, ink_object: InkModel):
        &#34;&#34;&#34;Parse transformation matrix message (Matrix4).&#34;&#34;&#34;
        t = document.transform
        matrix: list = [
            [t.m00, t.m01, t.m02, t.m03],
            [t.m10, t.m11, t.m12, t.m13],
            [t.m20, t.m21, t.m22, t.m23],
            [t.m30, t.m31, t.m32, t.m33],
        ]
        ink_object.transform = matrix</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="uim.codec.parser.decoder.decoder_3_0_0.UIMDecoder300"><code class="flex name class">
<span>class <span class="ident">UIMDecoder300</span></span>
</code></dt>
<dd>
<div class="desc"><p>The UIMDecoder300 decodes the Universal Ink Model v3.0.0 and maps it into the model for v3.1.0.</p>
<h2 id="references">References</h2>
<p>[1]
Universal Ink Model documentation - URL <a href="https://developer-docs.wacom.com/sdk-for-ink/docs/model">https://developer-docs.wacom.com/sdk-for-ink/docs/model</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UIMDecoder300(CodecDecoder):
    &#34;&#34;&#34;
    The UIMDecoder300 decodes the Universal Ink Model v3.0.0 and maps it into the model for v3.1.0.

    References
    ----------
    [1]  Universal Ink Model documentation - URL https://developer-docs.wacom.com/sdk-for-ink/docs/model
    &#34;&#34;&#34;

    MAP_INK_METRICS_TYPE: Dict[int, InkSensorMetricType] = {
        uim_3_0_0.LENGTH: InkSensorMetricType.LENGTH,
        uim_3_0_0.TIME: InkSensorMetricType.TIME,
        uim_3_0_0.FORCE: InkSensorMetricType.FORCE,
        uim_3_0_0.ANGLE: InkSensorMetricType.ANGLE,
        uim_3_0_0.NORMALIZED: InkSensorMetricType.NORMALIZED
    }
    &#34;&#34;&#34;Mapping metric types from UIM v3.0.0 to internal enum.&#34;&#34;&#34;

    MAP_STATE_TYPE: Dict[int, InkState] = {
        uim_3_0_0.PLANE: InkState.PLANE,
        uim_3_0_0.HOVERING: InkState.HOVERING,
        uim_3_0_0.IN_VOLUME: InkState.IN_VOLUME,
        uim_3_0_0.VOLUME_HOVERING: InkState.VOLUME_HOVERING
    }
    &#34;&#34;&#34;Mapping of the uim input data states.&#34;&#34;&#34;

    MAP_CHANNEL_TYPE: Dict[int, InkSensorType] = {
        InkSensorType.X.value: InkSensorType.X,
        InkSensorType.Y.value: InkSensorType.Y,
        InkSensorType.Z.value: InkSensorType.Z,
        InkSensorType.TIMESTAMP.value: InkSensorType.TIMESTAMP,
        InkSensorType.PRESSURE.value: InkSensorType.PRESSURE,
        InkSensorType.AZIMUTH.value: InkSensorType.AZIMUTH,
        InkSensorType.ALTITUDE.value: InkSensorType.ALTITUDE,
        InkSensorType.ROTATION.value: InkSensorType.ROTATION,
        InkSensorType.RADIUS_X.value: InkSensorType.RADIUS_X,
        InkSensorType.RADIUS_Y.value: InkSensorType.RADIUS_Y
    }
    &#34;&#34;&#34;Mapping for channel type.&#34;&#34;&#34;

    MAP_INPUT_PROVIDER_TYPE: Dict[int, InkInputType] = {
        InkInputType.PEN.value: InkInputType.PEN,
        InkInputType.TOUCH.value: InkInputType.TOUCH,
        InkInputType.CONTROLLER.value: InkInputType.CONTROLLER,
        InkInputType.MOUSE.value: InkInputType.MOUSE
    }
    &#34;&#34;&#34;Mapping for input provider.&#34;&#34;&#34;

    MAP_BLEND_MODE: Dict[int, BlendMode] = {
        uim_3_0_0.SOURCE_OVER: BlendMode.SOURCE_OVER,
        uim_3_0_0.DESTINATION_OVER: BlendMode.DESTINATION_OVER,
        uim_3_0_0.DESTINATION_OUT: BlendMode.DESTINATION_OUT,
        uim_3_0_0.LIGHTER: BlendMode.LIGHTER,
        uim_3_0_0.COPY: BlendMode.COPY,
        uim_3_0_0.MIN: BlendMode.MIN,
        uim_3_0_0.MAX: BlendMode.MAX
    }
    &#34;&#34;&#34;Mapping for blending mode.&#34;&#34;&#34;

    # Map for rotation mode
    MAP_ROTATION_MODE: Dict[int, RotationMode] = {
        uim_3_0_0.NONE: RotationMode.NONE,
        uim_3_0_0.RANDOM: RotationMode.RANDOM,
        uim_3_0_0.TRAJECTORY: RotationMode.TRAJECTORY
    }

    def __init__(self):
        pass

    @classmethod
    def decode(cls, riff: BytesIO, size_head: int) -&gt; InkModel:
        &#34;&#34;&#34;
        Decoding Universal Ink Model (RIFF / Protobuf encoded) content file.

        Parameters
        ----------
        riff: `BytesIO`
            RIFF content with encoded UIM v3.0.0 content.
        size_head: `int`
            Size of  the header

        Returns
        -------
            model - `InkModel`
                Parsed `InkModel` from UIM v3.0.0 ink content
        &#34;&#34;&#34;
        riff.read((size_head - 3) + 1)
        if riff.read(4) != DATA_HEADER:
            raise FormatException(&#39;Data header missing.&#39;)
        data_size = ctypes.c_uint32(int.from_bytes(riff.read(4), byteorder=&#39;little&#39;)).value
        message: bytes = riff.read(data_size)
        # read document
        document: uim_3_0_0.InkObject = uim_3_0_0.InkObject()
        document.ParseFromString(message)
        return UIMDecoder300.decode_document(document)

    @classmethod
    def decode_json(cls, fp: BinaryIO) -&gt; InkModel:
        &#34;&#34;&#34;
        Decoding Universal Ink Model (JSON Protobuf encoded) content file.

        Parameters
        ----------
        fp: `BinaryIO`
            JSON with encoded UIM v3.0.0 content.

        Returns
        -------
            model - `InkModel`
                Parsed `InkModel` from UIM v3.0.0 ink content
        &#34;&#34;&#34;
        message = fp.read()
        document: uim_3_0_0.InkObject = uim_3_0_0.InkObject()
        document: uim_3_0_0.InkObject = json_format.Parse(message, document)
        return UIMDecoder300.decode_document(document)

    @classmethod
    def decode_document(cls, document: uim_3_0_0.InkObject) -&gt; InkModel:
        &#34;&#34;&#34;
        Decoding Protobuf content file.

        Parameters
        ----------
        document: `uim_3_0_0.InkObject`
            Parsed protobuf structure.

        Returns
        -------
            model - `InkModel`
                Parsed `InkModel` from UIM v3.0.0 ink content
        &#34;&#34;&#34;
        context: DecoderContext = DecoderContext(version=SupportedFormats.UIM_VERSION_3_0_0.value,
                                                 ink_model=InkModel(SupportedFormats.UIM_VERSION_3_0_0.value))
        # Set properties
        context.ink_model.properties = CodecDecoder.__parse_properties__(document.properties)
        # Parse input data
        UIMDecoder300.__parse_input_data__(context, document.inputData)
        # Parse ink data
        UIMDecoder300.__parse_ink_data__(context, document.inkData)
        # Parse brushes
        UIMDecoder300.__parse_brushes__(context, document.brushes)
        # Parse main tree
        UIMDecoder300.__parse_ink_tree__(context, document.inkTree, CommonViews.MAIN_INK_TREE.value)
        # Parse view
        for view in document.views:
            UIMDecoder300.__parse_ink_tree__(context, view.tree, view.name)
        # Parse knowledge graph
        UIMDecoder300.__parse_knowledge_graph__(context, document.knowledgeGraph)
        # Finally upgrade the URIs
        context.upgrade_uris()
        return context.ink_model

    @classmethod
    def __parse_input_data__(cls, context: DecoderContext, input_data: uim_3_0_0.InputData):
        input_context_data: uim_3_0_0.InputContextData = input_data.inputContextData
        # Parse Input Contexts
        for inputContext in input_context_data.inputContexts:
            input_context: InputContext = InputContext(
                UUIDIdentifier.str_to_uimid(inputContext.id),
                UUIDIdentifier.str_to_uimid(inputContext.environmentID),
                UUIDIdentifier.str_to_uimid(inputContext.sensorContextID))
            context.ink_model.input_configuration.input_contexts.append(input_context)

        # Parse Ink Input Providers
        for inkInputProvider in input_context_data.inkInputProviders:
            properties = CodecDecoder.__parse_properties__(inkInputProvider.properties)
            ink_input_provider = InkInputProvider(
                UUIDIdentifier.str_to_uimid(inkInputProvider.id),
                UIMDecoder300.MAP_INPUT_PROVIDER_TYPE[inkInputProvider.type],
                properties
            )
            context.ink_model.input_configuration.ink_input_providers.append(ink_input_provider)

        # Parse Input Devices
        for inputDevice in input_context_data.inputDevices:
            properties = CodecDecoder.__parse_properties__(inputDevice.properties)
            input_device: InputDevice = InputDevice(
                UUIDIdentifier.str_to_uimid(inputDevice.id),
                properties
            )
            context.ink_model.input_configuration.devices.append(input_device)

        # Parse Environments
        for environment in input_context_data.environments:
            properties = CodecDecoder.__parse_properties__(environment.properties)
            environment = Environment(UUIDIdentifier.str_to_uimid(environment.id), properties)
            context.ink_model.input_configuration.environments.append(environment)

        # Parse Sensor Data Contexts
        for sensorContext in input_context_data.sensorContexts:
            sensor_channels_contexts: list = []

            # Parse Sensor Channels Contexts
            for sensorChannelsContext in sensorContext.sensorChannelsContext:
                channels: list = []
                input_provider_uuid: Optional[uuid.UUID] = None
                if sensorChannelsContext.inkInputProviderID:
                    input_provider_uuid = Identifier.str_to_uimid(sensorChannelsContext.inkInputProviderID)
                # Parse Sensor Channels
                for sensorChannel in sensorChannelsContext.channels:
                    sensor_channel: SensorChannel = SensorChannel(
                        UUIDIdentifier.str_to_uimid(sensorChannel.id),
                        UIMDecoder300.MAP_CHANNEL_TYPE[sensorChannel.type],
                        UIMDecoder300.MAP_INK_METRICS_TYPE[sensorChannel.metric],
                        sensorChannel.resolution,
                        sensorChannel.min,
                        sensorChannel.max,
                        sensorChannel.precision,
                        data_type=DataType.FLOAT32,
                        ink_input_provider_id=input_provider_uuid,
                        input_device_id=Identifier.str_to_uimid(sensorChannelsContext.inputDeviceID)
                    )
                    channels.append(sensor_channel)
                input_provider_uuid: Optional[uuid.UUID] = None
                if sensorChannelsContext.inkInputProviderID:
                    input_provider_uuid = Identifier.str_to_uimid(sensorChannelsContext.inkInputProviderID)
                sensor_channel_context: SensorChannelsContext = SensorChannelsContext(
                    Identifier.str_to_uimid(sensorChannelsContext.id),
                    channels,
                    sensorChannelsContext.samplingRateHint.value,
                    sensorChannelsContext.latency.value,
                    input_provider_uuid,
                    Identifier.str_to_uimid(sensorChannelsContext.inputDeviceID),
                )
                sensor_channels_contexts.append(sensor_channel_context)
            sensor_context: SensorContext = SensorContext(
                Identifier.str_to_uimid(sensorContext.id),
                sensor_channels_contexts
            )
            context.ink_model.input_configuration.sensor_contexts.append(sensor_context)

        # Parse Sensor Data
        sensor_data_array: list = []
        for sensorData in input_data.sensorData:
            input_context: InputContext = context.ink_model. \
                input_configuration.get_input_context(Identifier.str_to_uimid(sensorData.inputContextID))
            sensor_ctx: SensorContext = context.ink_model.input_configuration. \
                get_sensor_context(input_context.sensor_context_id)
            # Add sensor data
            sensor_data: SensorData = SensorData(
                Identifier.str_to_uimid(sensorData.id),
                Identifier.str_to_uimid(sensorData.inputContextID),
                UIMDecoder300.MAP_STATE_TYPE[sensorData.state],
                sensorData.timestamp
            )
            for dataChannel in sensorData.dataChannels:
                sensor_type: SensorChannel = sensor_ctx.get_channel_by_id(
                    Identifier.str_to_uimid(dataChannel.sensorChannelID)
                )
                if sensor_type.type == InkSensorType.TIMESTAMP:
                    ctx: SensorChannel = sensor_ctx.get_channel_by_id(
                        Identifier.str_to_uimid(dataChannel.sensorChannelID))
                    channel_data: ChannelData = ChannelData(
                        Identifier.str_to_uimid(dataChannel.sensorChannelID),
                        CodecDecoder.__decode__(dataChannel.values, ctx.precision, ctx.resolution,
                                                start_value=sensorData.timestamp, data_type=float),
                    )
                else:
                    ctx: SensorChannel = sensor_ctx.get_channel_by_id(
                        Identifier.str_to_uimid(dataChannel.sensorChannelID)
                    )
                    channel_data: ChannelData = ChannelData(
                        Identifier.str_to_uimid(dataChannel.sensorChannelID),
                        CodecDecoder.__decode__(dataChannel.values, ctx.precision, ctx.resolution),
                    )
                sensor_data.add_data(sensor_type, channel_data.values)

            sensor_data_array.append(sensor_data)

        context.ink_model.sensor_data.sensor_data = sensor_data_array

    @classmethod
    def __parse_ink_data__(cls, context: DecoderContext, ink_data: uim_3_0_0.InkData):
        # Iterate over strokes
        for p in ink_data.strokes:
            properties = p.style.properties
            path_point_properties: PathPointProperties = PathPointProperties(
                properties.size.value,
                properties.red.value,
                properties.green.value,
                properties.blue.value,
                properties.alpha.value,
                properties.rotation.value,
                properties.scaleX.value,
                properties.scaleY.value,
                properties.scaleZ.value,
                properties.offsetX.value,
                properties.offsetY.value,
                properties.offsetZ.value,
            )
            style: Style = Style(
                path_point_properties,
                p.style.brushURI,
                p.style.particlesRandomSeed,
                p.style.renderModeURI
            )
            sensor_id: Optional[uuid.UUID] = None
            if p.sensorDataID:
                sensor_id = Identifier.str_to_uimid(p.sensorDataID)
            stroke: Stroke = Stroke(
                Identifier.str_to_uimid(p.id),
                p.sensorDataOffset,
                sensor_id,
                p.sensorDataMapping,
                style
            )
            stroke.start_parameter = p.startParameter
            stroke.end_parameter = p.endParameter
            stroke.red = list(p.red)
            stroke.green = list(p.green)
            stroke.blue = list(p.blue)
            stroke.alpha = list(p.alpha)
            stroke.splines_x = list(p.splineX)
            stroke.splines_y = list(p.splineY)
            stroke.splines_z = list(p.splineZ)
            stroke.sizes = list(p.size)
            stroke.rotations = list(p.rotation)
            stroke.scales_x = list(p.scaleX)
            stroke.scales_y = list(p.scaleY)
            stroke.scales_z = list(p.scaleZ)
            stroke.offsets_x = list(p.offsetX)
            stroke.offsets_y = list(p.offsetY)
            stroke.offsets_z = list(p.offsetZ)
            context.strokes.append(stroke)

    @classmethod
    def __parse_brushes__(cls, context: DecoderContext, brushes: uim_3_0_0.Brushes):
        # iterate over vector brushes
        for vectorBrush in brushes.vectorBrushes:
            prototypes: list = []
            for p in vectorBrush.prototype:
                if p.shapeURI:
                    brush_prototype: BrushPolygonUri = BrushPolygonUri(p.shapeURI, p.size)
                else:
                    points: list = []
                    for idx in range(len(p.coordX)):
                        points.append((p.coordX[idx], p.coordY[idx]))
                    brush_prototype: BrushPolygon = BrushPolygon(min_scale=p.size, points=points, indices=p.indices)
                prototypes.append(brush_prototype)
            brush: VectorBrush = VectorBrush(
                vectorBrush.name,
                prototypes,
                vectorBrush.spacing
            )
            context.ink_model.brushes.add_vector_brush(brush)
        # Iterate over raster brushes
        for rasterBrush in brushes.rasterBrushes:
            brush: RasterBrush = RasterBrush(
                rasterBrush.name,
                rasterBrush.spacing,
                rasterBrush.scattering,
                UIMDecoder300.MAP_ROTATION_MODE[rasterBrush.rotationMode],
                rasterBrush.shapeTexture,
                rasterBrush.shapeTextureURI,
                rasterBrush.fillTexture,
                rasterBrush.fillTextureURI,
                rasterBrush.fillWidth,
                rasterBrush.fillHeight,
                rasterBrush.randomizeFill,
                UIMDecoder300.MAP_BLEND_MODE[rasterBrush.blendMode]
            )
            context.ink_model.brushes.add_raster_brush(brush)

    @classmethod
    def __extract_bounding_box__(cls, rect: uim_3_0_0.Rectangle) -&gt; BoundingBox:
        if rect:
            return BoundingBox(rect.x, rect.y, rect.width, rect.height)
        return BoundingBox(0., 0., 0., 0.)

    @classmethod
    def __parse_ink_tree__(cls, context: DecoderContext, proto_tree: List[uim_3_0_0.Node], view: str):
        stack: List[StrokeGroupNode] = []
        # Sanity checks
        if proto_tree is None or len(proto_tree) == 0:
            raise FormatException(&#34;Tree is empty&#34;)
        if proto_tree[0].depth:
            raise FormatException(&#34;Tree root depth must be 0&#34;)
        # Differentiate between main tree and view
        if view == CommonViews.MAIN_INK_TREE.value:
            tree: InkTree = InkTree(view)
            context.ink_model.ink_tree = tree
        else:
            tree: InkTree = InkTree(view)
            context.ink_model.add_tree(tree)
        # Root element
        root_id: str = proto_tree[0].id
        prev_node: StrokeGroupNode = StrokeGroupNode(Identifier.str_to_uimid(root_id))
        tree.root = prev_node
        tree.root.group_bounding_box = UIMDecoder300.__extract_bounding_box__(proto_tree[0].groupBoundingBox)
        # Parent
        parent: StrokeGroupNode = tree.root
        # Iterate over all children of root
        for node_idx in range(1, len(proto_tree)):
            node: uim_3_0_0.Node = proto_tree[node_idx]
            if node.depth &gt; len(stack):
                stack.append(parent)
                parent = prev_node
            elif node.depth &lt; len(stack):
                while node.depth &lt; len(stack):
                    parent = stack.pop()

            bbox: BoundingBox = UIMDecoder300.__extract_bounding_box__(node.groupBoundingBox)
            # Handle different node types
            if node.type == uim_3_0_0.STROKE_GROUP:  # Stroke Group Node
                group_id: uuid.UUID = Identifier.str_to_uimid(node.id)
                new_node: StrokeGroupNode = StrokeGroupNode(group_id)
                new_node.group_bounding_box = bbox
                # remember current node
                prev_node = new_node
            else:  # Stroke Node
                index: int = node.index
                if index &gt; len(context.strokes):
                    raise FormatException(f&#34;Reference stroke with index:= {index} does not exist in UIM.&#34;)
                stroke: Stroke = context.strokes[index]
                # Create Stroke node
                new_node: StrokeNode = StrokeNode(stroke=stroke, fragment=None)
                new_node.group_bounding_box = bbox
            parent.add(new_node)

    @classmethod
    def __parse_knowledge_graph__(cls, context: DecoderContext, knowledge_graph: uim_3_0_0.TripleStore):
        for el in knowledge_graph.statements:
            if el.subject != &#39;&#39;:
                context.ink_model.add_semantic_triple(el.subject, el.predicate, el.object)

    @classmethod
    def __parse_transform__(cls, document, ink_object: InkModel):
        &#34;&#34;&#34;Parse transformation matrix message (Matrix4).&#34;&#34;&#34;
        t = document.transform
        matrix: list = [
            [t.m00, t.m01, t.m02, t.m03],
            [t.m10, t.m11, t.m12, t.m13],
            [t.m20, t.m21, t.m22, t.m23],
            [t.m30, t.m31, t.m32, t.m33],
        ]
        ink_object.transform = matrix</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="uim.codec.parser.decoder.base.CodecDecoder" href="base.html#uim.codec.parser.decoder.base.CodecDecoder">CodecDecoder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="uim.codec.parser.decoder.decoder_3_0_0.UIMDecoder300.MAP_BLEND_MODE"><code class="name">var <span class="ident">MAP_BLEND_MODE</span> : Dict[int, <a title="uim.model.inkdata.brush.BlendMode" href="../../../model/inkdata/brush.html#uim.model.inkdata.brush.BlendMode">BlendMode</a>]</code></dt>
<dd>
<div class="desc"><p>Mapping for blending mode.</p></div>
</dd>
<dt id="uim.codec.parser.decoder.decoder_3_0_0.UIMDecoder300.MAP_CHANNEL_TYPE"><code class="name">var <span class="ident">MAP_CHANNEL_TYPE</span> : Dict[int, <a title="uim.model.inkinput.inputdata.InkSensorType" href="../../../model/inkinput/inputdata.html#uim.model.inkinput.inputdata.InkSensorType">InkSensorType</a>]</code></dt>
<dd>
<div class="desc"><p>Mapping for channel type.</p></div>
</dd>
<dt id="uim.codec.parser.decoder.decoder_3_0_0.UIMDecoder300.MAP_INK_METRICS_TYPE"><code class="name">var <span class="ident">MAP_INK_METRICS_TYPE</span> : Dict[int, <a title="uim.model.inkinput.inputdata.InkSensorMetricType" href="../../../model/inkinput/inputdata.html#uim.model.inkinput.inputdata.InkSensorMetricType">InkSensorMetricType</a>]</code></dt>
<dd>
<div class="desc"><p>Mapping metric types from UIM v3.0.0 to internal enum.</p></div>
</dd>
<dt id="uim.codec.parser.decoder.decoder_3_0_0.UIMDecoder300.MAP_INPUT_PROVIDER_TYPE"><code class="name">var <span class="ident">MAP_INPUT_PROVIDER_TYPE</span> : Dict[int, <a title="uim.model.inkinput.inputdata.InkInputType" href="../../../model/inkinput/inputdata.html#uim.model.inkinput.inputdata.InkInputType">InkInputType</a>]</code></dt>
<dd>
<div class="desc"><p>Mapping for input provider.</p></div>
</dd>
<dt id="uim.codec.parser.decoder.decoder_3_0_0.UIMDecoder300.MAP_ROTATION_MODE"><code class="name">var <span class="ident">MAP_ROTATION_MODE</span> : Dict[int, <a title="uim.model.inkdata.brush.RotationMode" href="../../../model/inkdata/brush.html#uim.model.inkdata.brush.RotationMode">RotationMode</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="uim.codec.parser.decoder.decoder_3_0_0.UIMDecoder300.MAP_STATE_TYPE"><code class="name">var <span class="ident">MAP_STATE_TYPE</span> : Dict[int, <a title="uim.model.inkinput.sensordata.InkState" href="../../../model/inkinput/sensordata.html#uim.model.inkinput.sensordata.InkState">InkState</a>]</code></dt>
<dd>
<div class="desc"><p>Mapping of the uim input data states.</p></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="uim.codec.parser.decoder.decoder_3_0_0.UIMDecoder300.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>riff: _io.BytesIO, size_head: int) ‑> <a title="uim.model.ink.InkModel" href="../../../model/ink.html#uim.model.ink.InkModel">InkModel</a></span>
</code></dt>
<dd>
<div class="desc"><p>Decoding Universal Ink Model (RIFF / Protobuf encoded) content file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>riff</code></strong> :&ensp;<code>BytesIO</code></dt>
<dd>RIFF content with encoded UIM v3.0.0 content.</dd>
<dt><strong><code>size_head</code></strong> :&ensp;<code>int</code></dt>
<dd>Size of
the header</dd>
</dl>
<h2 id="returns">Returns</h2>
<pre><code>model - &lt;code&gt;InkModel&lt;/code&gt;
    Parsed &lt;code&gt;InkModel&lt;/code&gt; from UIM v3.0.0 ink content
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def decode(cls, riff: BytesIO, size_head: int) -&gt; InkModel:
    &#34;&#34;&#34;
    Decoding Universal Ink Model (RIFF / Protobuf encoded) content file.

    Parameters
    ----------
    riff: `BytesIO`
        RIFF content with encoded UIM v3.0.0 content.
    size_head: `int`
        Size of  the header

    Returns
    -------
        model - `InkModel`
            Parsed `InkModel` from UIM v3.0.0 ink content
    &#34;&#34;&#34;
    riff.read((size_head - 3) + 1)
    if riff.read(4) != DATA_HEADER:
        raise FormatException(&#39;Data header missing.&#39;)
    data_size = ctypes.c_uint32(int.from_bytes(riff.read(4), byteorder=&#39;little&#39;)).value
    message: bytes = riff.read(data_size)
    # read document
    document: uim_3_0_0.InkObject = uim_3_0_0.InkObject()
    document.ParseFromString(message)
    return UIMDecoder300.decode_document(document)</code></pre>
</details>
</dd>
<dt id="uim.codec.parser.decoder.decoder_3_0_0.UIMDecoder300.decode_document"><code class="name flex">
<span>def <span class="ident">decode_document</span></span>(<span>document: will_3_pb2.InkObject) ‑> <a title="uim.model.ink.InkModel" href="../../../model/ink.html#uim.model.ink.InkModel">InkModel</a></span>
</code></dt>
<dd>
<div class="desc"><p>Decoding Protobuf content file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>document</code></strong> :&ensp;<code>uim_3_0_0.InkObject</code></dt>
<dd>Parsed protobuf structure.</dd>
</dl>
<h2 id="returns">Returns</h2>
<pre><code>model - &lt;code&gt;InkModel&lt;/code&gt;
    Parsed &lt;code&gt;InkModel&lt;/code&gt; from UIM v3.0.0 ink content
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def decode_document(cls, document: uim_3_0_0.InkObject) -&gt; InkModel:
    &#34;&#34;&#34;
    Decoding Protobuf content file.

    Parameters
    ----------
    document: `uim_3_0_0.InkObject`
        Parsed protobuf structure.

    Returns
    -------
        model - `InkModel`
            Parsed `InkModel` from UIM v3.0.0 ink content
    &#34;&#34;&#34;
    context: DecoderContext = DecoderContext(version=SupportedFormats.UIM_VERSION_3_0_0.value,
                                             ink_model=InkModel(SupportedFormats.UIM_VERSION_3_0_0.value))
    # Set properties
    context.ink_model.properties = CodecDecoder.__parse_properties__(document.properties)
    # Parse input data
    UIMDecoder300.__parse_input_data__(context, document.inputData)
    # Parse ink data
    UIMDecoder300.__parse_ink_data__(context, document.inkData)
    # Parse brushes
    UIMDecoder300.__parse_brushes__(context, document.brushes)
    # Parse main tree
    UIMDecoder300.__parse_ink_tree__(context, document.inkTree, CommonViews.MAIN_INK_TREE.value)
    # Parse view
    for view in document.views:
        UIMDecoder300.__parse_ink_tree__(context, view.tree, view.name)
    # Parse knowledge graph
    UIMDecoder300.__parse_knowledge_graph__(context, document.knowledgeGraph)
    # Finally upgrade the URIs
    context.upgrade_uris()
    return context.ink_model</code></pre>
</details>
</dd>
<dt id="uim.codec.parser.decoder.decoder_3_0_0.UIMDecoder300.decode_json"><code class="name flex">
<span>def <span class="ident">decode_json</span></span>(<span>fp: <class 'BinaryIO'>) ‑> <a title="uim.model.ink.InkModel" href="../../../model/ink.html#uim.model.ink.InkModel">InkModel</a></span>
</code></dt>
<dd>
<div class="desc"><p>Decoding Universal Ink Model (JSON Protobuf encoded) content file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fp</code></strong> :&ensp;<code>BinaryIO</code></dt>
<dd>JSON with encoded UIM v3.0.0 content.</dd>
</dl>
<h2 id="returns">Returns</h2>
<pre><code>model - &lt;code&gt;InkModel&lt;/code&gt;
    Parsed &lt;code&gt;InkModel&lt;/code&gt; from UIM v3.0.0 ink content
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def decode_json(cls, fp: BinaryIO) -&gt; InkModel:
    &#34;&#34;&#34;
    Decoding Universal Ink Model (JSON Protobuf encoded) content file.

    Parameters
    ----------
    fp: `BinaryIO`
        JSON with encoded UIM v3.0.0 content.

    Returns
    -------
        model - `InkModel`
            Parsed `InkModel` from UIM v3.0.0 ink content
    &#34;&#34;&#34;
    message = fp.read()
    document: uim_3_0_0.InkObject = uim_3_0_0.InkObject()
    document: uim_3_0_0.InkObject = json_format.Parse(message, document)
    return UIMDecoder300.decode_document(document)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="uim.codec.parser.decoder" href="index.html">uim.codec.parser.decoder</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="uim.codec.parser.decoder.decoder_3_0_0.UIMDecoder300" href="#uim.codec.parser.decoder.decoder_3_0_0.UIMDecoder300">UIMDecoder300</a></code></h4>
<ul class="">
<li><code><a title="uim.codec.parser.decoder.decoder_3_0_0.UIMDecoder300.MAP_BLEND_MODE" href="#uim.codec.parser.decoder.decoder_3_0_0.UIMDecoder300.MAP_BLEND_MODE">MAP_BLEND_MODE</a></code></li>
<li><code><a title="uim.codec.parser.decoder.decoder_3_0_0.UIMDecoder300.MAP_CHANNEL_TYPE" href="#uim.codec.parser.decoder.decoder_3_0_0.UIMDecoder300.MAP_CHANNEL_TYPE">MAP_CHANNEL_TYPE</a></code></li>
<li><code><a title="uim.codec.parser.decoder.decoder_3_0_0.UIMDecoder300.MAP_INK_METRICS_TYPE" href="#uim.codec.parser.decoder.decoder_3_0_0.UIMDecoder300.MAP_INK_METRICS_TYPE">MAP_INK_METRICS_TYPE</a></code></li>
<li><code><a title="uim.codec.parser.decoder.decoder_3_0_0.UIMDecoder300.MAP_INPUT_PROVIDER_TYPE" href="#uim.codec.parser.decoder.decoder_3_0_0.UIMDecoder300.MAP_INPUT_PROVIDER_TYPE">MAP_INPUT_PROVIDER_TYPE</a></code></li>
<li><code><a title="uim.codec.parser.decoder.decoder_3_0_0.UIMDecoder300.MAP_ROTATION_MODE" href="#uim.codec.parser.decoder.decoder_3_0_0.UIMDecoder300.MAP_ROTATION_MODE">MAP_ROTATION_MODE</a></code></li>
<li><code><a title="uim.codec.parser.decoder.decoder_3_0_0.UIMDecoder300.MAP_STATE_TYPE" href="#uim.codec.parser.decoder.decoder_3_0_0.UIMDecoder300.MAP_STATE_TYPE">MAP_STATE_TYPE</a></code></li>
<li><code><a title="uim.codec.parser.decoder.decoder_3_0_0.UIMDecoder300.decode" href="#uim.codec.parser.decoder.decoder_3_0_0.UIMDecoder300.decode">decode</a></code></li>
<li><code><a title="uim.codec.parser.decoder.decoder_3_0_0.UIMDecoder300.decode_document" href="#uim.codec.parser.decoder.decoder_3_0_0.UIMDecoder300.decode_document">decode_document</a></code></li>
<li><code><a title="uim.codec.parser.decoder.decoder_3_0_0.UIMDecoder300.decode_json" href="#uim.codec.parser.decoder.decoder_3_0_0.UIMDecoder300.decode_json">decode_json</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>